
<!DOCTYPE html><html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.28.1" theme-name="Stellar" theme-version="1.28.1">
  
  <meta name="generator" content="Hexo 6.3.0">
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" media="(prefers-color-scheme: light)" content="#f9fafb">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#000">
  
  <title>OpenCV-Python 文档汉化 - 霜晴避风港</title>

  
    <meta name="description" content="OpenCV-Python 部分教程文档的汉化">
<meta property="og:type" content="article">
<meta property="og:title" content="OpenCV-Python 文档汉化">
<meta property="og:url" content="https://immortal3180.github.io/OpenCV-Python/index.html">
<meta property="og:site_name" content="霜晴避风港">
<meta property="og:description" content="OpenCV-Python 部分教程文档的汉化">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.gitmirror.com/immortal3180/Repo/main/img/GithubPicBed/20240825-/20240907122152.png">
<meta property="og:image" content="https://raw.gitmirror.com/immortal3180/Repo/main/img/GithubPicBed/20240825-/20240907133722.png">
<meta property="og:image" content="https://raw.gitmirror.com/immortal3180/Repo/main/img/GithubPicBed/20240825-/20240907201012.png">
<meta property="og:image" content="https://raw.gitmirror.com/immortal3180/Repo/main/img/GithubPicBed/20240825-/20240907201332.png">
<meta property="og:image" content="https://raw.gitmirror.com/immortal3180/Repo/main/img/GithubPicBed/20240825-/20240907202844.png">
<meta property="og:image" content="https://raw.gitmirror.com/immortal3180/Repo/main/img/GithubPicBed/20240825-/20240907203111.png">
<meta property="og:image" content="https://raw.gitmirror.com/immortal3180/Repo/main/img/GithubPicBed/20240825-/20240908124137.png">
<meta property="og:image" content="https://docs.opencv.org/4.10.0/translation.jpg">
<meta property="og:image" content="https://docs.opencv.org/4.10.0/rotation.jpg">
<meta property="og:image" content="https://docs.opencv.org/4.10.0/affine.jpg">
<meta property="og:image" content="https://docs.opencv.org/4.10.0/perspective.jpg">
<meta property="og:image" content="https://docs.opencv.org/4.10.0/doxygen.png">
<meta property="article:published_time" content="2024-08-26T02:22:22.000Z">
<meta property="article:modified_time" content="2026-01-18T20:19:01.596Z">
<meta property="article:author" content="霜晴">
<meta property="article:tag" content="OpenCV-Python">
<meta property="article:tag" content="OpenCV">
<meta property="article:tag" content="计算机视觉">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.gitmirror.com/immortal3180/Repo/main/img/GithubPicBed/20240825-/20240907122152.png">
  
  
  
  <meta name="keywords" content="OpenCV-Python,OpenCV,计算机视觉">

  <!-- feed -->
  

  <link rel="stylesheet" href="/css/main.css?v=1.28.1">

  
    <link rel="shortcut icon" href="/images/ciallo.apk.round.png">
  

  

  <script src="https://cdn.jsdelivr.net/npm/markmap-autoloader" defer></script>

  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-1C99YXK0WT"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-1C99YXK0WT');
  </script>
</head>
<body>

<div class="l_body s:aa content tech" id="start" layout="post" ><aside class="l_left"><div class="leftbar-container">


<header class="header"><div class="logo-wrap"><a class="avatar" href="/about/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="undefined" onerror="javascript:this.classList.add('error');this.src='/images/ciallo.apk.round.png';"></a><a class="title" href="/"><div class="main" ff="title">霜晴避风港</div><div class="sub cap">... la ringrazio.</div></a></div></header>

<div class="nav-area">
<div class="search-wrapper" id="search-wrapper"><form class="search-form"><a class="search-button" onclick="document.getElementById(&quot;search-input&quot;).focus();"><svg t="1705074644177" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></a><input type="text" class="search-input" id="search-input" placeholder="站内搜索"></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div>


<nav class="menu dis-select"><a class="nav-item" title="GitHub" target="_blank" rel="noopener" href="https://github.com/immortal3180" style="color:#000000"><img no-lazy src="/images/github-favicon.png" / onerror="javascript:this.classList.add('error');this.src='/images/ciallo.apk.round.png';"></a><a class="nav-item" title="Bilibili" target="_blank" rel="noopener" href="https://space.bilibili.com/641764776" style="color:#00a1d6"><img no-lazy src="/images/bilibili-favicon.ico" / onerror="javascript:this.classList.add('error');this.src='/images/ciallo.apk.round.png';"></a><a class="nav-item" title="友链" href="/friends/" style="color:#8de93f"><img no-lazy src="/images/link.svg" / onerror="javascript:this.classList.add('error');this.src='/images/ciallo.apk.round.png';"></a></nav>
</div>
<div class="widgets">

</div>

</div></aside><div class="l_main" id="main">





<div class="article banner top">
  <div class="content">
    <div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a>
<span class="sep"></span><a class="cap breadcrumb" href="/">文章</a></div>
<div class="flex-row" id="post-meta"><span class="text created">发布于：<time datetime="2024-08-26T02:22:22.000Z">2024-08-26</time></span><span class="sep updated"></span><span class="text updated">更新于：<time datetime="2026-01-18T20:19:01.596Z">2026-01-19</time></span></div></div></div>
    
    <div class="bottom only-title">
      
      <div class="text-area">
        <h1 class="text title"><span>OpenCV-Python 文档汉化</span></h1>
        
      </div>
    </div>
    
  </div>
  </div><article class="md-text content"><h2 id="OpenCV-Python-Tutorials-OpenCV-Python-教程"><a href="#OpenCV-Python-Tutorials-OpenCV-Python-教程" class="headerlink" title="OpenCV-Python Tutorials -  OpenCV-Python 教程"></a><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/d6/d00/tutorial_py_root.html"><strong>OpenCV-Python Tutorials</strong></a> -  OpenCV-Python 教程</h2><h3 id="Gui-Features-in-OpenCV-OpenCV的Gui特性"><a href="#Gui-Features-in-OpenCV-OpenCV的Gui特性" class="headerlink" title="Gui Features in OpenCV - OpenCV的Gui特性"></a><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/dc/d4d/tutorial_py_table_of_contents_gui.html"><strong>Gui Features in OpenCV</strong></a> - OpenCV的Gui特性</h3><p>(在这里，您将学习如何显示和保存图像和视频，控制鼠标事件和创建跟踪栏。)</p>
<h4 id="OpenCV-Python-图像处理入门"><a href="#OpenCV-Python-图像处理入门" class="headerlink" title="OpenCV-Python 图像处理入门"></a><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/db/deb/tutorial_display_image.html">OpenCV-Python 图像处理入门</a></h4><p><strong>上一篇教程:</strong> <a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/d6/d15/tutorial_building_tegra_cuda.html">Building OpenCV for Tegra with CUDA</a><br><strong>下一篇教程:</strong> <a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/d4/db1/tutorial_documentation.html">Writing documentation for OpenCV</a></p>
<table>
<thead>
<tr>
<th align="right">原作者</th>
<th align="left">Ana Huamán</th>
</tr>
</thead>
<tbody><tr>
<td align="right">兼容性</td>
<td align="left">OpenCV &gt;&#x3D; 3.4.4</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>警告</strong></p>
<p>​		本教程可能包含过时的信息。</p>
</blockquote>
<h5 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h5><p>在本教程中，您将学习如何:</p>
<ul>
<li>从文件中读取图像 (使用 <a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/d4/da8/group__imgcodecs.html#gab32ee19e22660912565f8140d0f675a8"><strong>cv::imread</strong></a>)</li>
<li>在 OpenCV 窗口中显示图像 (使用 <a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/d7/dfc/group__highgui.html#ga453d42fe4cb60e5723281a89973ee563"><strong>cv::imshow</strong></a>)</li>
<li>将图像写入文件 (使用 <a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/d4/da8/group__imgcodecs.html#ga8ac397bd09e48851665edbe12aa28f25"><strong>cv::imwrite</strong></a>)</li>
</ul>
<h5 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h5><ul>
<li><p><strong>可下载的源代码</strong>: Click <a target="_blank" rel="noopener" href="https://github.com/opencv/opencv/tree/4.x/samples/python/tutorial_code/introduction/display_image/display_image.py">here</a></p>
</li>
<li><p><strong>代码如下</strong>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">img = cv.imread(cv.samples.findFile(<span class="string">&quot;starry_night.jpg&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> img <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">	sys.exit(<span class="string">&quot;Could not read the image./找不到图像.&quot;</span>)</span><br><span class="line"></span><br><span class="line">cv.imshow(<span class="string">&quot;Display window&quot;</span>, img)</span><br><span class="line">k = cv.waitKey(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> k == <span class="built_in">ord</span>(<span class="string">&quot;s&quot;</span>):</span><br><span class="line">	cv.imwrite(<span class="string">&quot;starry_night.png&quot;</span>, img)</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h5><p>作为第一步，导入OpenCV python库。正确的方法是额外为其分配名称 <em>cv</em>，该名称在下面的代码中用于引用库。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> sys</span><br></pre></td></tr></table></figure>

<p>现在，让我们分析一下主代码。作为第一步，我们从 OpenCV 样本读取图像”starry_night.ipg”。为了做到这一点，调用 <a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/d4/da8/group__imgcodecs.html#gab32ee19e22660912565f8140d0f675a8">cv::imread</a> 函数使用第一个参数指定的文件路径加载图像。第二个参数是可选的，它指定了我们想要的图像格式。这可能是:</p>
<ul>
<li>IMREAD_COLOR 以 BGR 8位格式加载图像. 这是这里使用的<strong>默认值</strong>。</li>
<li>IMREAD_UNCHANGED 按原样加载图像(包括alpha通道，如果它存在的话)</li>
<li>IMREAD_GRAYSCALE 以灰度图形式加载图像</li>
</ul>
<p>读取后的图像数据将存储在 <a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/d3/d63/classcv_1_1Mat.html">cv::Mat </a>对象中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">img = cv.imread(cv.samples.findFile(<span class="string">&quot;starry_night.jpg&quot;</span>))</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong></p>
<p>OpenCV 提供了对 Windows位图(bmp)图像格式，便携式图像格式(pbm, pgm, ppm) 和 Sun raster(sr, ras)的支持。您也可以借助插件 (你需要在自行构建库时指定使用它们，不过在我们提供的包中，这些功能默认是包含的) 来加载如 JPEG (jpeg, jpg, jpe), JPEG 2000 (jp2 - codenamed in the CMake as Jasper), TIFF files (tiff, tif) 以及 portable network graphics (png) 一类的图像格式。 此外，OpenEXR也是一种可能性。</p>
</blockquote>
<p>之后，如果映像加载正确，则执行检查。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> img <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">	sys.exit(<span class="string">&quot;Could not read the image.&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>然后，调用 <a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/d7/dfc/group__highgui.html#ga453d42fe4cb60e5723281a89973ee563">cv::imshow</a> 函数以显示图像。第一个参数是窗口的标题，第二个参数是将要显示的 <a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/d3/d63/classcv_1_1Mat.html">cv::Mat </a>对象。</p>
<p>因为我们想要让我们的窗口直到用户按下任意按键前一直显示(否则这个项目会结束得太快)，我们使用 <a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/d7/dfc/group__highgui.html#ga5628525ad33f52eab17feebcfba38bd7">cv::waitKey</a> 函数，它的唯一参数是等待用户输入的时间(以毫秒为单位)。0表示永远等待。返回值是按下的键。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cv.imshow(<span class="string">&quot;Display window&quot;</span>, img)</span><br><span class="line">k = cv.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>最后，如果按下的键是“s”键，则将图像写入文件。为此 <a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/d4/da8/group__imgcodecs.html#ga8ac397bd09e48851665edbe12aa28f25">cv::imwrite</a> 函数被调用，其中包含文件路径和 作为一个参数的 <a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/d3/d63/classcv_1_1Mat.html">cv::Mat</a> 函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> k == <span class="built_in">ord</span>(<span class="string">&quot;s&quot;</span>):</span><br><span class="line">	cv.imwrite(<span class="string">&quot;starry_night.png&quot;</span>, img)</span><br></pre></td></tr></table></figure>

<p>[^注]: 本文翻译最初编辑于 2024.08.26，最终编辑于 2024.09.07</p>
<hr>
<h4 id="OpenCV-Python-视频处理入门"><a href="#OpenCV-Python-视频处理入门" class="headerlink" title="OpenCV-Python 视频处理入门"></a><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/dd/d43/tutorial_py_video_display.html">OpenCV-Python 视频处理入门</a></h4><h5 id="目标-1"><a href="#目标-1" class="headerlink" title="目标"></a>目标</h5><ul>
<li>学习读取视频，显示视频，保存视频。</li>
<li>学习从相机捕捉视频并显示。</li>
<li>您将学习这些函数 : <strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/d8/dfe/classcv_1_1VideoCapture.html">cv.VideoCapture()</a></strong>, <strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/dd/d9e/classcv_1_1VideoWriter.html">cv.VideoWriter()</a></strong></li>
</ul>
<h5 id="从摄像机捕捉视频"><a href="#从摄像机捕捉视频" class="headerlink" title="从摄像机捕捉视频"></a>从摄像机捕捉视频</h5><p>通常，我们必须用摄像机捕捉实时视频流。OpenCV 提供了一个非常简单的接口来做到这一点。让我们从摄像机中捕捉一段视频 (我用的是笔记本电脑的内置摄像头)，转换成灰度视频并显示。这只是一个简单的开始任务。</p>
<p>要捕获视频，需要创建一个 <strong>VideoCapture</strong> 对象。它的参数可以是设备索引或视频文件的名称。设备索引只是指定哪个相机的数字，通常会连接一台相机(就像我的情况一样)，所以我只用参数0(或-1)。您可以用参数1来选择第二个摄像机，以此类推。之后，您可以逐帧捕获。但最后，别忘了释放捕捉到的画面。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"></span><br><span class="line">cap = cv.VideoCapture(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> cap.isOpened():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Cannot open camera&quot;</span>)</span><br><span class="line">    exit()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># Capture frame-by-frame / 获取一帧</span></span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># if frame is read correctly ret is True / 如果frame被正确读取，ret为True</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Can&#x27;t receive frame (stream end?). Exiting ...&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># Our operations on the frame come here / 我们对坐标系的操作到这里</span></span><br><span class="line">    gray = cv.cvtColor(frame, cv.COLOR_BGR2GRAY)</span><br><span class="line">    <span class="comment"># Display the resulting frame</span></span><br><span class="line">    cv.imshow(<span class="string">&#x27;frame&#x27;</span>, gray)</span><br><span class="line">    <span class="keyword">if</span> cv.waitKey(<span class="number">1</span>) == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># When everything done, release the capture / 当一切完成后，释放捕获</span></span><br><span class="line">cap.release()</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<p><code>cap.read()</code> 返回一个bool值 (<code>True</code>&#x2F;<code>False</code>)。如果帧读取正确该值将变为 <code>True</code>. 所以你可以通过检查这个返回值来检查视频是否结束。</p>
<p>有时，cap可能没有初始化捕获。在这种情况下，这段代码显示了一个错误。你可以通过 **cap.isOpened() **方法来检查它是否已经初始化。如果返回值为 <code>True</code>, 那么OK。否则使用 <strong>cap.open()</strong> 打开它。</p>
<p>您还可以使用 <strong>cap.get(propId)</strong> 方法访问本视频的一些功能，propld 为0 ~ 18之间的数字。每个数字代表视频的一个属性 (如果它适用于该视频)。完整的细节可以在这里看到: <a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/d8/dfe/classcv_1_1VideoCapture.html#aa6480e6972ef4c00d74814ec841a2939">cv::VideoCapture::get()</a>。其中一些值可以使用 <strong>cap.set(propId, value)</strong> 修改。Value is the new value you want.</p>
<p>例如，我可以通过 <code>cap.get(cv.CAP_PROP_FRAME_WIDTH)</code> 和 <code>cap.get(cv.CAP_PROP_FRAME_HEIGHT)</code> 检查帧的宽度和高度。它默认是 640x480。但我想将它改为 320x240，只需使用 <code>ret = cap.set(cv.CAP_PROP_FRAME_WIDTH,320)</code> 和 <code>ret = cap.set(cv.CAP_PROP_FRAME_HEIGHT,240)</code>.</p>
<blockquote>
<p><strong>注意</strong></p>
<p>如果你的代码报错，可能是你的相机正在使用任何其他相机应用程序工作 (比如 Linux 中的 Cheese)。</p>
</blockquote>
<h5 id="从文件播放视频"><a href="#从文件播放视频" class="headerlink" title="从文件播放视频"></a>从文件播放视频</h5><p>从文件中播放视频和从相机中捕获视频是一样的，只需将相机索引更改为视频文件名。在显示框架时也是如此，为 <code>cv.waitKey()</code> 选择适当的时间。如果它太小，视频将非常快，如果它太高，视频将很慢 (嗯，这就是如何用慢动作显示视频的方法)。在正常情况下，25毫秒就可以了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"></span><br><span class="line">cap = cv.VideoCapture(<span class="string">&#x27;vtest.avi&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> cap.isOpened():</span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># if frame is read correctly ret is True</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Can&#x27;t receive frame (stream end?). Exiting ...&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    gray = cv.cvtColor(frame, cv.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line">    cv.imshow(<span class="string">&#x27;frame&#x27;</span>, gray)</span><br><span class="line">    <span class="keyword">if</span> cv.waitKey(<span class="number">1</span>) == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">cap.release()</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong></p>
<p>确保安装了正确版本的 ffmpeg 或 gstreamer。有时使用视频捕捉是一件令人头疼的事情，主要是由于错误安装 ffmpeg&#x2F;gstreamer。</p>
</blockquote>
<h5 id="保存视频"><a href="#保存视频" class="headerlink" title="保存视频"></a>保存视频</h5><p>所以我们捕捉一段视频并逐帧处理，然后我们想保存这个视频。对于图像，它非常简单：只需使用 <code>cv.imwrite()</code>。 这里，还需要再多做一点工作。</p>
<p>这次我们创建一个 <strong>VideoWriter</strong> 对象。我们应该指定输出文件名 (如:output.avi)。然后我们应该指定 <strong>FourCC</strong> 代码 (详情见下一段)。然后应该传递每秒帧数(fps)和帧大小。最后一个是 <strong>isColor</strong> 标志。 如果它的值为 <code>True</code>，编码器期望彩色帧，否则它适用于灰度帧。</p>
<p><a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/FourCC">FourCC</a> 是一个用于指定视频编解码器的 4-byte 代码。可用代码的列表可以在 <a target="_blank" rel="noopener" href="https://fourcc.org/codecs.php">fourcc.org</a> 上找到。它依赖于平台。以下编解码器对我来说很好。</p>
<ul>
<li>In Fedora: DIVX, XVID, MJPG, X264, WMV1, WMV2. (XVID is more preferable. MJPG results in high size video. X264 gives very small size video)</li>
<li>In Windows: DIVX (More to be tested and added)</li>
<li>In OSX: MJPG (.mp4), DIVX (.avi), X264 (.mkv).</li>
</ul>
<p>FourCC code is passed as ‘cv.VideoWriter_fourcc(‘M’,’J’,’P’,’G’)<code>or </code>cv.VideoWriter_fourcc(*’MJPG’)&#96; for MJPG.</p>
<p>下面的代码从摄像机捕获，在垂直方向翻转每一帧，并保存视频。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"></span><br><span class="line">cap = cv.VideoCapture(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Define the codec and create VideoWriter object</span></span><br><span class="line">fourcc = cv.VideoWriter_fourcc(*<span class="string">&#x27;XVID&#x27;</span>)</span><br><span class="line">out = cv.VideoWriter(<span class="string">&#x27;output.avi&#x27;</span>, fourcc, <span class="number">20.0</span>, (<span class="number">640</span>, <span class="number">480</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> cap.isOpened():</span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Can&#x27;t receive frame (stream end?). Exiting ...&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    frame = cv.flip(frame, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># write the flipped frame</span></span><br><span class="line">    out.write(frame)</span><br><span class="line"></span><br><span class="line">    cv.imshow(<span class="string">&#x27;frame&#x27;</span>, frame)</span><br><span class="line">    <span class="keyword">if</span> cv.waitKey(<span class="number">1</span>) == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Release everything if job is finished</span></span><br><span class="line">cap.release()</span><br><span class="line">out.release()</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h5 id="额外的资源"><a href="#额外的资源" class="headerlink" title="额外的资源"></a>额外的资源</h5><h5 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h5><p>[^注]: 本文翻译最初编辑于 2024.08.27，最终编辑于 2024.09.07</p>
<hr>
<h4 id="OpenCV中的绘图函数"><a href="#OpenCV中的绘图函数" class="headerlink" title="OpenCV中的绘图函数"></a><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/dc/da5/tutorial_py_drawing_functions.html">OpenCV中的绘图函数</a></h4><h5 id="目标-2"><a href="#目标-2" class="headerlink" title="目标"></a>目标</h5><ul>
<li>学习使用 OpenCV 绘制不同的几何形状</li>
<li>你将学习这些函数：<a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/d6/d6e/group__imgproc__draw.html#ga7078a9fae8c7e7d13d24dac2520ae4a2"><strong>cv.line()</strong></a>**, <strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/d6/d6e/group__imgproc__draw.html#gaf10604b069374903dbd0f0488cb43670"><strong>cv.circle()</strong></a></strong>, <strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/d6/d6e/group__imgproc__draw.html#ga07d2f74cadcf8e305e810ce8eed13bc9"><strong>cv.rectangle()</strong></a></strong>, <strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/d6/d6e/group__imgproc__draw.html#ga28b2267d35786f5f890ca167236cbc69"><strong>cv.ellipse()</strong></a></strong>, <strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/d6/d6e/group__imgproc__draw.html#ga5126f47f883d730f633d74f07456c576"><strong>cv.putText()</strong></a></strong> 等.</li>
</ul>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><p>在上述所有函数中，您将看到一些常见的参数，如下所示：</p>
<ul>
<li>img ： 要绘制形状的图像</li>
<li>color ：形状的颜色。对于 BGR，请将其作为元组传递，例如：(255,0,0) 表示蓝色。对于灰度而言，只需传递标量值。</li>
<li>thickness ： 线或圆等的粗细。如果为闭合图形(如圆形)传递 <strong>-1</strong>，它将填充形状。<em>默认厚度 &#x3D; 1</em></li>
<li>lineType ：线路类型，是否为 8-connected、抗锯齿线等。*默认情况下，它是 8-connected。<a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/d6/d6e/group__imgproc__draw.html#ggaf076ef45de481ac96e0ab3dc2c29a777a85fdabe5335c9e6656563dfd7c94fb4f"><strong>cv.LINE_AA</strong></a> 提供抗锯齿线，非常适合曲线。</li>
</ul>
<h5 id="绘制直线"><a href="#绘制直线" class="headerlink" title="绘制直线"></a>绘制直线</h5><p>要绘制一条线，您需要设置线的起点和终点坐标。我们将创建一个黑色图像，并在其上从左上角到右下角绘制一条蓝线。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Create a black image</span></span><br><span class="line">img = np.zeros((<span class="number">512</span>,<span class="number">512</span>,<span class="number">3</span>), np.uint8)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Draw a diagonal blue line with thickness of 5 px</span></span><br><span class="line">cv.line(img,(<span class="number">0</span>,<span class="number">0</span>),(<span class="number">511</span>,<span class="number">511</span>),(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>),<span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<h5 id="绘制矩形"><a href="#绘制矩形" class="headerlink" title="绘制矩形"></a>绘制矩形</h5><p>要绘制矩形，您需要矩形的左上角和右下角。这次我们将在图像的右上角绘制一个绿色矩形。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv.rectangle(img,(<span class="number">384</span>,<span class="number">0</span>),(<span class="number">510</span>,<span class="number">128</span>),(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<h5 id="绘制圆"><a href="#绘制圆" class="headerlink" title="绘制圆"></a>绘制圆</h5><p>要绘制圆，您需要其中心坐标和半径。我们将在上面绘制的矩形内画一个圆。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv.circle(img,(<span class="number">447</span>,<span class="number">63</span>), <span class="number">63</span>, (<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>), -<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h5 id="绘制椭圆"><a href="#绘制椭圆" class="headerlink" title="绘制椭圆"></a>绘制椭圆</h5><p>要绘制椭圆，我们需要设置多个参数。一个参数是中心位置 (x，y)。下一个参数是轴长度 (长轴长度、短轴长度)。angle 是椭圆逆时针方向的旋转角度。startAngle 和 endAngle 表示从长轴开始按顺时针方向测量的椭圆弧的起点和终点。即，给出值 0 和 360 得到完整的椭圆。有关更多详细信息，请查看 <strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/d6/d6e/group__imgproc__draw.html#ga28b2267d35786f5f890ca167236cbc69">cv.ellipse()</a></strong> 的文档。以下示例在图像中心绘制一个半椭圆。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cv.ellipse(img,(<span class="number">256</span>,<span class="number">256</span>),(<span class="number">100</span>,<span class="number">50</span>),<span class="number">0</span>,<span class="number">0</span>,<span class="number">180</span>,<span class="number">255</span>,-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h5 id="绘制多边形"><a href="#绘制多边形" class="headerlink" title="绘制多边形"></a>绘制多边形</h5><p>要绘制多边形，首先需要顶点的坐标。将这些点制作成形状为 ROWSx1x2 的数组，其中 ROWS 是顶点数，其类型应为 int32。在这里，我们绘制一个带有四个黄色顶点的小多边形。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pts = np.array([[<span class="number">10</span>,<span class="number">5</span>],[<span class="number">20</span>,<span class="number">30</span>],[<span class="number">70</span>,<span class="number">20</span>],[<span class="number">50</span>,<span class="number">10</span>]], np.int32)</span><br><span class="line">pts = pts.reshape((-<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>))</span><br><span class="line">cv.polylines(img,[pts],<span class="literal">True</span>,(<span class="number">0</span>,<span class="number">255</span>,<span class="number">255</span>))</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong></p>
<p>如果第三个参数为 False，您将获得连接所有点的多段线，而不是闭合形状。</p>
<p><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/d6/d6e/group__imgproc__draw.html#gaa3c25f9fb764b6bef791bf034f6e26f5"><strong>cv.polylines()</strong></a> 可用于绘制多条线。只需创建一个包含您要绘制的所有线条的列表，并将其传递给函数即可。所有线条都将单独绘制。与为每行调用 <a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/d6/d6e/group__imgproc__draw.html#ga7078a9fae8c7e7d13d24dac2520ae4a2"><strong>cv.line()</strong></a> 相比，绘制一组行是一种更好、更快的方法。</p>
</blockquote>
<h5 id="在图像中添加文本："><a href="#在图像中添加文本：" class="headerlink" title="在图像中添加文本："></a>在图像中添加文本：</h5><p>要将文本放入图像中，您需要指定以下内容。</p>
<ul>
<li>要写入的文本数据</li>
<li>将坐标放在你想要放置的位置（即数据开始的左下角）。</li>
<li>字体类型（查看 <strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/d6/d6e/group__imgproc__draw.html#ga5126f47f883d730f633d74f07456c576">cv.putText()</a></strong> 文档了解支持的字体）</li>
<li>字体比例 （指定字体的大小）</li>
<li>常规内容，如 color、thickness、lineType 等。为了更好地查看，建议使用 lineType &#x3D; <a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/d6/d6e/group__imgproc__draw.html#ggaf076ef45de481ac96e0ab3dc2c29a777a85fdabe5335c9e6656563dfd7c94fb4f"><strong>cv.LINE_AA</strong></a>。</li>
</ul>
<p>我们将在我们的图像上以白色书写 <strong>OpenCV</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">font = cv.FONT_HERSHEY_SIMPLEX</span><br><span class="line">cv.putText(img,<span class="string">&#x27;OpenCV&#x27;</span>,(<span class="number">10</span>,<span class="number">500</span>), font, <span class="number">4</span>,(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>),<span class="number">2</span>,cv.LINE_AA)</span><br></pre></td></tr></table></figure>

<h5 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h5><p>是时候看看我们绘图的最终结果了。正如您在前几篇文章中所学习的，请显示图像以查看它。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://raw.gitmirror.com/immortal3180/Repo/main/img/GithubPicBed/20240825-/20240907122152.png"></p>
<h5 id="其他资源"><a href="#其他资源" class="headerlink" title="其他资源"></a>其他资源</h5><ol>
<li>ellipse(椭圆) 函数中使用的角度不是我们的圆角。有关更多详细信息，请访问<a target="_blank" rel="noopener" href="http://answers.opencv.org/question/14541/angles-in-ellipse-function/">此讨论</a>。</li>
</ol>
<h5 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h5><ol>
<li>尝试使用 OpenCV 中提供的绘图功能创建 OpenCV 的徽标。</li>
</ol>
<p>[^注]: 本文翻译最初编辑于 2024.09.07</p>
<hr>
<h4 id="鼠标作为画笔"><a href="#鼠标作为画笔" class="headerlink" title="鼠标作为画笔"></a><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/db/d5b/tutorial_py_mouse_handling.html">鼠标作为画笔</a></h4><h5 id="目标-3"><a href="#目标-3" class="headerlink" title="目标"></a>目标</h5><ul>
<li>学习在 OpenCV 中处理鼠标事件</li>
<li>您将学习这些函数：<a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/d7/dfc/group__highgui.html#ga89e7806b0a616f6f1d502bd8c183ad3e"><strong>cv.setMouseCallback()</strong></a></li>
</ul>
<h5 id="简单演示"><a href="#简单演示" class="headerlink" title="简单演示"></a>简单演示</h5><p>在这里，我们创建了一个简单的应用程序，它在图像双击图像的任何位置都会画一个圆圈。</p>
<p>首先，我们创建一个鼠标回调函数，该函数在鼠标事件发生时执行。鼠标事件可以是与鼠标相关的任何内容，例如左键按下、左键向上、左键双击等。它为我们提供了每个鼠标事件的坐标 （x，y）。有了这个活动和地点，我们可以做任何我们想做的事。要列出所有可用的事件，请在 Python 终端中运行以下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line">events = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">dir</span>(cv) <span class="keyword">if</span> <span class="string">&#x27;EVENT&#x27;</span> <span class="keyword">in</span> i]</span><br><span class="line"><span class="built_in">print</span>( events )</span><br></pre></td></tr></table></figure>

<p>创建鼠标回调函数具有特定的格式，该格式在任何地方都是相同的。它仅在函数的作用上有所不同。所以我们的鼠标回调函数只做了一件事，它在我们双击的地方画了一个圆圈。所以请看下面的代码。代码从注释中不言自明：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"> </span><br><span class="line"><span class="comment"># mouse callback function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">draw_circle</span>(<span class="params">event,x,y,flags,param</span>):</span><br><span class="line">    <span class="keyword">if</span> event == cv.EVENT_LBUTTONDBLCLK:</span><br><span class="line">        cv.circle(img,(x,y),<span class="number">100</span>,(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>),-<span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Create a black image, a window and bind the function to window</span></span><br><span class="line">img = np.zeros((<span class="number">512</span>,<span class="number">512</span>,<span class="number">3</span>), np.uint8)</span><br><span class="line">cv.namedWindow(<span class="string">&#x27;image&#x27;</span>)</span><br><span class="line">cv.setMouseCallback(<span class="string">&#x27;image&#x27;</span>,draw_circle)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    cv.imshow(<span class="string">&#x27;image&#x27;</span>,img)</span><br><span class="line">    <span class="keyword">if</span> cv.waitKey(<span class="number">20</span>) &amp; <span class="number">0xFF</span> == <span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h5 id="更高级的演示"><a href="#更高级的演示" class="headerlink" title="更高级的演示"></a>更高级的演示</h5><p>现在我们寻求更好的应用程序。在这种情况下，我们像在 Paint 应用程序中一样通过拖动鼠标来绘制矩形或圆形（取决于我们选择的模式）。所以我们的鼠标回调函数有两部分，一部分是画矩形，一部分是画圆。这个具体示例对于创建和理解一些交互式应用程序（如对象跟踪、图像分割等）非常有帮助。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"> </span><br><span class="line">drawing = <span class="literal">False</span> <span class="comment"># true if mouse is pressed</span></span><br><span class="line">mode = <span class="literal">True</span> <span class="comment"># if True, draw rectangle. Press &#x27;m&#x27; to toggle to curve</span></span><br><span class="line">ix,iy = -<span class="number">1</span>,-<span class="number">1</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># mouse callback function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">draw_circle</span>(<span class="params">event,x,y,flags,param</span>):</span><br><span class="line">    <span class="keyword">global</span> ix,iy,drawing,mode</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> event == cv.EVENT_LBUTTONDOWN:</span><br><span class="line">        drawing = <span class="literal">True</span></span><br><span class="line">        ix,iy = x,y</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">elif</span> event == cv.EVENT_MOUSEMOVE:</span><br><span class="line">        <span class="keyword">if</span> drawing == <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> mode == <span class="literal">True</span>:</span><br><span class="line">                cv.rectangle(img,(ix,iy),(x,y),(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cv.circle(img,(x,y),<span class="number">5</span>,(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),-<span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">elif</span> event == cv.EVENT_LBUTTONUP:</span><br><span class="line">        drawing = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> mode == <span class="literal">True</span>:</span><br><span class="line">            cv.rectangle(img,(ix,iy),(x,y),(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cv.circle(img,(x,y),<span class="number">5</span>,(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>接下来，我们必须将这个鼠标回调函数绑定到 OpenCV 窗口。在主循环中，我们应该为键 ‘m’ 设置一个键盘绑定，以便在矩形和圆形之间切换。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">img = np.zeros((<span class="number">512</span>,<span class="number">512</span>,<span class="number">3</span>), np.uint8)</span><br><span class="line">cv.namedWindow(<span class="string">&#x27;image&#x27;</span>)</span><br><span class="line">cv.setMouseCallback(<span class="string">&#x27;image&#x27;</span>,draw_circle)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    cv.imshow(<span class="string">&#x27;image&#x27;</span>,img)</span><br><span class="line">    k = cv.waitKey(<span class="number">1</span>) &amp; <span class="number">0xFF</span></span><br><span class="line">    <span class="keyword">if</span> k == <span class="built_in">ord</span>(<span class="string">&#x27;m&#x27;</span>):</span><br><span class="line">        mode = <span class="keyword">not</span> mode</span><br><span class="line">    <span class="keyword">elif</span> k == <span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"> </span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<h4 id="其他资源-1"><a href="#其他资源-1" class="headerlink" title="其他资源"></a>其他资源</h4><h5 id="习题-1"><a href="#习题-1" class="headerlink" title="习题"></a>习题</h5><ol>
<li>在上一个例子中，我们绘制了填充矩形。修改代码以绘制未填充的矩形。</li>
</ol>
<p>[^注]: 本文翻译最初编辑于 2024.09.07</p>
<hr>
<h4 id="Trackbar-作为调色板"><a href="#Trackbar-作为调色板" class="headerlink" title="Trackbar 作为调色板"></a><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/d9/dc8/tutorial_py_trackbar.html">Trackbar 作为调色板</a></h4><h5 id="目标-4"><a href="#目标-4" class="headerlink" title="目标"></a>目标</h5><ul>
<li>了解如何将跟踪条绑定到 OpenCV 窗口</li>
<li>您将学习这些函数：**<a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/d7/dfc/group__highgui.html#ga122632e9e91b9ec06943472c55d9cda8">cv.getTrackbarPos()</a>**, <strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/d7/dfc/group__highgui.html#gaf78d2155d30b728fc413803745b67a9b">cv.createTrackbar()</a></strong> 等。</li>
</ul>
<h5 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h5><p>在这里，我们将创建一个简单的应用程序，显示您指定的颜色。您有一个显示颜色的窗口和三个跟踪条来指定 B、G、R 颜色中的每一种。滑动跟踪条并相应地更改窗口颜色。默认情况下，初始颜色将设置为 Black。</p>
<p>对于 <a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/d7/dfc/group__highgui.html#gaf78d2155d30b728fc413803745b67a9b"><strong>cv.createTrackbar()</strong></a> 函数，第一个参数是跟踪栏名称，第二个参数是它所附加的窗口名称，第三个参数是默认值，第四个参数是最大值，第五个参数是每次跟踪栏值更改时执行的回调函数。回调函数始终具有一个默认参数，即跟踪栏位置。在我们的例子中，function 什么都不做，所以我们简单地传递。</p>
<p>跟踪栏的另一个重要应用是将其用作按钮或开关。默认情况下，OpenCV 没有按钮功能。因此，您可以使用 trackbar 来获得此类功能。在我们的应用程序中，我们创建了一个开关，该应用程序仅在开关打开时工作，否则屏幕始终为黑色。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"> </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">nothing</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># Create a black image, a window</span></span><br><span class="line">img = np.zeros((<span class="number">300</span>,<span class="number">512</span>,<span class="number">3</span>), np.uint8)</span><br><span class="line">cv.namedWindow(<span class="string">&#x27;image&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># create trackbars for color change</span></span><br><span class="line">cv.createTrackbar(<span class="string">&#x27;R&#x27;</span>,<span class="string">&#x27;image&#x27;</span>,<span class="number">0</span>,<span class="number">255</span>,nothing)</span><br><span class="line"> </span><br><span class="line">cv.createTrackbar(<span class="string">&#x27;G&#x27;</span>,<span class="string">&#x27;image&#x27;</span>,<span class="number">0</span>,<span class="number">255</span>,nothing)</span><br><span class="line">cv.createTrackbar(<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;image&#x27;</span>,<span class="number">0</span>,<span class="number">255</span>,nothing)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># create switch for ON/OFF functionality</span></span><br><span class="line">switch = <span class="string">&#x27;0 : OFF \n1 : ON&#x27;</span></span><br><span class="line">cv.createTrackbar(switch, <span class="string">&#x27;image&#x27;</span>,<span class="number">0</span>,<span class="number">1</span>,nothing)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    cv.imshow(<span class="string">&#x27;image&#x27;</span>,img)</span><br><span class="line">    k = cv.waitKey(<span class="number">1</span>) &amp; <span class="number">0xFF</span></span><br><span class="line">    <span class="keyword">if</span> k == <span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment"># get current positions of four trackbars</span></span><br><span class="line">    r = cv.getTrackbarPos(<span class="string">&#x27;R&#x27;</span>,<span class="string">&#x27;image&#x27;</span>)</span><br><span class="line">    g = cv.getTrackbarPos(<span class="string">&#x27;G&#x27;</span>,<span class="string">&#x27;image&#x27;</span>)</span><br><span class="line">    b = cv.getTrackbarPos(<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;image&#x27;</span>)</span><br><span class="line">    s = cv.getTrackbarPos(switch,<span class="string">&#x27;image&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> s == <span class="number">0</span>:</span><br><span class="line">        img[:] = <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        img[:] = [b,g,r]</span><br><span class="line"> </span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<p>应用程序的屏幕截图如下所示：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://raw.gitmirror.com/immortal3180/Repo/main/img/GithubPicBed/20240825-/20240907133722.png" alt="image"></p>
<h5 id="习题-2"><a href="#习题-2" class="headerlink" title="习题"></a>习题</h5><ol>
<li>使用跟踪条创建具有可调整颜色和画笔半径的 Paint 应用程序。有关绘图，请参阅前面的鼠标操作教程。</li>
</ol>
<p>[^注]: 本文翻译最初编辑于 2024.09.07</p>
<hr>
<h3 id="Core-Operations-核心业务"><a href="#Core-Operations-核心业务" class="headerlink" title="Core Operations - 核心业务"></a><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/d7/d16/tutorial_py_table_of_contents_core.html"><strong>Core Operations</strong></a> - 核心业务</h3><p>(在本节中，您将学习图像的基本操作，如像素编辑，几何变换，代码优化，一些数学工具等)</p>
<h4 id="对图像的基本操作"><a href="#对图像的基本操作" class="headerlink" title="对图像的基本操作"></a><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/d3/df2/tutorial_py_basic_ops.html">对图像的基本操作</a></h4><p>(学习读取和编辑像素值，处理图像ROl等基本操作)</p>
<h5 id="目标-5"><a href="#目标-5" class="headerlink" title="目标"></a>目标</h5><p>学习：</p>
<ul>
<li>访问像素值并对其进行修改</li>
<li>访问图像属性</li>
<li>设置感兴趣区域 （ROI）</li>
<li>拆分和合并图像</li>
</ul>
<p>本节中几乎所有的操作都主要与 Numpy 有关，而不是 OpenCV。要使用 OpenCV 编写更好的优化代码，需要对 Numpy 有很好的了解。</p>
<p><em>（ 示例将显示在 Python 终端中，因为它们中的大多数只是单行代码 ）</em></p>
<h5 id="访问和修改像素值"><a href="#访问和修改像素值" class="headerlink" title="访问和修改像素值"></a>访问和修改像素值</h5><p>让我们先加载一张彩色图片：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>img = cv.imread(<span class="string">&#x27;messi5.jpg&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">assert</span> img <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>, <span class="string">&quot;file could not be read, check with os.path.exists()&quot;</span></span><br></pre></td></tr></table></figure>

<p>您可以通过像素值的行和列坐标来访问像素值。对于 BGR 图像，它返回 Blue、Green、Red 值的数组。对于灰度图像，仅返回相应的强度。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>px = img[<span class="number">100</span>,<span class="number">100</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>( px )</span><br><span class="line">[<span class="number">157</span> <span class="number">166</span> <span class="number">200</span>]</span><br><span class="line"> </span><br><span class="line"><span class="comment"># accessing only blue pixel</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>blue = img[<span class="number">100</span>,<span class="number">100</span>,<span class="number">0</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>( blue )</span><br><span class="line"><span class="number">157</span></span><br></pre></td></tr></table></figure>

<p>您可以用相同的方式修改像素值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>img[<span class="number">100</span>,<span class="number">100</span>] = [<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>( img[<span class="number">100</span>,<span class="number">100</span>] )</span><br><span class="line">[<span class="number">255</span> <span class="number">255</span> <span class="number">255</span>]</span><br></pre></td></tr></table></figure>

<p><strong>警告</strong></p>
<p>Numpy 是一个用于快速数组计算的优化库。因此，简单地访问每个像素值并对其进行修改将非常缓慢，并且不建议这样做。</p>
<blockquote>
<p><strong>注意</strong></p>
<p>上述方法通常用于选择数组的区域，例如前 5 行和后 3 列。对于单个像素访问，Numpy 数组方法 array.item（） 和 array.itemset（） 被认为更好。但是，它们总是返回一个标量，因此如果您想访问所有 B，G，R 值，则需要为每个值单独调用 array.item（）。</p>
</blockquote>
<p>更好的像素访问和编辑方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># accessing RED value</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>img.item(<span class="number">10</span>,<span class="number">10</span>,<span class="number">2</span>)</span><br><span class="line"><span class="number">59</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># modifying RED value</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>img.itemset((<span class="number">10</span>,<span class="number">10</span>,<span class="number">2</span>),<span class="number">100</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>img.item(<span class="number">10</span>,<span class="number">10</span>,<span class="number">2</span>)</span><br><span class="line"><span class="number">100</span></span><br></pre></td></tr></table></figure>

<h5 id="访问图像属性"><a href="#访问图像属性" class="headerlink" title="访问图像属性"></a>访问图像属性</h5><p>图像属性包括行数、列数和通道数;图像数据类型;像素数;等。</p>
<p>图像的形状由 img.shape 访问。它返回行数、列数和通道数的 Tuples（如果图像是彩色的）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>( img.shape )</span><br><span class="line">(<span class="number">342</span>, <span class="number">548</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong></p>
<p>如果图像是灰度图像，则返回的元组仅包含行数和列数，因此检查加载的图像是灰度还是彩色的好方法。</p>
</blockquote>
<p>像素总数的访问方式为 ：<code>img.size</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>( img.size )</span><br><span class="line"><span class="number">562248</span></span><br></pre></td></tr></table></figure>

<p>Image 数据类型由 ‘img.dtype’ 获取：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>( img.dtype )</span><br><span class="line">uint8</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong></p>
<p>img.dtype 在调试时非常重要，因为 OpenCV-Python 代码中的大量错误都是由无效的数据类型引起的。</p>
</blockquote>
<h5 id="图像-ROI"><a href="#图像-ROI" class="headerlink" title="图像 ROI"></a>图像 ROI</h5><p>有时，您将不得不处理图像的某些区域。对于图像中的眼睛检测，首先对整个图像进行人脸检测。获得人脸后，我们单独选择人脸区域并搜索其中的眼睛，而不是搜索整个图像。它提高了准确性（因为眼睛总是:D人脸上）和性能（因为我们在小区域内搜索）。</p>
<p>ROI 再次使用 Numpy 索引获得。在这里，我选择球并将其复制到图像中的另一个区域：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ball = img[<span class="number">280</span>:<span class="number">340</span>, <span class="number">330</span>:<span class="number">390</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>img[<span class="number">273</span>:<span class="number">333</span>, <span class="number">100</span>:<span class="number">160</span>] = ball</span><br></pre></td></tr></table></figure>

<p>检查下面的结果：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://raw.gitmirror.com/immortal3180/Repo/main/img/GithubPicBed/20240825-/20240907201012.png" alt="image"></p>
<h5 id="拆分和合并图像通道"><a href="#拆分和合并图像通道" class="headerlink" title="拆分和合并图像通道"></a>拆分和合并图像通道</h5><p>有时，您需要单独处理图像的 B、G、R 通道。在这种情况下，您需要将 BGR 图像拆分为单个通道。在其他情况下，您可能需要加入这些单独的通道以创建 BGR 图像。您可以简单地通过以下方式执行此操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b,g,r = cv.split(img)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>img = cv.merge((b,g,r))</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = img[:,:,<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<p>假设您要将所有红色像素设置为零 - 您无需先拆分通道。Numpy 索引更快：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>img[:,:,<span class="number">2</span>] = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><strong>警告</strong></p>
<p><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/d2/de8/group__core__array.html#ga0547c7fed86152d7e9d0096029c8518a">cv.split()</a> 是一个昂贵的操作（就时间而言）。因此，请仅在必要时使用它。否则选择 Numpy 索引。</p>
<h5 id="为图像创建边框（填充）"><a href="#为图像创建边框（填充）" class="headerlink" title="为图像创建边框（填充）"></a>为图像创建边框（填充）</h5><p>如果你想在图像周围创建一个边框，比如相框，你可以使用 <a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/d2/de8/group__core__array.html#ga2ac1049c2c3dd25c2b41bffe17658a36"><strong>cv.copyMakeBorder()</strong></a>但它有更多的应用，用于卷积运算、零填充等。此函数采用以下参数：</p>
<ul>
<li><strong>src</strong> - 输入图像</li>
<li><strong>top</strong>， <strong>bottom</strong>， <strong>left</strong>， <strong>right</strong> - 相应方向的边框宽度（以像素数为单位）</li>
<li><strong>borderType</strong> - 定义要添加的边框类型的标志。它可以是以下类型：<ul>
<li><strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/d2/de8/group__core__array.html#gga209f2f4869e304c82d07739337eae7c5aed2e4346047e265c8c5a6d0276dcd838">cv.BORDER_CONSTANT</a></strong> - 添加恒定的彩色边框。该值应作为 next 参数给出。</li>
<li><strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/d2/de8/group__core__array.html#gga209f2f4869e304c82d07739337eae7c5a815c8a89b7cb206dcba14d11b7560f4b">cv.BORDER_REFLECT</a></strong> - 边界将是边界元素的镜像反射，如下所示 ： <em>fedcba|abcdefgh|hgfedcb</em></li>
<li><strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/d2/de8/group__core__array.html#gga209f2f4869e304c82d07739337eae7c5ab3c5a6143d8120b95005fa7105a10bb4">cv.BORDER_REFLECT_101</a></strong> 或 <strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/d2/de8/group__core__array.html#gga209f2f4869e304c82d07739337eae7c5afe14c13a4ea8b8e3b3ef399013dbae01">cv.BORDER_DEFAULT</a></strong> - 同上，但略有变化，如下所示 ： <em>gfedcb|abcdefgh|gfedcba</em></li>
<li><strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/d2/de8/group__core__array.html#gga209f2f4869e304c82d07739337eae7c5aa1de4cff95e3377d6d0cbe7569bd4e9f">cv.BORDER_REPLICATE</a></strong> - 最后一个元素在整个过程中被复制，如下所示：<em>aaaaaa|abcdefgh|hhhhhh</em></li>
<li><strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/d2/de8/group__core__array.html#gga209f2f4869e304c82d07739337eae7c5a697c1b011884a7c2bdc0e5caf7955661">cv.BORDER_WRAP</a></strong> - 无法解释，它看起来像这样 ： <em>cdefgh|abcdefgh|abcdefg</em></li>
</ul>
</li>
<li><strong>value</strong> - 如果 border type 为 <a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/d2/de8/group__core__array.html#gga209f2f4869e304c82d07739337eae7c5aed2e4346047e265c8c5a6d0276dcd838">cv.BORDER_CONSTANT</a>，则边框的颜色</li>
</ul>
<p>下面是一个示例代码，演示了所有这些边框类型，以便更好地理解：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"> </span><br><span class="line">BLUE = [<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line"> </span><br><span class="line">img1 = cv.imread(<span class="string">&#x27;opencv-logo.png&#x27;</span>)</span><br><span class="line"><span class="keyword">assert</span> img1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>, <span class="string">&quot;file could not be read, check with os.path.exists()&quot;</span></span><br><span class="line"> </span><br><span class="line">replicate = cv.copyMakeBorder(img1,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,cv.BORDER_REPLICATE)</span><br><span class="line">reflect = cv.copyMakeBorder(img1,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,cv.BORDER_REFLECT)</span><br><span class="line">reflect101 = cv.copyMakeBorder(img1,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,cv.BORDER_REFLECT_101)</span><br><span class="line">wrap = cv.copyMakeBorder(img1,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,cv.BORDER_WRAP)</span><br><span class="line">constant= cv.copyMakeBorder(img1,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,cv.BORDER_CONSTANT,value=BLUE)</span><br><span class="line"> </span><br><span class="line">plt.subplot(<span class="number">231</span>),plt.imshow(img1,<span class="string">&#x27;gray&#x27;</span>),plt.title(<span class="string">&#x27;ORIGINAL&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">232</span>),plt.imshow(replicate,<span class="string">&#x27;gray&#x27;</span>),plt.title(<span class="string">&#x27;REPLICATE&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">233</span>),plt.imshow(reflect,<span class="string">&#x27;gray&#x27;</span>),plt.title(<span class="string">&#x27;REFLECT&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">234</span>),plt.imshow(reflect101,<span class="string">&#x27;gray&#x27;</span>),plt.title(<span class="string">&#x27;REFLECT_101&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">235</span>),plt.imshow(wrap,<span class="string">&#x27;gray&#x27;</span>),plt.title(<span class="string">&#x27;WRAP&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">236</span>),plt.imshow(constant,<span class="string">&#x27;gray&#x27;</span>),plt.title(<span class="string">&#x27;CONSTANT&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>请参阅下面的结果。（图像使用 matplotlib 显示。所以 RED 和 BLUE 通道将互换）：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://raw.gitmirror.com/immortal3180/Repo/main/img/GithubPicBed/20240825-/20240907201332.png" alt="image"></p>
<h5 id="其他资源-2"><a href="#其他资源-2" class="headerlink" title="其他资源"></a>其他资源</h5><h5 id="习题-3"><a href="#习题-3" class="headerlink" title="习题"></a>习题</h5><hr>
<h4 id="图像的算术运算"><a href="#图像的算术运算" class="headerlink" title="图像的算术运算"></a><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/d0/d86/tutorial_py_image_arithmetics.html">图像的算术运算</a></h4><p>(对图像执行算术运算)</p>
<h5 id="目标-6"><a href="#目标-6" class="headerlink" title="目标"></a>目标</h5><ul>
<li>学习图像上的几种算术运算，如加法、减法、按位运算等。</li>
<li>了解这些函数：<a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/d2/de8/group__core__array.html#ga10ac1bfb180e2cfda1701d06c24fdbd6"><strong>cv.add()</strong></a>**, **<a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/d2/de8/group__core__array.html#gafafb2513349db3bcff51f54ee5592a19"><strong>cv.addWeighted()</strong></a>, 等。</li>
</ul>
<h5 id="图像添加"><a href="#图像添加" class="headerlink" title="图像添加"></a>图像添加</h5><p>您可以使用 OpenCV 函数 <a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/d2/de8/group__core__array.html#ga10ac1bfb180e2cfda1701d06c24fdbd6">cv.add()</a> 添加两张图像，或者简单地通过 numpy 操作 res &#x3D; img1 + img2。两个图像应具有相同的深度和类型，或者第二个图像只能是标量值。</p>
<blockquote>
<p><strong>注意</strong></p>
<p>OpenCV 加法和 Numpy 加法是有区别的。OpenCV 加法是饱和运算，而 Numpy 加法是模运算。</p>
</blockquote>
<p>例如，请考虑以下示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = np.uint8([<span class="number">250</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = np.uint8([<span class="number">10</span>])</span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>( cv.add(x,y) ) <span class="comment"># 250+10 = 260 =&gt; 255</span></span><br><span class="line">[[<span class="number">255</span>]]</span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>( x+y )          <span class="comment"># 250+10 = 260 % 256 = 4</span></span><br><span class="line">[<span class="number">4</span>]</span><br></pre></td></tr></table></figure>

<p>当您添加两张图片时，这将更加明显。坚持使用 OpenCV 函数，因为它们会提供更好的结果。</p>
<h5 id="图像混合"><a href="#图像混合" class="headerlink" title="图像混合"></a>图像混合</h5><p>这也是图像添加，但为了给人一种混合或透明的感觉，对图像赋予了不同的权重。根据以下公式添加图像：<br>$$<br>g(x)&#x3D;(1-\alpha)f_0(x)+\alpha f_1(x)<br>$$<br>通过变化α从0→1中，您可以在一个图像到另一个图像之间执行很酷的过渡。</p>
<p>在这里，我拍了两张图片混合在一起。第一个图像的权重为 0.7，第二个图像的权重为 0.3。<a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/d2/de8/group__core__array.html#gafafb2513349db3bcff51f54ee5592a19">cv.addWeighted()</a> 将以下公式应用于图像：<br>$$<br>dst&#x3D;\alpha\cdot img1+\beta\cdot img2+\gamma<br>$$<br>这里γ视为零。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">img1 = cv.imread(<span class="string">&#x27;ml.png&#x27;</span>)</span><br><span class="line">img2 = cv.imread(<span class="string">&#x27;opencv-logo.png&#x27;</span>)</span><br><span class="line"><span class="keyword">assert</span> img1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>, <span class="string">&quot;file could not be read, check with os.path.exists()&quot;</span></span><br><span class="line"><span class="keyword">assert</span> img2 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>, <span class="string">&quot;file could not be read, check with os.path.exists()&quot;</span></span><br><span class="line"> </span><br><span class="line">dst = cv.addWeighted(img1,<span class="number">0.7</span>,img2,<span class="number">0.3</span>,<span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line">cv.imshow(<span class="string">&#x27;dst&#x27;</span>,dst)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<p>检查下面的结果：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://raw.gitmirror.com/immortal3180/Repo/main/img/GithubPicBed/20240825-/20240907202844.png" alt="image"></p>
<h5 id="按位运算"><a href="#按位运算" class="headerlink" title="按位运算"></a>按位运算</h5><p>这包括按位 AND、OR、NOT 和 XOR 运算。它们在提取图像的任何部分（我们将在后面的章节中看到）、定义和使用非矩形 ROI 等时非常有用。下面我们将看到如何更改图像特定区域的示例。</p>
<p>我想将 OpenCV 徽标放在图像上方。如果我添加两张图片，它会改变颜色。如果我混合它们，我会得到一个透明的效果。但我希望它是不透明的。如果它是一个矩形区域，我可以像上一章中那样使用 ROI。但 OpenCV 标志不是矩形。所以你可以用按位运算来实现，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Load two images</span></span><br><span class="line">img1 = cv.imread(<span class="string">&#x27;messi5.jpg&#x27;</span>)</span><br><span class="line">img2 = cv.imread(<span class="string">&#x27;opencv-logo-white.png&#x27;</span>)</span><br><span class="line"><span class="keyword">assert</span> img1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>, <span class="string">&quot;file could not be read, check with os.path.exists()&quot;</span></span><br><span class="line"><span class="keyword">assert</span> img2 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>, <span class="string">&quot;file could not be read, check with os.path.exists()&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># I want to put logo on top-left corner, So I create a ROI</span></span><br><span class="line">rows,cols,channels = img2.shape</span><br><span class="line">roi = img1[<span class="number">0</span>:rows, <span class="number">0</span>:cols]</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Now create a mask of logo and create its inverse mask also</span></span><br><span class="line">img2gray = cv.cvtColor(img2,cv.COLOR_BGR2GRAY)</span><br><span class="line">ret, mask = cv.threshold(img2gray, <span class="number">10</span>, <span class="number">255</span>, cv.THRESH_BINARY)</span><br><span class="line">mask_inv = cv.bitwise_not(mask)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Now black-out the area of logo in ROI</span></span><br><span class="line">img1_bg = cv.bitwise_and(roi,roi,mask = mask_inv)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Take only region of logo from logo image.</span></span><br><span class="line">img2_fg = cv.bitwise_and(img2,img2,mask = mask)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Put logo in ROI and modify the main image</span></span><br><span class="line">dst = cv.add(img1_bg,img2_fg)</span><br><span class="line">img1[<span class="number">0</span>:rows, <span class="number">0</span>:cols ] = dst</span><br><span class="line"> </span><br><span class="line">cv.imshow(<span class="string">&#x27;res&#x27;</span>,img1)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<p>请参阅下面的结果。左图显示了我们创建的蒙版。右图显示最终结果。为了更好地理解，请显示上述代码中的所有中间图像，尤其是 img1_bg 和 img2_fg。</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://raw.gitmirror.com/immortal3180/Repo/main/img/GithubPicBed/20240825-/20240907203111.png" alt="image"></p>
<h5 id="其他资源-3"><a href="#其他资源-3" class="headerlink" title="其他资源"></a>其他资源</h5><h5 id="习题-4"><a href="#习题-4" class="headerlink" title="习题"></a>习题</h5><ol>
<li>使用 <a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/d2/de8/group__core__array.html#gafafb2513349db3bcff51f54ee5592a19">cv.addWeighted</a> 函数在文件夹中创建图像的幻灯片，并在图像之间平滑过渡</li>
</ol>
<hr>
<h4 id="性能测量和改进技术"><a href="#性能测量和改进技术" class="headerlink" title="性能测量和改进技术"></a><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/dc/d71/tutorial_py_optimization.html">性能测量和改进技术</a></h4><p>(找到解决方案很重要。但以最快的方式获得解决方案更为重要。学会检查代码的运行速度，优化代码等等。)</p>
<h5 id="目标-7"><a href="#目标-7" class="headerlink" title="目标"></a>目标</h5><p>在图像处理中，由于您每秒要处理大量操作，因此您的代码不仅必须提供正确的解决方案，而且还必须以最快的方式提供解决方案。因此，在本章中，您将学习：</p>
<ul>
<li>测量代码的性能。</li>
<li>提高代码性能的一些技巧。</li>
<li>您将看到以下函数：**<a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/db/de0/group__core__utils.html#gae73f58000611a1af25dd36d496bf4487">cv.getTickCount</a><strong>、</strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/db/de0/group__core__utils.html#ga705441a9ef01f47acdc55d87fbe5090c">cv.getTickFrequency</a>** 等。</li>
</ul>
<p>除了 OpenCV，Python 还提供了一个模块 <strong>time</strong>，有助于测量执行时间。另一个模块<strong>配置文件</strong>有助于获取有关代码的详细报告，例如代码中每个函数花费的时间、函数被调用的次数等。但是，如果您使用的是 IPython，所有这些功能都以用户友好的方式集成。我们将看到一些重要的 VPN，有关更多详细信息，请查看 <strong>Additional Resources</strong> 部分中的链接。</p>
<h5 id="使用-OpenCV-测量性能"><a href="#使用-OpenCV-测量性能" class="headerlink" title="使用 OpenCV 测量性能"></a>使用 OpenCV 测量性能</h5><p><strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/db/de0/group__core__utils.html#gae73f58000611a1af25dd36d496bf4487">cv.getTickCount</a></strong> 函数返回引用事件（如机器打开的那一刻）到调用此函数的时钟周期数。因此，如果您在函数执行之前和之后调用它，您将获得用于执行函数的 clock-cycles 数。</p>
<p><strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/db/de0/group__core__utils.html#ga705441a9ef01f47acdc55d87fbe5090c">cv.getTickFrequency</a></strong> 函数返回 clock-cycles 的频率，或每秒的 clock-cycles 数。因此，要查找以秒为单位的执行时间，您可以执行以下操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">e1 = cv.getTickCount()</span><br><span class="line"><span class="comment"># your code execution</span></span><br><span class="line">e2 = cv.getTickCount()</span><br><span class="line">time = (e2 - e1)/ cv.getTickFrequency()</span><br></pre></td></tr></table></figure>

<p>我们将通过以下示例进行演示。以下示例对奇数大小（从 5 到 49）的内核应用中位数筛选。（不要担心结果会是什么样子 - 这不是我们的目标）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">img1 = cv.imread(<span class="string">&#x27;messi5.jpg&#x27;</span>)</span><br><span class="line"><span class="keyword">assert</span> img1 <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>, <span class="string">&quot;file could not be read, check with os.path.exists()&quot;</span></span><br><span class="line"> </span><br><span class="line">e1 = cv.getTickCount()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>,<span class="number">49</span>,<span class="number">2</span>):</span><br><span class="line">    img1 = cv.medianBlur(img1,i)</span><br><span class="line">e2 = cv.getTickCount()</span><br><span class="line">t = (e2 - e1)/cv.getTickFrequency()</span><br><span class="line"><span class="built_in">print</span>( t )</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Result I got is 0.521107655 seconds</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong></p>
<p>你可以对 time 模块做同样的事情。使用 time.time() 函数，而不是 <a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/db/de0/group__core__utils.html#gae73f58000611a1af25dd36d496bf4487">cv.getTickCount</a>。然后取两次的差值。</p>
</blockquote>
<h5 id="OpenCV-中的默认优化"><a href="#OpenCV-中的默认优化" class="headerlink" title="OpenCV 中的默认优化"></a>OpenCV 中的默认优化</h5><p>许多 OpenCV 函数都使用 SSE2、AVX 等进行了优化。它还包含未优化的代码。因此，如果我们的系统支持这些功能，我们应该利用它们（几乎所有现代处理器都支持它们）。默认情况下，它在编译时处于启用状态。因此，如果启用，OpenCV 将运行优化的代码，否则它将运行未优化的代码。您可以使用 <a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/db/de0/group__core__utils.html#gafa6d5d04eff341825573ec6c0aa6519f"><strong>cv.useOptimized()</strong></a> 来检查它是否被启用&#x2F;禁用，并使用 <a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/db/de0/group__core__utils.html#ga3c8487ea4449e550bc39575ede094c7a"><strong>cv.setUseOptimized()</strong></a> 来启用&#x2F;禁用它。让我们看一个简单的例子。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># check if optimization is enabled</span></span><br><span class="line">In [<span class="number">5</span>]: cv.useOptimized()</span><br><span class="line">Out[<span class="number">5</span>]: <span class="literal">True</span></span><br><span class="line"> </span><br><span class="line">In [<span class="number">6</span>]: %timeit res = cv.medianBlur(img,<span class="number">49</span>)</span><br><span class="line"><span class="number">10</span> loops, best of <span class="number">3</span>: <span class="number">34.9</span> ms per loop</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Disable it</span></span><br><span class="line">In [<span class="number">7</span>]: cv.setUseOptimized(<span class="literal">False</span>)</span><br><span class="line"> </span><br><span class="line">In [<span class="number">8</span>]: cv.useOptimized()</span><br><span class="line">Out[<span class="number">8</span>]: <span class="literal">False</span></span><br><span class="line"> </span><br><span class="line">In [<span class="number">9</span>]: %timeit res = cv.medianBlur(img,<span class="number">49</span>)</span><br><span class="line"><span class="number">10</span> loops, best of <span class="number">3</span>: <span class="number">64.1</span> ms per loop</span><br></pre></td></tr></table></figure>

<p>如您所见，优化的中值滤波比未优化的版本快 2 倍。如果检查其来源，您可以看到中值滤波是 SIMD 优化的。因此，您可以使用它来在代码顶部启用优化（请记住，默认情况下它是启用的）。</p>
<h5 id="在-IPython-中测量性能"><a href="#在-IPython-中测量性能" class="headerlink" title="在 IPython 中测量性能"></a>在 IPython 中测量性能</h5><p>有时，您可能需要比较两个类似操作的性能。IPython 为您提供了一个神奇的命令 timeit 来执行此操作。它会多次运行代码以获得更准确的结果。同样，它适用于测量单行代码。</p>
<p>例如，您知道以下哪个加法运算更好吗，<code>x = 5；y = x**2， x = 5；y = x*x， x = np.uint8([5])；y = x*x，还是 y = np.square(x)</code>？我们将在 IPython shell 中使用 timeit 来找出答案。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">10</span>]: x = <span class="number">5</span></span><br><span class="line"> </span><br><span class="line">In [<span class="number">11</span>]: %timeit y=x**<span class="number">2</span></span><br><span class="line"><span class="number">10000000</span> loops, best of <span class="number">3</span>: <span class="number">73</span> ns per loop</span><br><span class="line"> </span><br><span class="line">In [<span class="number">12</span>]: %timeit y=x*x</span><br><span class="line"><span class="number">10000000</span> loops, best of <span class="number">3</span>: <span class="number">58.3</span> ns per loop</span><br><span class="line"> </span><br><span class="line">In [<span class="number">15</span>]: z = np.uint8([<span class="number">5</span>])</span><br><span class="line"> </span><br><span class="line">In [<span class="number">17</span>]: %timeit y=z*z</span><br><span class="line"><span class="number">1000000</span> loops, best of <span class="number">3</span>: <span class="number">1.25</span> us per loop</span><br><span class="line"> </span><br><span class="line">In [<span class="number">19</span>]: %timeit y=np.square(z)</span><br><span class="line"><span class="number">1000000</span> loops, best of <span class="number">3</span>: <span class="number">1.16</span> us per loop</span><br></pre></td></tr></table></figure>

<p>你可以看到， <code>x = 5 ;y = x*x</code> 是最快的，与 Numpy 相比，它快了大约 20 倍。如果您还考虑数组创建，它可能会快 100 倍。很酷，对吧？<em>（Numpy 开发人员正在努力解决这个问题）</em></p>
<blockquote>
<p><strong>注意</strong></p>
<p>Python 标量运算比 Numpy 标量运算更快。因此，对于包含一个或两个元素的操作，Python 标量优于 Numpy 数组。当数组的大小稍大时，Numpy 具有优势。</p>
</blockquote>
<p>我们将再尝试一个例子。这一次，我们将比较 <strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/d2/de8/group__core__array.html#gaa4b89393263bb4d604e0fe5986723914">cv.countNonZero()</a></strong> 和 <strong>np.count_nonzero()</strong> 对同一图像的性能。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">35</span>]: %timeit z = cv.countNonZero(img)</span><br><span class="line"><span class="number">100000</span> loops, best of <span class="number">3</span>: <span class="number">15.8</span> us per loop</span><br><span class="line"> </span><br><span class="line">In [<span class="number">36</span>]: %timeit z = np.count_nonzero(img)</span><br><span class="line"><span class="number">1000</span> loops, best of <span class="number">3</span>: <span class="number">370</span> us per loop</span><br></pre></td></tr></table></figure>

<p>你看，OpenCV 函数比 Numpy 函数快近 25 倍。</p>
<blockquote>
<p><strong>注意</strong></p>
<p>通常，OpenCV 函数比 Numpy 函数更快。所以对于相同的操作，OpenCV 函数是首选。但是，可能会有例外，尤其是当 Numpy 使用视图而不是副本时。</p>
</blockquote>
<h5 id="更多-IPython-魔术命令"><a href="#更多-IPython-魔术命令" class="headerlink" title="更多 IPython 魔术命令"></a>更多 IPython 魔术命令</h5><p>还有其他几个魔术命令来测量性能、分析、行分析、内存测量等。他们都有据可查。因此，此处仅提供指向这些文档的链接。建议有兴趣的读者尝试一下。</p>
<h5 id="性能优化技术"><a href="#性能优化技术" class="headerlink" title="性能优化技术"></a>性能优化技术</h5><p>有几种技术和编码方法可以充分利用 Python 和 Numpy 的最大性能。这里只注明相关的，并给出重要来源的链接。这里要注意的主要一点是，首先尝试以简单的方式实现算法。一旦它开始工作，就对其进行分析，找到瓶颈并对其进行优化。</p>
<ol>
<li>尽量避免在 Python 中使用循环，尤其是双&#x2F;三循环等。它们本质上是缓慢的。</li>
<li>尽可能地矢量化算法&#x2F;代码，因为 Numpy 和 OpenCV 针对矢量运算进行了优化。</li>
<li>利用缓存一致性。</li>
<li>除非必要，否则切勿复制数组。尝试改用视图。数组复制是一项成本高昂的操作。</li>
</ol>
<p>如果在执行所有这些操作后代码仍然很慢，或者如果不可避免地使用大循环，请使用 Cython 等其他库来使其更快。</p>
<h5 id="其他资源-4"><a href="#其他资源-4" class="headerlink" title="其他资源"></a>其他资源</h5><ol>
<li><a target="_blank" rel="noopener" href="http://wiki.python.org/moin/PythonSpeed/PerformanceTips">Python 优化技术</a></li>
<li>Scipy 讲义 - <a target="_blank" rel="noopener" href="http://scipy-lectures.github.io/advanced/advanced_numpy/index.html#advanced-numpy">高级 Numpy</a></li>
<li><a target="_blank" rel="noopener" href="http://pynash.org/2013/03/06/timing-and-profiling/">IPython 中的计时和分析</a></li>
</ol>
<h5 id="习题-5"><a href="#习题-5" class="headerlink" title="习题"></a>习题</h5><hr>
<h3 id="Image-Processing-in-OpenCV-OpenCV中的图像处理"><a href="#Image-Processing-in-OpenCV-OpenCV中的图像处理" class="headerlink" title="Image Processing in OpenCV - OpenCV中的图像处理"></a><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/d2/d96/tutorial_py_table_of_contents_imgproc.html"><strong>Image Processing in OpenCV</strong></a> - OpenCV中的图像处理</h3><p>(在本节中，您将学习OpencV中不同的图像处理函数。)</p>
<h5 id="改变颜色"><a href="#改变颜色" class="headerlink" title="改变颜色"></a><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/df/d9d/tutorial_py_colorspaces.html">改变颜色</a></h5><p>(学会在不同的色彩空间之间改变图像。另外学习在视频中跟踪有颜色的物体。)</p>
<h5 id="目标-8"><a href="#目标-8" class="headerlink" title="目标"></a>目标</h5><ul>
<li>在本教程中，您将学习如何将图像从一个色彩空间转换为另一个色彩空间，例如 BGR ↔ Gray，BGR ↔ HSV 等</li>
<li>除此之外，我们还将创建一个应用程序来提取视频中的彩色对象</li>
<li>您将学习以下函数：<a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/d8/d01/group__imgproc__color__conversions.html#ga397ae87e1288a81d2363b61574eb8cab"><strong>cv.cvtColor()</strong></a>, <a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/d2/de8/group__core__array.html#ga48af0ab51e36436c5d04340e036ce981"><strong>cv.inRange()</strong></a> 等。</li>
</ul>
<h5 id="更改色彩空间"><a href="#更改色彩空间" class="headerlink" title="更改色彩空间"></a>更改色彩空间</h5><p>OpenCV 中有 150 多种颜色空间转换方法。但我们只研究两个，它们是使用最广泛的：BGR ↔ Gray 和 BGR ↔ HSV。</p>
<p>对于颜色转换，我们使用函数 cv.cvtColor(input_image, flag)，其中 flag 确定转换的类型。</p>
<p>对于 BGR → Gray 转换，我们使用 <a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/d8/d01/group__imgproc__color__conversions.html#gga4e0972be5de079fed4e3a10e24ef5ef0a353a4b8db9040165db4dacb5bcefb6ea">cv.COLOR_BGR2GRAY</a> 标志。BGR → HSV 也是如此，我们使用 <a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/d8/d01/group__imgproc__color__conversions.html#gga4e0972be5de079fed4e3a10e24ef5ef0aa4a7f0ecf2e94150699e48c79139ee12">cv.COLOR_BGR2HSV</a> 标志。要获取其他标志，只需在 Python 终端中运行以下命令：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>flags = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">dir</span>(cv) <span class="keyword">if</span> i.startswith(<span class="string">&#x27;COLOR_&#x27;</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>( flags )</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong></p>
<p>对于 HSV，色相范围为 [0,179]，饱和度范围为 [0,255]，值范围为 [0,255]。不同的软件使用不同的尺度。因此，如果要将 OpenCV 值与它们进行比较，则需要对这些范围进行标准化。</p>
</blockquote>
<h5 id="对象跟踪"><a href="#对象跟踪" class="headerlink" title="对象跟踪"></a>对象跟踪</h5><p>现在我们知道了如何将 BGR 图像转换为 HSV，我们可以使用它来提取彩色对象。在 HSV 中，表示颜色比在 BGR 颜色空间中更容易。在我们的应用程序中，我们将尝试提取蓝色对象。所以这是方法：</p>
<ul>
<li>拍摄视频的每一帧</li>
<li>从 BGR 转换为 HSV 色彩空间</li>
<li>我们将 HSV 图像阈值设置为蓝色范围</li>
<li>现在单独提取蓝色对象，我们可以对该图像执行任何操作。</li>
</ul>
<p>下面是详细注释的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"> </span><br><span class="line">cap = cv.VideoCapture(<span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># Take each frame</span></span><br><span class="line">    _, frame = cap.read()</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># Convert BGR to HSV</span></span><br><span class="line">    hsv = cv.cvtColor(frame, cv.COLOR_BGR2HSV)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># define range of blue color in HSV</span></span><br><span class="line">    lower_blue = np.array([<span class="number">110</span>,<span class="number">50</span>,<span class="number">50</span>])</span><br><span class="line">    upper_blue = np.array([<span class="number">130</span>,<span class="number">255</span>,<span class="number">255</span>])</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># Threshold the HSV image to get only blue colors</span></span><br><span class="line">    mask = cv.inRange(hsv, lower_blue, upper_blue)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># Bitwise-AND mask and original image</span></span><br><span class="line">    res = cv.bitwise_and(frame,frame, mask= mask)</span><br><span class="line"> </span><br><span class="line">    cv.imshow(<span class="string">&#x27;frame&#x27;</span>,frame)</span><br><span class="line">    cv.imshow(<span class="string">&#x27;mask&#x27;</span>,mask)</span><br><span class="line">    cv.imshow(<span class="string">&#x27;res&#x27;</span>,res)</span><br><span class="line">    k = cv.waitKey(<span class="number">5</span>) &amp; <span class="number">0xFF</span></span><br><span class="line">    <span class="keyword">if</span> k == <span class="number">27</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"> </span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>

<p>下图显示了对蓝色对象的跟踪：</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://raw.gitmirror.com/immortal3180/Repo/main/img/GithubPicBed/20240825-/20240908124137.png" alt="image"></p>
<blockquote>
<p><strong>注意</strong></p>
<p>图像中有一些杂色。我们将在后面的章节中看到如何删除它。</p>
<p>这是对象跟踪中最简单的方法。一旦你学会了等值线的功能，你就可以做很多事情，比如找到对象的质心并使用它来跟踪对象，只需在相机前移动你的手就可以画图表，以及其他有趣的事情。</p>
</blockquote>
<h5 id="如何找到要跟踪的-HSV-值？"><a href="#如何找到要跟踪的-HSV-值？" class="headerlink" title="如何找到要跟踪的 HSV 值？"></a>如何找到要跟踪的 HSV 值？</h5><p>这是 <a target="_blank" rel="noopener" href="http://www.stackoverflow.com/">stackoverflow.com</a> 中的常见问题。这非常简单，您可以使用相同的函数 <a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/d8/d01/group__imgproc__color__conversions.html#ga397ae87e1288a81d2363b61574eb8cab">cv.cvtColor()</a>。您无需传递图像，只需传递所需的 BGR 值。例如，要查找 Green 的 HSV 值，请在 Python 终端中尝试以下命令：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>green = np.uint8([[[<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span> ]]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hsv_green = cv.cvtColor(green,cv.COLOR_BGR2HSV)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>( hsv_green )</span><br><span class="line">[[[ <span class="number">60</span> <span class="number">255</span> <span class="number">255</span>]]]</span><br></pre></td></tr></table></figure>

<p>现在，您分别将 [H-10, 100, 100] 和 [H+10, 255, 255] 作为下限和上限。除了这种方法，您还可以使用任何图像编辑工具(如 GIMP)或任何在线转换器来查找这些值，但不要忘记调整 HSV 范围。</p>
<h5 id="其他资源-5"><a href="#其他资源-5" class="headerlink" title="其他资源"></a>其他资源</h5><h5 id="习题-6"><a href="#习题-6" class="headerlink" title="习题"></a>习题</h5><ol>
<li>尝试找到一种方法来提取多个彩色对象，例如，同时提取红色、蓝色和绿色对象。</li>
</ol>
<hr>
<h4 id="图像的几何变换"><a href="#图像的几何变换" class="headerlink" title="图像的几何变换"></a><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/da/d6e/tutorial_py_geometric_transformations.html">图像的几何变换</a></h4><p>(学习应用不同的几何变换图像，如旋转，平移等。)</p>
<h5 id="目标-9"><a href="#目标-9" class="headerlink" title="目标"></a>目标</h5><ul>
<li>学习对图像应用不同的几何变换，如平移、旋转、仿射变换等。</li>
<li>您将看到以下函数：<a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/da/d54/group__imgproc__transform.html#ga20f62aa3235d869c9956436c870893ae"><strong>cv.getPerspectiveTransform</strong></a></li>
</ul>
<h5 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h5><p>OpenCV 提供了两个变换函数，<a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/da/d54/group__imgproc__transform.html#ga0203d9ee5fcd28d40dbc4a1ea4451983"><strong>cv.warpAffine</strong></a> and <a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/da/d54/group__imgproc__transform.html#gaf73673a7e8e18ec6963e3774e6a94b87"><strong>cv.warpPerspective</strong></a>，**你可以使用它们执行各种变换。 **<a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/da/d54/group__imgproc__transform.html#ga0203d9ee5fcd28d40dbc4a1ea4451983"><strong>cv.warpAffine</strong></a> 采用 2x3 变换矩阵，而 <a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/da/d54/group__imgproc__transform.html#gaf73673a7e8e18ec6963e3774e6a94b87"><strong>cv.warpPerspective</strong></a> 采用 3x3 变换矩阵作为输入。</p>
<h5 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h5><p>缩放只是调整图像的大小。为此 OpenCV 附带了一个函数 <strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/da/d54/group__imgproc__transform.html#ga47a974309e9102f5f08231edc7e7529d">cv.resize()</a><strong>。可以手动指定图像的大小，也可以指定缩放因子。使用不同的插值方法。首选的插值方法是 <strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/da/d54/group__imgproc__transform.html#gga5bb5a1fea74ea38e1a5445ca803ff121acf959dca2480cc694ca016b81b442ceb">cv.INTER_AREA</a></strong> 用于缩小，</strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/da/d54/group__imgproc__transform.html#gga5bb5a1fea74ea38e1a5445ca803ff121a55e404e7fa9684af79fe9827f36a5dc1">cv.INTER_CUBIC</a></strong> (慢速) &amp; <strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/da/d54/group__imgproc__transform.html#gga5bb5a1fea74ea38e1a5445ca803ff121ac97d8e4880d8b5d509e96825c7522deb">cv.INTER_LINEAR</a></strong> 用于缩放。默认情况下，插值方法 <strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/da/d54/group__imgproc__transform.html#gga5bb5a1fea74ea38e1a5445ca803ff121ac97d8e4880d8b5d509e96825c7522deb">cv.INTER_LINEAR</a></strong> 用于所有大小调整目的。您可以使用以下任一方法调整输入图像的大小：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">import cv2 as cv</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">img = [cv.imread](https://docs.opencv.org/4.10.0/d4/da8/group__imgcodecs.html#gab32ee19e22660912565f8140d0f675a8)(&#x27;messi5.jpg&#x27;)</span><br><span class="line"></span><br><span class="line">assert img is not None, &quot;file could not be read, check with os.path.exists()&quot;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">res = [cv.resize](https://docs.opencv.org/4.10.0/da/d54/group__imgproc__transform.html#ga47a974309e9102f5f08231edc7e7529d)(img,None,fx=2, fy=2, interpolation = cv.INTER_CUBIC)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">\#OR</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">height, width = img.shape[:2]</span><br><span class="line"></span><br><span class="line">res = [cv.resize](https://docs.opencv.org/4.10.0/da/d54/group__imgproc__transform.html#ga47a974309e9102f5f08231edc7e7529d)(img,(2*width, 2*height), interpolation = cv.INTER_CUBIC)</span><br></pre></td></tr></table></figure>

<h2 id="平移"><a href="#平移" class="headerlink" title="平移"></a>平移</h2><p>平移是物体位置的移动。如果你知道 (x,y) 方向的位移并设为 (tx,ty), you can create the transformation matrix M as follows:</p>
<p>M&#x3D;[10tx01ty]</p>
<p>You can take make it into a Numpy array of type np.float32 and pass it into the <strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/da/d54/group__imgproc__transform.html#ga0203d9ee5fcd28d40dbc4a1ea4451983">cv.warpAffine()</a></strong> function. See the below example for a shift of (100,50):</p>
<p>import numpy as np</p>
<p>import cv2 as cv</p>
<p>img &#x3D; <a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/d4/da8/group__imgcodecs.html#gab32ee19e22660912565f8140d0f675a8">cv.imread</a>(‘messi5.jpg’, cv.IMREAD_GRAYSCALE)</p>
<p>assert img is not None, “file could not be read, check with os.path.exists()”</p>
<p>rows,cols &#x3D; img.shape</p>
<p>M &#x3D; np.float32([[1,0,100],[0,1,50]])</p>
<p>dst &#x3D; <a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/da/d54/group__imgproc__transform.html#ga0203d9ee5fcd28d40dbc4a1ea4451983">cv.warpAffine</a>(img,M,(cols,rows))</p>
<p><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/d7/dfc/group__highgui.html#ga453d42fe4cb60e5723281a89973ee563">cv.imshow</a>(‘img’,dst)</p>
<p><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/d7/dfc/group__highgui.html#ga5628525ad33f52eab17feebcfba38bd7">cv.waitKey</a>(0)</p>
<p><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/d7/dfc/group__highgui.html#ga6b7fc1c1a8960438156912027b38f481">cv.destroyAllWindows</a>()</p>
<p><strong>warning</strong></p>
<p>The third argument of the <strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/da/d54/group__imgproc__transform.html#ga0203d9ee5fcd28d40dbc4a1ea4451983">cv.warpAffine()</a></strong> function is the size of the output image, which should be in the form of <strong>(width, height)</strong>. Remember width &#x3D; number of columns, and height &#x3D; number of rows.</p>
<p>See the result below:</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://docs.opencv.org/4.10.0/translation.jpg" alt="img"></p>
<p>image</p>
<h2 id="Rotation"><a href="#Rotation" class="headerlink" title="Rotation"></a>Rotation</h2><p>Rotation of an image for an angle θ is achieved by the transformation matrix of the form</p>
<p>M&#x3D;[cosθ−sinθsinθcosθ]</p>
<p>But OpenCV provides scaled rotation with adjustable center of rotation so that you can rotate at any location you prefer. The modified transformation matrix is given by</p>
<p>[αβ(1−α)⋅center.x−β⋅center.y−βαβ⋅center.x+(1−α)⋅center.y]</p>
<p>where:</p>
<p>α&#x3D;scale⋅cos⁡θ,β&#x3D;scale⋅sin⁡θ</p>
<p>To find this transformation matrix, OpenCV provides a function, <strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/da/d54/group__imgproc__transform.html#gafbbc470ce83812914a70abfb604f4326">cv.getRotationMatrix2D</a></strong>. Check out the below example which rotates the image by 90 degree with respect to center without any scaling.</p>
<p>img &#x3D; <a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/d4/da8/group__imgcodecs.html#gab32ee19e22660912565f8140d0f675a8">cv.imread</a>(‘messi5.jpg’, cv.IMREAD_GRAYSCALE)</p>
<p>assert img is not None, “file could not be read, check with os.path.exists()”</p>
<p>rows,cols &#x3D; img.shape</p>
<p># cols-1 and rows-1 are the coordinate limits.</p>
<p>M &#x3D; <a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/da/d54/group__imgproc__transform.html#gafbbc470ce83812914a70abfb604f4326">cv.getRotationMatrix2D</a>(((cols-1)&#x2F;2.0,(rows-1)&#x2F;2.0),90,1)</p>
<p>dst &#x3D; <a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/da/d54/group__imgproc__transform.html#ga0203d9ee5fcd28d40dbc4a1ea4451983">cv.warpAffine</a>(img,M,(cols,rows))</p>
<p>See the result:</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://docs.opencv.org/4.10.0/rotation.jpg" alt="img"></p>
<p>image</p>
<h2 id="Affine-Transformation"><a href="#Affine-Transformation" class="headerlink" title="Affine Transformation"></a>Affine Transformation</h2><p>In affine transformation, all parallel lines in the original image will still be parallel in the output image. To find the transformation matrix, we need three points from the input image and their corresponding locations in the output image. Then <strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/da/d54/group__imgproc__transform.html#ga8f6d378f9f8eebb5cb55cd3ae295a999">cv.getAffineTransform</a></strong> will create a 2x3 matrix which is to be passed to <strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/da/d54/group__imgproc__transform.html#ga0203d9ee5fcd28d40dbc4a1ea4451983">cv.warpAffine</a></strong>.</p>
<p>Check the below example, and also look at the points I selected (which are marked in green color):</p>
<p>img &#x3D; <a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/d4/da8/group__imgcodecs.html#gab32ee19e22660912565f8140d0f675a8">cv.imread</a>(‘drawing.png’)</p>
<p>assert img is not None, “file could not be read, check with os.path.exists()”</p>
<p>rows,cols,ch &#x3D; img.shape</p>
<p>pts1 &#x3D; np.float32([[50,50],[200,50],[50,200]])</p>
<p>pts2 &#x3D; np.float32([[10,100],[200,50],[100,250]])</p>
<p>M &#x3D; <a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/da/d54/group__imgproc__transform.html#ga8f6d378f9f8eebb5cb55cd3ae295a999">cv.getAffineTransform</a>(pts1,pts2)</p>
<p>dst &#x3D; <a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/da/d54/group__imgproc__transform.html#ga0203d9ee5fcd28d40dbc4a1ea4451983">cv.warpAffine</a>(img,M,(cols,rows))</p>
<p>plt.subplot(121),plt.imshow(img),plt.title(‘Input’)</p>
<p>plt.subplot(122),plt.imshow(dst),plt.title(‘Output’)</p>
<p>plt.show()</p>
<p>See the result:</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://docs.opencv.org/4.10.0/affine.jpg" alt="img"></p>
<p>image</p>
<h2 id="Perspective-Transformation"><a href="#Perspective-Transformation" class="headerlink" title="Perspective Transformation"></a>Perspective Transformation</h2><p>For perspective transformation, you need a 3x3 transformation matrix. Straight lines will remain straight even after the transformation. To find this transformation matrix, you need 4 points on the input image and corresponding points on the output image. Among these 4 points, 3 of them should not be collinear. Then the transformation matrix can be found by the function <strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/da/d54/group__imgproc__transform.html#ga20f62aa3235d869c9956436c870893ae">cv.getPerspectiveTransform</a></strong>. Then apply <strong><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/da/d54/group__imgproc__transform.html#gaf73673a7e8e18ec6963e3774e6a94b87">cv.warpPerspective</a></strong> with this 3x3 transformation matrix.</p>
<p>See the code below:</p>
<p>img &#x3D; <a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/d4/da8/group__imgcodecs.html#gab32ee19e22660912565f8140d0f675a8">cv.imread</a>(‘sudoku.png’)</p>
<p>assert img is not None, “file could not be read, check with os.path.exists()”</p>
<p>rows,cols,ch &#x3D; img.shape</p>
<p>pts1 &#x3D; np.float32([[56,65],[368,52],[28,387],[389,390]])</p>
<p>pts2 &#x3D; np.float32([[0,0],[300,0],[0,300],[300,300]])</p>
<p>M &#x3D; <a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/da/d54/group__imgproc__transform.html#ga20f62aa3235d869c9956436c870893ae">cv.getPerspectiveTransform</a>(pts1,pts2)</p>
<p>dst &#x3D; <a target="_blank" rel="noopener" href="https://docs.opencv.org/4.10.0/da/d54/group__imgproc__transform.html#gaf73673a7e8e18ec6963e3774e6a94b87">cv.warpPerspective</a>(img,M,(300,300))</p>
<p>plt.subplot(121),plt.imshow(img),plt.title(‘Input’)</p>
<p>plt.subplot(122),plt.imshow(dst),plt.title(‘Output’)</p>
<p>plt.show()</p>
<p>Result:</p>
<p><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://docs.opencv.org/4.10.0/perspective.jpg" alt="img"></p>
<p>image</p>
<h1 id="Additional-Resources"><a href="#Additional-Resources" class="headerlink" title="Additional Resources"></a>Additional Resources</h1><ol>
<li>“Computer Vision: Algorithms and Applications”, Richard Szeliski</li>
</ol>
<h1 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h1><p>Generated on Sun Jun 2 2024 21:52:14 for OpenCV by  <a target="_blank" rel="noopener" href="http://www.doxygen.org/index.html"> <img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="https://docs.opencv.org/4.10.0/doxygen.png" alt="doxygen"> </a>1.9.8</p>


</article>
<div class="related-wrap" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">较新文章</div><a href="/6800H/">6800H 笔记本 性能及优化(magicbook14)</a></div><div class="item" id="next"><div class="note">较早文章</div><a href="/Python/">Python</a></div></section></div>






<footer class="page-footer footnote"><hr><div class="text"><p>© 2024  使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.28.1">Stellar 1.28.1</a> 主题创建<br>文章采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处<br><a target="_blank" rel="noopener" href="https://stats.uptimerobot.com/kDDbIRso6S">站点监控</a><br><a href="https://icp.gov.moe/?keyword=20240215" target="_blank">萌ICP备20240215号</a></p>
</div></footer>
<div class="main-mask" onclick="sidebar.dismiss()"></div></div><aside class="l_right">
<div class="widgets">



<widget class="widget-wrapper toc" id="data-toc" collapse="false"><div class="widget-header dis-select"><span class="name">本文目录</span><a class="cap-action" onclick="sidebar.toggleTOC()" ><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg></a></div><div class="widget-body"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#OpenCV-Python-Tutorials-OpenCV-Python-%E6%95%99%E7%A8%8B"><span class="toc-text">OpenCV-Python Tutorials -  OpenCV-Python 教程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Gui-Features-in-OpenCV-OpenCV%E7%9A%84Gui%E7%89%B9%E6%80%A7"><span class="toc-text">Gui Features in OpenCV - OpenCV的Gui特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#OpenCV-Python-%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%85%A5%E9%97%A8"><span class="toc-text">OpenCV-Python 图像处理入门</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87"><span class="toc-text">目标</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BA%90%E4%BB%A3%E7%A0%81"><span class="toc-text">源代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A"><span class="toc-text">解释</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OpenCV-Python-%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86%E5%85%A5%E9%97%A8"><span class="toc-text">OpenCV-Python 视频处理入门</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87-1"><span class="toc-text">目标</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8E%E6%91%84%E5%83%8F%E6%9C%BA%E6%8D%95%E6%8D%89%E8%A7%86%E9%A2%91"><span class="toc-text">从摄像机捕捉视频</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8E%E6%96%87%E4%BB%B6%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91"><span class="toc-text">从文件播放视频</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%9D%E5%AD%98%E8%A7%86%E9%A2%91"><span class="toc-text">保存视频</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A2%9D%E5%A4%96%E7%9A%84%E8%B5%84%E6%BA%90"><span class="toc-text">额外的资源</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0"><span class="toc-text">练习</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#OpenCV%E4%B8%AD%E7%9A%84%E7%BB%98%E5%9B%BE%E5%87%BD%E6%95%B0"><span class="toc-text">OpenCV中的绘图函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87-2"><span class="toc-text">目标</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%98%E5%88%B6%E7%9B%B4%E7%BA%BF"><span class="toc-text">绘制直线</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%98%E5%88%B6%E7%9F%A9%E5%BD%A2"><span class="toc-text">绘制矩形</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%98%E5%88%B6%E5%9C%86"><span class="toc-text">绘制圆</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%98%E5%88%B6%E6%A4%AD%E5%9C%86"><span class="toc-text">绘制椭圆</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%98%E5%88%B6%E5%A4%9A%E8%BE%B9%E5%BD%A2"><span class="toc-text">绘制多边形</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%A8%E5%9B%BE%E5%83%8F%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%96%87%E6%9C%AC%EF%BC%9A"><span class="toc-text">在图像中添加文本：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%93%E6%9E%9C"><span class="toc-text">结果</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E8%B5%84%E6%BA%90"><span class="toc-text">其他资源</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98"><span class="toc-text">习题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BC%A0%E6%A0%87%E4%BD%9C%E4%B8%BA%E7%94%BB%E7%AC%94"><span class="toc-text">鼠标作为画笔</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87-3"><span class="toc-text">目标</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%BC%94%E7%A4%BA"><span class="toc-text">简单演示</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9B%B4%E9%AB%98%E7%BA%A7%E7%9A%84%E6%BC%94%E7%A4%BA"><span class="toc-text">更高级的演示</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E8%B5%84%E6%BA%90-1"><span class="toc-text">其他资源</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98-1"><span class="toc-text">习题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Trackbar-%E4%BD%9C%E4%B8%BA%E8%B0%83%E8%89%B2%E6%9D%BF"><span class="toc-text">Trackbar 作为调色板</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87-4"><span class="toc-text">目标</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA"><span class="toc-text">代码演示</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98-2"><span class="toc-text">习题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Core-Operations-%E6%A0%B8%E5%BF%83%E4%B8%9A%E5%8A%A1"><span class="toc-text">Core Operations - 核心业务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E5%9B%BE%E5%83%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-text">对图像的基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87-5"><span class="toc-text">目标</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%92%8C%E4%BF%AE%E6%94%B9%E5%83%8F%E7%B4%A0%E5%80%BC"><span class="toc-text">访问和修改像素值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%9B%BE%E5%83%8F%E5%B1%9E%E6%80%A7"><span class="toc-text">访问图像属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F-ROI"><span class="toc-text">图像 ROI</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8B%86%E5%88%86%E5%92%8C%E5%90%88%E5%B9%B6%E5%9B%BE%E5%83%8F%E9%80%9A%E9%81%93"><span class="toc-text">拆分和合并图像通道</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E5%9B%BE%E5%83%8F%E5%88%9B%E5%BB%BA%E8%BE%B9%E6%A1%86%EF%BC%88%E5%A1%AB%E5%85%85%EF%BC%89"><span class="toc-text">为图像创建边框（填充）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E8%B5%84%E6%BA%90-2"><span class="toc-text">其他资源</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98-3"><span class="toc-text">习题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E7%9A%84%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97"><span class="toc-text">图像的算术运算</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87-6"><span class="toc-text">目标</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E6%B7%BB%E5%8A%A0"><span class="toc-text">图像添加</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E6%B7%B7%E5%90%88"><span class="toc-text">图像混合</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%89%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-text">按位运算</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E8%B5%84%E6%BA%90-3"><span class="toc-text">其他资源</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98-4"><span class="toc-text">习题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E6%B5%8B%E9%87%8F%E5%92%8C%E6%94%B9%E8%BF%9B%E6%8A%80%E6%9C%AF"><span class="toc-text">性能测量和改进技术</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87-7"><span class="toc-text">目标</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-OpenCV-%E6%B5%8B%E9%87%8F%E6%80%A7%E8%83%BD"><span class="toc-text">使用 OpenCV 测量性能</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#OpenCV-%E4%B8%AD%E7%9A%84%E9%BB%98%E8%AE%A4%E4%BC%98%E5%8C%96"><span class="toc-text">OpenCV 中的默认优化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%A8-IPython-%E4%B8%AD%E6%B5%8B%E9%87%8F%E6%80%A7%E8%83%BD"><span class="toc-text">在 IPython 中测量性能</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9B%B4%E5%A4%9A-IPython-%E9%AD%94%E6%9C%AF%E5%91%BD%E4%BB%A4"><span class="toc-text">更多 IPython 魔术命令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF"><span class="toc-text">性能优化技术</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E8%B5%84%E6%BA%90-4"><span class="toc-text">其他资源</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98-5"><span class="toc-text">习题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Image-Processing-in-OpenCV-OpenCV%E4%B8%AD%E7%9A%84%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86"><span class="toc-text">Image Processing in OpenCV - OpenCV中的图像处理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%94%B9%E5%8F%98%E9%A2%9C%E8%89%B2"><span class="toc-text">改变颜色</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87-8"><span class="toc-text">目标</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9B%B4%E6%94%B9%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4"><span class="toc-text">更改色彩空间</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E8%B7%9F%E8%B8%AA"><span class="toc-text">对象跟踪</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%89%BE%E5%88%B0%E8%A6%81%E8%B7%9F%E8%B8%AA%E7%9A%84-HSV-%E5%80%BC%EF%BC%9F"><span class="toc-text">如何找到要跟踪的 HSV 值？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E8%B5%84%E6%BA%90-5"><span class="toc-text">其他资源</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98-6"><span class="toc-text">习题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E7%9A%84%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2"><span class="toc-text">图像的几何变换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87-9"><span class="toc-text">目标</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2"><span class="toc-text">转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%A9%E6%94%BE"><span class="toc-text">缩放</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B3%E7%A7%BB"><span class="toc-text">平移</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Rotation"><span class="toc-text">Rotation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Affine-Transformation"><span class="toc-text">Affine Transformation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Perspective-Transformation"><span class="toc-text">Perspective Transformation</span></a></li></ol></div><div class="widget-footer">

<a class="top" onclick="util.scrollTop()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 12c0-4.714 0-7.071 1.464-8.536C4.93 2 7.286 2 12 2c4.714 0 7.071 0 8.535 1.464C22 4.93 22 7.286 22 12c0 4.714 0 7.071-1.465 8.535C19.072 22 16.714 22 12 22s-7.071 0-8.536-1.465C2 19.072 2 16.714 2 12Z"/><path stroke-linecap="round" stroke-linejoin="round" d="m9 15.5l3-3l3 3m-6-4l3-3l3 3"/></g></svg><span>回到顶部</span></a><a class="buttom" onclick="util.scrollComment()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M10.46 1.25h3.08c1.603 0 2.86 0 3.864.095c1.023.098 1.861.3 2.6.752a5.75 5.75 0 0 1 1.899 1.899c.452.738.654 1.577.752 2.6c.095 1.004.095 2.261.095 3.865v1.067c0 1.141 0 2.036-.05 2.759c-.05.735-.153 1.347-.388 1.913a5.75 5.75 0 0 1-3.112 3.112c-.805.334-1.721.408-2.977.43a10.81 10.81 0 0 0-.929.036c-.198.022-.275.054-.32.08c-.047.028-.112.078-.224.232c-.121.166-.258.396-.476.764l-.542.916c-.773 1.307-2.69 1.307-3.464 0l-.542-.916a10.605 10.605 0 0 0-.476-.764c-.112-.154-.177-.204-.224-.232c-.045-.026-.122-.058-.32-.08c-.212-.023-.49-.03-.93-.037c-1.255-.021-2.171-.095-2.976-.429A5.75 5.75 0 0 1 1.688 16.2c-.235-.566-.338-1.178-.389-1.913c-.049-.723-.049-1.618-.049-2.76v-1.066c0-1.604 0-2.86.095-3.865c.098-1.023.3-1.862.752-2.6a5.75 5.75 0 0 1 1.899-1.899c.738-.452 1.577-.654 2.6-.752C7.6 1.25 8.857 1.25 10.461 1.25M6.739 2.839c-.914.087-1.495.253-1.959.537A4.25 4.25 0 0 0 3.376 4.78c-.284.464-.45 1.045-.537 1.96c-.088.924-.089 2.11-.089 3.761v1c0 1.175 0 2.019.046 2.685c.045.659.131 1.089.278 1.441a4.25 4.25 0 0 0 2.3 2.3c.515.214 1.173.294 2.429.316h.031c.398.007.747.013 1.037.045c.311.035.616.104.909.274c.29.17.5.395.682.645c.169.232.342.525.538.856l.559.944a.52.52 0 0 0 .882 0l.559-.944c.196-.331.37-.624.538-.856c.182-.25.392-.476.682-.645c.293-.17.598-.24.909-.274c.29-.032.639-.038 1.037-.045h.032c1.255-.022 1.913-.102 2.428-.316a4.25 4.25 0 0 0 2.3-2.3c.147-.352.233-.782.278-1.441c.046-.666.046-1.51.046-2.685v-1c0-1.651 0-2.837-.089-3.762c-.087-.914-.253-1.495-.537-1.959a4.25 4.25 0 0 0-1.403-1.403c-.464-.284-1.045-.45-1.96-.537c-.924-.088-2.11-.089-3.761-.089h-3c-1.651 0-2.837 0-3.762.089" clip-rule="evenodd"/><path fill="currentColor" d="M9 11a1 1 0 1 1-2 0a1 1 0 0 1 2 0m4 0a1 1 0 1 1-2 0a1 1 0 0 1 2 0m4 0a1 1 0 1 1-2 0a1 1 0 0 1 2 0"/></svg><span>参与讨论</span></a></div></widget>
</div></aside><div class='float-panel blur'>
  <button type='button' style='display:none' class='laptop-only rightbar-toggle mobile' onclick='sidebar.rightbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg>
  </button>
  <button type='button' style='display:none' class='mobile-only leftbar-toggle mobile' onclick='sidebar.leftbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 11c0-3.771 0-5.657 1.172-6.828C4.343 3 6.229 3 10 3h4c3.771 0 5.657 0 6.828 1.172C22 5.343 22 7.229 22 11v2c0 3.771 0 5.657-1.172 6.828C19.657 21 17.771 21 14 21h-4c-3.771 0-5.657 0-6.828-1.172C2 18.657 2 16.771 2 13z"/><path id="sep" stroke-linecap="round" d="M5.5 10h6m-5 4h4m4.5 7V3"/></g></svg>
  </button>
</div>
</div><div class="scripts">
<script type="text/javascript">
  const ctx = {
    date_suffix: {
      just: `刚刚`,
      min: `分钟前`,
      hour: `小时前`,
      day: `天前`,
    },
    root : `/`,
  };

  // required plugins (only load if needs)
  if (`local_search`) {
    ctx.search = {};
    ctx.search.service = `local_search`;
    if (ctx.search.service == 'local_search') {
      let service_obj = Object.assign({}, `{"field":"all","path":"/search.json","content":true,"sort":"-date"}`);
      ctx.search[ctx.search.service] = service_obj;
    }
  }
  const def = {
    avatar: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg`,
    cover: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/cover/76b86c0226ffd.svg`,
  };
  const deps = {
    jquery: `https://cdn.bootcdn.net/ajax/libs/jquery/3.7.1/jquery.min.js`,
    marked: `https://cdn.bootcdn.net/ajax/libs/marked/4.0.18/marked.min.js`
  }
  

</script>

<script type="text/javascript">
  const utils = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    css: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    js: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')){
        src = ctx.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    jq: (fn) => {
      if (typeof jQuery === 'undefined') {
        utils.js(deps.jquery).then(fn)
      } else {
        fn()
      }
    },
    
    onLoading: (el) => {
      if (el) {
        $(el).append('<div class="loading-wrap"><svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" stroke-opacity=".3" d="M12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="1.3s" values="60;0"/></path><path stroke-dasharray="15" stroke-dashoffset="15" d="M12 3C16.9706 3 21 7.02944 21 12"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.3s" values="15;0"/><animateTransform attributeName="transform" dur="1.5s" repeatCount="indefinite" type="rotate" values="0 12 12;360 12 12"/></path></g></svg></div>');
      }
    },
    onLoadSuccess: (el) => {
      if (el) {
        $(el).find('.loading-wrap').remove();
      }
    },
    onLoadFailure: (el) => {
      if (el) {
        $(el).find('.loading-wrap svg').remove();
        $(el).find('.loading-wrap').append('<svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" d="M12 3L21 20H3L12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.5s" values="60;0"/></path><path stroke-dasharray="6" stroke-dashoffset="6" d="M12 10V14"><animate fill="freeze" attributeName="stroke-dashoffset" begin="0.6s" dur="0.2s" values="6;0"/></path></g><circle cx="12" cy="17" r="1" fill="currentColor" fill-opacity="0"><animate fill="freeze" attributeName="fill-opacity" begin="0.8s" dur="0.4s" values="0;1"/></circle></svg>');
        $(el).find('.loading-wrap').addClass('error');
      }
    },
    request: (el, url, callback, onFailure) => {
      let retryTimes = 3;
      utils.onLoading(el);
      function req() {
        return new Promise((resolve, reject) => {
          let status = 0; // 0 等待 1 完成 2 超时
          let timer = setTimeout(() => {
            if (status === 0) {
              status = 2;
              timer = null;
              reject('请求超时');
              if (retryTimes == 0) {
                onFailure();
              }
            }
          }, 5000);
          fetch(url).then(function(response) {
            if (status !== 2) {
              clearTimeout(timer);
              resolve(response);
              timer = null;
              status = 1;
            }
            if (response.ok) {
              return response.json();
            }
            throw new Error('Network response was not ok.');
          }).then(function(data) {
            retryTimes = 0;
            utils.onLoadSuccess(el);
            callback(data);
          }).catch(function(error) {
            if (retryTimes > 0) {
              retryTimes -= 1;
              setTimeout(() => {
                req();
              }, 5000);
            } else {
              utils.onLoadFailure(el);
              onFailure();
            }
          });
        });
      }
      req();
    },
  };
</script>

<script>
  const sidebar = {
    leftbar: () => {
      if (l_body) {
        l_body.toggleAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    rightbar: () => {
      if (l_body) {
        l_body.toggleAttribute('rightbar');
        l_body.removeAttribute('leftbar');
      }
    },
    dismiss: () => {
      if (l_body) {
        l_body.removeAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    toggleTOC: () => {
      document.querySelector('#data-toc').classList.toggle('collapse');
    }
  }
</script>

<!-- required -->
<script src="/js/main.js?v=1.28.1" async></script>

<!-- optional -->



<script defer>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.services = Object.assign({}, JSON.parse(`{"mdrender":{"js":"/js/services/mdrender.js"},"siteinfo":{"js":"/js/services/siteinfo.js","api":null},"ghinfo":{"js":"/js/services/ghinfo.js"},"sites":{"js":"/js/services/sites.js"},"friends":{"js":"/js/services/friends.js"},"timeline":{"js":"/js/services/timeline.js"},"fcircle":{"js":"/js/services/fcircle.js"},"weibo":{"js":"/js/services/weibo.js"},"memos":{"js":"/js/services/memos.js"}}`));
    for (let id of Object.keys(ctx.services)) {
      const js = ctx.services[id].js;
      if (id == 'siteinfo') {
        ctx.cardlinks = document.querySelectorAll('a.link-card[cardlink]');
        if (ctx.cardlinks?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            setCardLink(ctx.cardlinks);
          });
        }
      } else {
        const els = document.getElementsByClassName(`ds-${id}`);
        if (els?.length > 0) {
          utils.jq(() => {
            if (id == 'timeline' || 'memos' || 'marked') {
              utils.js(deps.marked).then(function () {
                utils.js(js, { defer: true });
              });
            } else {
              utils.js(js, { defer: true });
            }
          });
        }
      }
    }
  });
</script>

<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.search = {
      path: `/search.json`,
    }
    utils.js('/js/search/local-search.js', { defer: true });
  });
</script><script>
  window.FPConfig = {
    delay: 0,
    ignoreKeywords: [],
    maxRPS: 5,
    hoverDelay: 25
  };
</script>
<script defer src="https://cdn.bootcdn.net/ajax/libs/flying-pages/2.1.2/flying-pages.min.js"></script><script defer src="https://cdn.bootcdn.net/ajax/libs/vanilla-lazyload/17.8.4/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazy",
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    window.lazyLoadInstance?.update();
  });
</script><script>
  ctx.fancybox = {
    selector: `.timenode p>img`,
    css: `https://cdn.bootcdn.net/ajax/libs/fancyapps-ui/5.0.22/fancybox/fancybox.min.css`,
    js: `https://cdn.bootcdn.net/ajax/libs/fancyapps-ui/5.0.22/fancybox/fancybox.umd.min.js`
  };
  var selector = '[data-fancybox]:not(.error)';
  if (ctx.fancybox.selector) {
    selector += `, ${ctx.fancybox.selector}`
  }
  var needFancybox = document.querySelectorAll(selector).length !== 0;
  if (!needFancybox) {
    const els = document.getElementsByClassName('ds-memos');
    if (els != undefined && els.length > 0) {
      needFancybox = true;
    }
  }
  if (needFancybox) {
    utils.css(ctx.fancybox.css);
    utils.js(ctx.fancybox.js, { defer: true }).then(function () {
      Fancybox.bind(selector, {
        hideScrollbar: false,
        Thumbs: {
          autoStart: false,
        },
        caption: (fancybox, slide) => {
          return slide.triggerEl.alt || slide.triggerEl.dataset.caption || null
        }
      });
    })
  }
</script>
<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    const swiper_api = document.getElementById('swiper-api');
    if (swiper_api != undefined) {
      utils.css(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.css`);
      utils.js(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.js`, { defer: true }).then(function () {
        const effect = swiper_api.getAttribute('effect') || '';
        var swiper = new Swiper('.swiper#swiper-api', {
          slidesPerView: 'auto',
          spaceBetween: 8,
          centeredSlides: true,
          effect: effect,
          rewind: true,
          pagination: {
            el: '.swiper-pagination',
            clickable: true,
          },
          navigation: {
            nextEl: '.swiper-button-next',
            prevEl: '.swiper-button-prev',
          },
        });
      })
    }
  });
</script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"] ],
    processEscapes: true
  }
});
MathJax.Hub.Config({
  tex2jax: {
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  }
});
MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for(i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    window.codeElements = document.querySelectorAll('.code');
    if (window.codeElements.length > 0) {
      ctx.copycode = {
        default_text: `Copy`,
        success_text: `Copied`,
        toast: `复制成功`,
      };
      utils.js('/js/plugins/copycode.js');
    }
  });
</script>


<!-- inject -->

</div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/assets/miku.model.json"},"display":{"position":"right","width":150,"height":300,"hOffset":-15,"vOffset":-15},"mobile":{"show":true},"react":{"opacity":0.7},"log":false});</script></body></html>
