[{"title":"Networking-commands","path":"/Networking-commands/","content":"ipconfig_usageipconfig 查看基本网络配置信息ipconfig &#x2F;all 查看详细网络配置信息ipconfig &#x2F;release 释放当前的ip地址ipconfig &#x2F;renew 重新获取ip地址ipconfig &#x2F;flushdns 清除dns缓存ipconfig &#x2F;displaydns 显示dns缓存内容ipconfig &#x2F;registerdns 刷新所有DHCP租约并重新注册dns名称 netstat_usagenetstat 是一个用于监控网络连接和网络统计信息的命令行工具netstat -a 显示所有的网络连接netstat -at 显示活动的TCP连接netstat -r 显示路由表netstat -ano 显示PID(进程标识符)和程序名称netstat -ano | grep 端口数字 结合grep进行过滤，只显示所有与目标端口相关的连接信息netstat -at | grep :443 查看特定协议和端口的连接（grep是linux内置的shell命令，windows系统需要安装如cygwin等第三方软件支持它） pingping IP地址&#x2F;域名 测试基本连通性ping -n 数字 IP地址&#x2F;域名 自定义数据包发送数量的基本连通性测试ping -t IP地址&#x2F;域名 持续不断地测试ping -l 大小 IP地址&#x2F;域名 自定义数据包大小的基本连通性测试ping -r 数量 IP地址 记录数据包经过的路由信息，上限为9ping -a IP地址 将目标IP地址解析为主机名 tracert（Trace Route 的缩写）是一个网络诊断工具，用于确定IP数据包访问目标所采取的路径。它通过向目标发送具有不同生存时间(TTL)值的 Internet控制消息协议(ICMP,Internet control message protocol) 回显数据包，来确定到达目标的路径 arparp -a查看arp缓存表：显示该计算机所有网卡每个网卡通信过的设备的IP地址和MAC地址的对应关系arp -a IP地址查看特定IP地址的ARP缓存项arp -s IP地址 MAC地址人工向ARP缓存中添加静态ARP条目，将某IP地址和特定MAC地址绑定，确保通信时始终使用该MAC地址。作用一：防止ARP欺骗攻击 作用二：一些固定IP与MAC地址对应关系的场景arp -d IP地址 人工删除ARP缓存表中的指定条目arp C:\\Users\\LZF67&gt;ipconfig &#x2F;all Windows IP 配置 主机名 . . . . . . . . . . . . . : LapTop-8860 主 DNS 后缀 . . . . . . . . . . . : 节点类型 . . . . . . . . . . . . : 混合 IP 路由已启用 . . . . . . . . . . : 否 WINS 代理已启用 . . . . . . . . . : 否 以太网适配器 Radmin VPN: 连接特定的 DNS 后缀 . . . . . . . : 描述. . . . . . . . . . . . . . . : Famatech Radmin VPN Ethernet Adapter 物理地址. . . . . . . . . . . . . : 02-50-7E-BA-F5-33 DHCP 已启用 . . . . . . . . . . . : 否 自动配置已启用. . . . . . . . . . : 是 IPv6 地址 . . . . . . . . . . . . : fdfd::1a10:2a05(首选) 本地链接 IPv6 地址. . . . . . . . : fe80::5957:7518:b7df:bc98%12(首选) IPv4 地址 . . . . . . . . . . . . : 26.16.42.5(首选) 子网掩码 . . . . . . . . . . . . : 255.0.0.0 默认网关. . . . . . . . . . . . . : DHCPv6 IAID . . . . . . . . . . . : 906121342 DHCPv6 客户端 DUID . . . . . . . : 00-01-00-01-2D-24-52-F5-38-D5-7A-DF-96-CF TCPIP 上的 NetBIOS . . . . . . . : 已启用 未知适配器 本地连接: 媒体状态 . . . . . . . . . . . . : 媒体已断开连接 连接特定的 DNS 后缀 . . . . . . . : 描述. . . . . . . . . . . . . . . : TAP-Windows Adapter V9 物理地址. . . . . . . . . . . . . : 00-FF-B5-1C-10-75 DHCP 已启用 . . . . . . . . . . . : 是 自动配置已启用. . . . . . . . . . : 是 无线局域网适配器 WLAN 2: 连接特定的 DNS 后缀 . . . . . . . : 描述. . . . . . . . . . . . . . . : Qualcomm WCN685x Wi-Fi 6E Dual Band Simultaneous (DBS) WiFiCx Network Adapter #2 物理地址. . . . . . . . . . . . . : 5A-D5-7A-DF-96-CF DHCP 已启用 . . . . . . . . . . . : 否 自动配置已启用. . . . . . . . . . : 是 本地链接 IPv6 地址. . . . . . . . : fe80::c2f1:4f24:488c:51ee%23(首选) IPv4 地址 . . . . . . . . . . . . : 192.168.137.1(首选) 子网掩码 . . . . . . . . . . . . : 255.255.255.0 默认网关. . . . . . . . . . . . . : TCPIP 上的 NetBIOS . . . . . . . : 已启用 无线局域网适配器 WLAN 3: 媒体状态 . . . . . . . . . . . . : 媒体已断开连接 连接特定的 DNS 后缀 . . . . . . . : 描述. . . . . . . . . . . . . . . : Qualcomm WCN685x Wi-Fi 6E Dual Band Simultaneous (DBS) WiFiCx Network Adapter #3 物理地址. . . . . . . . . . . . . : 3A-D5-7A-DF-96-CF DHCP 已启用 . . . . . . . . . . . : 是 自动配置已启用. . . . . . . . . . : 是 以太网适配器 VMware Network Adapter VMnet1: 连接特定的 DNS 后缀 . . . . . . . : 描述. . . . . . . . . . . . . . . : VMware Virtual Ethernet Adapter for VMnet1 物理地址. . . . . . . . . . . . . : 00-50-56-C0-00-01 DHCP 已启用 . . . . . . . . . . . : 否 自动配置已启用. . . . . . . . . . : 是 本地链接 IPv6 地址. . . . . . . . : fe80::626:622f:199c:64ca%16(首选) IPv4 地址 . . . . . . . . . . . . : 192.168.254.1(首选) 子网掩码 . . . . . . . . . . . . : 255.255.255.0 默认网关. . . . . . . . . . . . . : DHCPv6 IAID . . . . . . . . . . . : 687886422 DHCPv6 客户端 DUID . . . . . . . : 00-01-00-01-2D-24-52-F5-38-D5-7A-DF-96-CF TCPIP 上的 NetBIOS . . . . . . . : 已启用 以太网适配器 VMware Network Adapter VMnet8: 连接特定的 DNS 后缀 . . . . . . . : 描述. . . . . . . . . . . . . . . : VMware Virtual Ethernet Adapter for VMnet8 物理地址. . . . . . . . . . . . . : 00-50-56-C0-00-08 DHCP 已启用 . . . . . . . . . . . : 否 自动配置已启用. . . . . . . . . . : 是 本地链接 IPv6 地址. . . . . . . . : fe80::70e1:361:619d:4b55%6(首选) IPv4 地址 . . . . . . . . . . . . : 192.168.10.1(首选) 子网掩码 . . . . . . . . . . . . : 255.255.255.0 默认网关. . . . . . . . . . . . . : DHCPv6 IAID . . . . . . . . . . . : 704663638 DHCPv6 客户端 DUID . . . . . . . : 00-01-00-01-2D-24-52-F5-38-D5-7A-DF-96-CF TCPIP 上的 NetBIOS . . . . . . . : 已启用 无线局域网适配器 WLAN: 连接特定的 DNS 后缀 . . . . . . . : 描述. . . . . . . . . . . . . . . : Qualcomm WCN685x Wi-Fi 6E Dual Band Simultaneous (DBS) WiFiCx Network Adapter 物理地址. . . . . . . . . . . . . : 38-D5-7A-DF-96-CF DHCP 已启用 . . . . . . . . . . . : 是 自动配置已启用. . . . . . . . . . : 是 本地链接 IPv6 地址. . . . . . . . : fe80::b89b:4764:f211:8cc2%14(首选) IPv4 地址 . . . . . . . . . . . . : 10.21.22.194(首选) 子网掩码 . . . . . . . . . . . . : 255.255.0.0 获得租约的时间 . . . . . . . . . : 2024年10月29日 1:28:48 租约过期的时间 . . . . . . . . . : 2024年10月30日 19:43:56 默认网关. . . . . . . . . . . . . : 10.21.0.1 DHCP 服务器 . . . . . . . . . . . : 10.21.0.1 DHCPv6 IAID . . . . . . . . . . . : 121165178 DHCPv6 客户端 DUID . . . . . . . : 00-01-00-01-2D-24-52-F5-38-D5-7A-DF-96-CF DNS 服务器 . . . . . . . . . . . : 10.23.0.10 10.23.0.11 TCPIP 上的 NetBIOS . . . . . . . : 已启用 以太网适配器 蓝牙网络连接: 媒体状态 . . . . . . . . . . . . : 媒体已断开连接 连接特定的 DNS 后缀 . . . . . . . : 描述. . . . . . . . . . . . . . . : Bluetooth Device (Personal Area Network) 物理地址. . . . . . . . . . . . . : 38-D5-7A-DF-96-D0 DHCP 已启用 . . . . . . . . . . . : 是 自动配置已启用. . . . . . . . . . : 是 隧道适配器 Teredo Tunneling Pseudo-Interface: 连接特定的 DNS 后缀 . . . . . . . : 描述. . . . . . . . . . . . . . . : Microsoft Teredo Tunneling Adapter 物理地址. . . . . . . . . . . . . : 00-00-00-00-00-00-00-E0 DHCP 已启用 . . . . . . . . . . . : 否 自动配置已启用. . . . . . . . . . : 是 IPv6 地址 . . . . . . . . . . . . : 2001:0:2851:b9f0:303b:c515:871f:1334(首选) 本地链接 IPv6 地址. . . . . . . . : fe80::303b:c515:871f:1334%15(首选) 默认网关. . . . . . . . . . . . . : DHCPv6 IAID . . . . . . . . . . . : 234881024 DHCPv6 客户端 DUID . . . . . . . : 00-01-00-01-2D-24-52-F5-38-D5-7A-DF-96-CF TCPIP 上的 NetBIOS . . . . . . . : 已禁用"},{"title":"alist - 拼凑更加实用的网盘","path":"/alist/","content":"AListAlist 是什么？参考：Home | AList文档 🗂️ 一个支持多种存储的文件列表程序，使用 Gin 和 Solidjs。能够将多种网盘结合起来，支持WebDAV(Web-based Distributed Authoring and Versioning，基于Web的分布式创作和版本控制)，支持文件在线预览，可以甩直连 等功能。相比厂商云盘而言有更高的集成度与更好的自由度。 使用 Alist：1.选购云服务器并初始化(以阿里云为例)阿里云 - 云服务器 ECS - 创建规格 - 实例规格ecs.e-c1m1.large - 系统Ubuntu - 其他配置按价格低的选 云服务器状态如图所示 添加安全组规则 - 公网开放alist默认使用的5244端口 配置完安全组规则如图所示 重置实例密码 开始远程连接 登录之后如图所示 2.在云服务器中配置alist参考：alist官方教程文档 一键脚本 | AList文档 12# 在 Linux amd64/arm64 平台上一键安装alistcurl -fsSL &quot;https://alist.nn.ci/v3.sh&quot; | bash -s install 12# 启动 alistsystemctl start alist 12# 进入默认 alist 安装文件夹cd /opt/alist 123# 设置你的管理员登陆密码# 手动设置一个密码,`NEW_PASSWORD`是指你需要设置的密码./alist admin set NEW_PASSWORD 在浏览器中输入服务器对应公网IP:5244，回车，进入alist登录页面 如图所示，alist已经初始化完毕，你可以在公网访问它 3.Alist设置 - 正式使用Alist参考：配置文件 | AList文档 4.Alist设置的备份与恢复在 Alist管理 - 备份&amp;恢复 一栏 5.Alist访问优化：关联域名、启用HTTPS、更改端口(1) 关联域名：在有域名的前提下，到域名商那里添加 A-将域名指向IPv4地址 的主机记录，记录值为云服务器的公网IP地址 (2) 启用Https：申请SSL证书到域名商那里申请域名对应的SSL证书 以华为云举例，参考：华为云免费SSL证书申请_ 【四个步骤】SSL证书免费申请_怎么申请免费SSL证书-华为云 申请流程完毕后，点击下载证书，在将其解压，找到Apache那一部分 Web进入Alist管理 - 存储-添加 - 驱动选择本机存储 - 保存配置 配置完可在主页访问云服务器本机存储，进入根目录&#x2F;opt&#x2F;alist&#x2F;data，上传下载到的证书 再回到服务器，打开config.json修改(可以直接在Web端Alist操作，也可以在云服务器命令行操作) 12345# 回到根目录cd# nano编辑器打开Alist配置文件cd /opt/alist/datanano config.json 在config.json中找到这一段，http端口改-1(禁用)，https端口改443，在cert_file和key_file两栏分别填上刚刚上传的证书文件的相对路径(格式：”data&#x2F;文件名.后缀”)，Ctrl+S保存，Ctrl+X退出 (3) 更改端口安全组按先前操作添加入方向443端口"},{"title":"乐理","path":"/music-scinese/","content":"【B站最通俗易懂的乐理课程（30集），零基础轻松学！适用于作曲编曲、钢琴、吉他、声乐。】 https://www.bilibili.com/video/BV1Hg411w7n2/?p=2&amp;share_source=copy_web&amp;vd_source=a9248fac1911da7678699a591ef91b0c 01 为什么要学习乐理？ 想学乐器 想音乐创作(作曲、编曲、写歌创作) 从事修音后期 声乐 02 音名与钢琴键盘认识钢琴键盘及音名 学乐理为何要认识钢琴键盘？ 钢琴是乐器之王，拥有最宽的音域和直观的黑白键 音乐制作软件里有对应的钢琴窗 开始认识钢琴键盘 钢琴键盘有88个键，去掉最左边的三个键和最右边的三个键，正好可以划分成7个组，每组有7个白键，5个黑键，每一组中前面两个键紧挨，后面三个键紧挨**(左二右三)** 引入概念：音名 先讲白键：每一组中，白键的音名以此为CDEFGAB 黑键在下节 03 升降号、还原号引入概念：半音、全音 两个相邻音之间的关系叫做半音。在白键中，只有EF、BC是半音关系；其他的白键，由于中间隔了一个黑键，便不能叫做半音，而是叫做全音关系。比如CD，中间就隔了一个黑键。 总之，不管是白键还是黑键，相邻是半音，中间隔了一个键是全音。 回到黑键：黑键没有自己的名字，而是借助白键的名字起名。拿白键CD中间的黑键举例：这个黑键和白键C是半音关系；在钢琴键盘上，音越往右越高，越往左越低，所以这个黑键是C升了半音，简称 C♯ (读作升C键)；同理，这个黑键比白键D低了半音，所以简称 D♭ (读作降D音)。综上，一个黑键有两个音名。 同理，一个组中5个黑键的名都可以得出。 为什么黑键有两个名字？是否可以随便选一个用？ 答：不可以。还是拿第一个黑键举例。它叫 C♯ ，又叫 D♭ ； 引入新音乐符号：还原号 ♮ ；对于这个黑键，如果它叫C♯，给它加一个还原号就是还原到了C；如果它叫D♭，给它叫一个还原号便是还原到了D。 所以对于同一个黑键的两个不同的音名的使用是有讲究的。虽然它们代表了同一个黑键，但给它们加上还原号却还原到了不同的白键，并不是可以随便用的。 对于什么情况下用什么样的音名在下节 引入问题：白键EF中间没有黑键，那它们有没有升降？白键BC中间也没有黑键，它们有没有升降？ 答案是有的。E往前升半音就到了F，所以F又可以叫E♯；反过来E也可以叫F♭。这样的音叫做等音。那么为什么要写E♯而不直接写F呢？因为尽管E♯和F代表了同一个键，但这两个表示方法能够与还原号♮配合，分别代表了不同的表达意思，不能混淆使用。 最后来讲重升 &#x1D12A;(以后用♯♯表示) 和 重降 ♭♭。一般五线谱中出现频率比较高，其他情况使用率并不是很高。 重升的意思是升两次半音。比如重升C。第一次半音升到了C♯，第二次半音就到了D键。同样的重降D就是降一次半音到了C♯，再降一次半音就到了C键。 这个一般用于包含了黑键式自然音的调式，然后需要对这个音进行升半音或者降半音。对于初学而言，只需要知道重升&#x2F;重降是升&#x2F;降两次半音。 04 如何区分同一音名的不同键？"},{"title":"eNSP-learn","path":"/eNSP-learn/","content":"Telnet^1、进入远程登录接口(vty)2、配置认证模式(null &#x2F; 密码 &#x2F; aaa) 1234[R1]telnet server enable[R2]user-interface vty 0 4 进入远程登录接口(vty)，允许五个用户同时登录[R2-ui-vty0-4] authentication-mode password 认证模式改为密码认证[R2-ui-vty0-4]set authentication password simple/cipher xx 设置明文/密文显示の密码xx telnet 用户登录的权限默认是 0—-查看权限，若需要管理、配置需要提权 1234[R2-ui-vty0-4]user privilege level 3 用户登录权限等级改为3[R2]int g0/0/0[R2-GigabitEthernet0/0/0]mtu 1200 修改mtu 1&lt;Huawei&gt;display mac-address 查看MAC地址表 相同网段通信ARP流程与交换机工作原理全过程：PC1,PC2 IP 和MACPC1和PC2互通 首先PC1产生数据，传输层封装TCP&#x2F;UDP，网络层封装IP；源IP1.1 目的IP1.2； 到达数据链路层时，封装帧头和帧尾；源MAC01； PC1封装目的MAC时，会首先查看它的ARP表项（arp-a)：发现表项中关于1.2的mac是未知的；于是产生一个ARP广播请求；（广播） 请求消息首先到达交换机，交换机便开始学习源MAC01和接口GE0&#x2F;0&#x2F;1的关系；然后放入到交换机的MAC地址表中；（学习） 交换机根据广播帧（FF:FF:FF:FF:FF:FF)进行泛洪动作，会把该帧从交换机的各个接口发出去；（泛洪） PC2收到该帧，对它进行解封装，得到1.1的MAC是01，记录到自己的ARP表项中；同时发现1.1在请求自己的MAC；便以单播的形式回复；消息到达交换机；（单播） 交换机学习MAC02和端口GE0&#x2F;0&#x2F;2的关系，放入到交换机MAC地址表中；（学习） 根据目的MAC01，查找MAC地址表发现，01对应的GE0&#x2F;0&#x2F;1接口，便从1口转发发送给PC1；（转发) PC1解封装，最后得到1.2的MAC为02，至此得到了想要的MAC。 相同网段通信ARP流程与交换机工作原理—关键要素1.源终端设备 产生数据；一系列封装： 应用层（产生数据）(Data)—&gt;传输层（封装TCP&#x2F;UDP）(数据段)—&gt;网络层（封装IP，包括了源IP和目的IP）(数据包)—&gt;数据链路层(数据帧)–从端口发送至交换机 2.封装目的MAC时，查看ARP表项：（1）目的MAC未知—&gt;ARP广播—&gt;泛洪（2）目的MAC已知—–&gt;单播——&gt;转发 3.消息到达交换机：*学习动作：学习源MAC与接口关系，放入MAC地址表中 （1）广播帧&#x2F;未知单播帧：泛洪动作：把该帧从交换机的各个接口（除刚刚接收该帧的口）发送出去（2）单播帧：转发动作：根据MAC地址表，从目的MAC对应的接口转发出去； 4.所有接收到消息的终端设备 –&gt; 解封装； 数据帧[得知 源 MAC]–&gt;[解封IP]–&gt;数据包[得到 源 的IP]*得到新鲜MAC—&gt;记录到自己的ARP表项中（1）检查其中的目的MAC：是自己的MAC—&gt;请求，需回复； 不是自己的MAC—&gt;将数据包丢弃 小问答： 一、（封装的过程是在哪里发生的？）在发送此数据的设备 二、（交换机的MAC地址表和终端的ARP表项是一个东西吗？）不是。ARP表项 包含 IP地址 和其对应的 MAC地址；MAC地址表 包含 MAC地址 和其对应的 端口。 静态路由配置^ 静态路由配置–网络拓扑图 大体思路：1.配PC2.配路由接口3.配静态路径 12345678910111213141516171819R2：syssys R2un in enint g0/0/0ip a 192.168.1.254 24int g0/0/1ip address 23.1.1.2 24ip route-static 192.168.2.0 24 g0/0/1 23.1.1.3 R3：syssys R3un in enint g0/0/0ip a 192.168.2.254 24int g0/0/1ip a 23.1.1.3 24ip route-static 192.168.1.0 24 g0/0/1 23.1.1.2 #ip route-static 目的网段 掩码 出接口 下一跳#[XX]dis ip routing-table #查看IP路由表 1、数据封装&#x2F;解封装定义 封装：应用层–&gt;物理层；数据–&gt;二进制数 解封装：物理层–&gt;应用层；二进制数–&gt;数据 2、OSI 模型 TCP&#x2F;IP 协议栈具体内容 OSI：应用层，表示层， 3、应用层作用，协议内容及端口号（5种以上）作用：产生数据； Http：超文本传输（TCP 80） Https：超文本传输安全（TCP 443） FTP：文件传输（TCP 20&#x2F;21） TFTP：简单文件传输（UDP 69） Pop3：邮局协议（TCP 110） Smtp：简单邮件传输（TCP 25） DNS：域名解析（TCP&#x2F;UDP 53） Dhcp：动态IP配置（UDP 67&#x2F;68） Telnet：远程登录（TCP 23） Ssh：安全远程登录（TCP 22） 4、网络层，传输层作用,包含协议及每种协议的作用 传输层：作用：数据分段–&gt;识别上层协议–&gt;根据数据需求封装传输层协议 协议：TCP，UDP 网络层：作用：数据包分片（防止数据过大 MTU-1500B）–&gt;路由寻址和寻路–&gt;实现不同网段通信 5、(TCP可靠性机制、应用UDP场景) TCP：三次握手—&gt;确认号确认机制—&gt;滑动窗口机制—&gt;四次挥手 UDP场景：延迟要求低，不在意数据泄露 6、网络层、传输层如何识别上层协议？ 网络层：协议号（Procotol）使用 tcp-6 &#x2F; udp-17 传输层：端口号：大小16bit；一共2^16&#x3D;65536种可能性，能取的0-65535； 7、园区网三层架构： 接入层，汇聚层，核心层 8.网络组成四要素： 12[R1]info-center enable 信息中心开启[R1]undo info-center enable 关闭信息中心开启 Tab：自动补齐 12[R1-GigabitEthernet0/0/0]dis this 查看当前接口下关系[R1]display ip interface brief 查看ip地址和接口简要关系 1display ip routing-table 查看ip路由表 127.0.0.0&#x2F;8 本地环回网段127.0.0.1 本地环回地址测试本地网卡连通性 Win+R 运行界面：cmd—打开黑窗口 route print 路由打印 关于ARP协议提升：PC封装数据—&gt;判断是否在同一网段：同：PC直接请求目的IP地址的MAC地址；不同：PC 请求本机所配置网关 IP 地址对应的MAC地址 路由器工作原理：1.解封装—解掉帧头帧尾–（路由器是三层设备需要看网络层信息）2.转发动作—路由器收到数据—根据目的IP查路由表转发（默认将路由器直连网段加入路由表）3.重新封装&#x2F;重写—-封装新的帧头、帧尾 *路由表的查看：Destination&#x2F;MaskProtoPreCostFlags NextHopInterfaceNextHop（下一跳） 通不通：1.看每台设备的路由表–大体看出来–默认加直连网段2.确定数据流 源IP地址— 静态路由：ip route-static 目的网段 掩码 出接口 下一跳ip route-static 目的网段 掩码 下一跳ip route-static 目的网段 掩码 出接口 OSPF 实验^要素：设备：PC1，PC2，R1，R2，R3 大体思路：1.配PC2.配路由接口3.进入OSPF界面，进程1 选择区域 net(连接)相连网段 R1：syssys R1un in enint g0&#x2F;0&#x2F;0ip a 192.168.1.254 24int g0&#x2F;0&#x2F;1ip a 12.1.1.1 24 ospfarea 0net 192.168.1.0 0.0.0.255net 12.1.1.0 0.0.0.255 R2:syssys R2un in enint g0&#x2F;0&#x2F;1ip a 12.1.1.2 24int g0&#x2F;0&#x2F;2ip a 23.1.1.2 24 ospfarea 0net 12.1.1.0 0.0.0.255 area 2net 23.1.1.0 0.0.0.255 R3:syssys R3un in enint g0&#x2F;0&#x2F;0ip a 192.168.2.254 24int g0&#x2F;0&#x2F;2ip a 23.1.1.3 24 ospfarea 2net 192.168.2.0 0.0.0.255net 23.1.1.0 0.0.0.255 检查：dis os pe br #查看OSPF邻居关系 1.交换机工作原理学习—&gt;泛洪(MAC表)—&gt;转发学习动作:学习源MAC与接口关系,放入MAC地址表中;泛洪动作:接收到广播帧&#x2F;未知单播帧时从每个端口(除接收端口外)发送转发动作:接收到单播帧时根据MAC地址表，从目的MAC对应端口转发 2.路由器工作原理解封装—&gt;转发(IP路由表)—&gt;重新封装解封装:解除帧头帧尾转发动作:根据目的IP查路由表转发重封装:封装新的帧头帧尾 3.ARP协议作用,工作原理,如何获取对端MAC地址根据IP地址寻找目的MAC地址; 发送数据前检查自己的arp缓存表(记录了IP与MAC地址对应关系)是否存在目的IP对应的MAC,有则作为目的MAC封装进数据帧中 PC封装数据—&gt;判断是否在同一网段：同：PC直接请求目的IP地址的MAC地址；不同：PC 请求本机所配置网关 IP 地址对应的MAC地址 4.TCP IP 协议栈中每层作用及协议应用层:HTTP ftp pop3 tftp telnet ssh 产生数据传输层:TCP UDP 数据分段,再根据需求封装传输层协议(端口号)网络层:ARP IP 包分片,路由寻址和选路数据链路层:以太网(以太Ⅱ,IEEE802.3) 广域网 封装链路层协议,识别上层协议 1.交换机工作原理学习动作 泛洪动作 转发动作 学习动作：学习MAC与接口关系放入MAC表泛洪动作：收到未知单播帧&#x2F;广播帧时从每一个端口发送出去转发动作：收到单播帧时根据目的MAC从对应端口转发出去 2.路由器工作原理解封装 转发动作 重新封装 解封装：解除帧头帧尾转发动作：根据目的IP查路由表转发重封装：重新封装新的帧头帧尾 3.ARP协议作用,工作原理,如何获取对端MAC地址作用：根据目的IP寻找目的MAC工作原理：发送数据时查看arp缓存表，若存在目的IP对应MAC则封装进数据帧中如何？：检查是否在同一网段：同：直接请求目的IP对应MAC；不同：请求网关IP对应MAC 4.TCP IP 协议栈中每层作用及协议应用层：产生数据：Http：TCP 80Https：TCP 443Ftp：TCP 20&#x2F;21Tftp：UDP 69Pop3：TCP 110Telnet：TCP 23Ssh：TCP 22 传输层：数据分段–根据数据需求封装传输层协议（端口号-识别应用层协议）TCPUDP 网络层：数据包分片–路由寻址和选路–实现不同网段通信 (协议号-识别传输层协议：TCP-6 UDP-17_)IPARP 数据链路层：封装帧头帧尾（包括数据链路层协议）–实现同网段通信 （识别上层协议）以太网协议（以太网Ⅱ帧、IEEE802.3帧）广域网协议 物理层：数据帧转换为二进制数 浮动静态路由^R1：syssys R1un in enint g0&#x2F;0&#x2F;0ip a 192.168.1.254 24int g0&#x2F;0&#x2F;1ip a 12.1.1.1 24int e0&#x2F;0&#x2F;1ip a 23.1.1.2 24 ip route-static 192.168.2.1 24 g0&#x2F;0&#x2F;1 12.1.1.2 preference 50ip route-static 192.168.2.1 24 e0&#x2F;0&#x2F;1 12.1.1.2 R2:syssys R2un in enint g0&#x2F;0&#x2F;1ip a 12.1.1.2 24int g0&#x2F;0&#x2F;2ip a 192.168.2.254 24int e0&#x2F;0&#x2F;1ip a 23.1.1.3 24 ip route-static 192.168.1.1 24 g0&#x2F;0&#x2F;1 12.1.1.1 preference 50ip route-static 192.168.1.1 24 e0&#x2F;0&#x2F;1 12.1.1.1 #ip route-static 目的IP 掩码 出接口 下一跳 优先级 50（静态默认60，优先级越小越优先） 只跟下一跳问题：存在迭代查询现象：到达目的网段需要查多次路由表查询速度慢，可能丢包 只跟出接口：默认不可通信（点到点环境除外）如何互通？开启arp代理：当某个接口开启arp代理功能后，代理目的IP地址回复MAC地址 前提：该接口可以与目的IP地址能互通 dis arp all 查看ARP缓存表 [R2]int g0&#x2F;0&#x2F;1[R2-GigabitEthernet0&#x2F;0&#x2F;1]arp-proxy enable 开启arp代理 默认路由&#x2F;缺省路由：目的网段为0.0.0.0&#x2F;0的路由 代表所有网段注意事项：切记不要互指下一跳为对方Tracert 路径跟踪 路由表比较规则：1.掩码长度，越长（精确）越优先2.Pre 优先级：越小越优先 直连-0 OSPF(内部)-10 isisp-15 静态-60 rip-100 OSPF(外部)-150 bgp-2553.Cost 度量：开销，跳数 越小越优先 等价路由：目的网段，掩码，优先级相同的多条路由、 [R1]ip route-static 192.168.2.0 24 g0&#x2F;0&#x2F;1 12.1.1.2 preference 50 修改优先级 静态路由不足之处：不适用于中大型网络；灵活性差 RIP:路由信息协议OSPF:开放式最短路径优先ISIS:中间系统-中间系统BGP:边界网关协议 按照协议特性：1.距离矢量路由协议 只关心距离和方向，传递的是路由（BGP，RIP）2.链路状态路由协议 传递链路状态信息，形成相同的数据库（地图） OSPF—LSA（链路状态通告） ISIS—–LSP（链路状态PDU（协议数据单元）） 按照运行范围（AS：自治区域系统）AS：运行相同路由协议路由器的集合ASBR：AS边界路由器（处于多个AS之间的路由器）IGP（内部网关协议）-运行在AS内的路由协议 - RIP\\OSPF\\ISISEGP（外部网关协议）-运行在AS间的路由协议 - BGP OSPF：开放式最短路径优先 定位：动态路由协议；链路状态：传递链路状态信息；IGP工作原理：1、发送Hello建立邻居关系2、进行LSA（链路状态通告）的泛洪，形成相同LSDB（链路状态数据库）3、运行SPF（最短路径优先）算法，得出最优路由 问题：随着路由器、链路数量的增多，LSDB随着增大、路由表增大，查表速度降低，转发效率降低如何解决：划分区域（area）区域分类：骨干区域：area 0； 非骨干区域：area 1；区域部署原则：非骨干区域之间通信，必须与骨干区域相连区域划分；基于接口划分；区域边界路由器：ABR（至少有一个区域是骨干区域） OSPF 配置：1.进入OSPF进程（进程号默认是1）2.进入路由器所属区域3.宣告区域内的直连网段（反掩码） [R1]ospf[R1-ospf-1]area 0[R1]display ospf peer brief 查看OSPF对端简要信息 Router ID：路由器标识：手工配置优先：[R1]ospf 1（进程号） router-id 1.1.1.1（标识名）默认第一个在路由器配置的IP地址为路由器router idYou need to restart the OSPF process to validate the new router ID.如果之前存在router id，修改后需要重置OSPF进程reset ospf processWarning: The OSPF process will be reset. Continue? [Y&#x2F;N]:y邻居状态—Full 收敛完成状态 OSPF 优先级：10OSPF 度量值：开销ospf接口开销cost &#x3D; 带宽参考值（100Mb&#x2F;s） &#x2F;接口带宽；不足1取1 【GE口千兆 E口百兆】ospf路由总开销 &#x3D; 路由器到达目的网段，出方向接口开销之和 如何修改接口cost？1、修改带宽参考值[R3-ospf-1]bandwidth-reference ?INTEGER&lt;1-2147483648&gt; The reference bandwidth (Mbits&#x2F;s)[R3-ospf-1]bandwidth-reference 100002、直接修改接口cost[R3]int g0&#x2F;0&#x2F;0[R3-GigabitEthernet0&#x2F;0&#x2F;0]ospf ? #&lt;65535&gt;[R3-GigabitEthernet0&#x2F;0&#x2F;0]ospf cost 5 OSPF 与优先级R1：syssys R1un in enint g0&#x2F;0&#x2F;0ip a 12.1.1.1 24int g0&#x2F;0&#x2F;1ip a 192.168.1.254 24qos 1 ro 1.1.1.1area 1net 192.168.1.0 0.0.0.255net 12.1.1.0 0.0.0.255 R2:syssys R2un in enint g0&#x2F;0&#x2F;0ip a 12.1.1.2 24int g0&#x2F;0&#x2F;1ip a 23.1.1.2 24qos 1 ro 2.2.2.2ar 1net 12.1.1.0 0.0.0.255 ar 0net 23.1.1.0 0.0.0.255 int g0&#x2F;0&#x2F;1ospf cost 6 R3:syssys R3un in enint g0&#x2F;0&#x2F;1ip a 23.1.1.3 24int g0&#x2F;0&#x2F;2ip a 34.1.1.3 24qos 1 ro 3.3.3.3ar 0net 23.1.1.0 0.0.0.255net 34.1.1.0 0.0.0.255 R4:syssys R4un in enint g0&#x2F;0&#x2F;2ip a 34.1.1.4 24int g0&#x2F;0&#x2F;3ip a 45.1.1.4 24int g0&#x2F;0&#x2F;0ip a 47.1.1.4 24qos 1 ro 4.4.4.4ar 0net 34.1.1.0 0.0.0.255 ip route-static 200.1.1.0 24 g0&#x2F;0&#x2F;3 45.1.1.5 preference 50ip route-static 200.1.1.0 24 g0&#x2F;0&#x2F;0 47.1.1.7 ospfdefault-route-advertise always R5:syssys R5un in enint g0&#x2F;0&#x2F;3ip a 45.1.1.5 24int g0&#x2F;0&#x2F;0ip a 56.1.1.5 24qos 100 ro 5.5.5.5ar 0net 56.1.1.0 0.0.0.255 ip route-static 192.168.1.0 24 g0&#x2F;0&#x2F;3 45.1.1.4 R7:syssys R7un in enint g0&#x2F;0&#x2F;0ip a 47.1.1.7 24int g0&#x2F;0&#x2F;1ip a 67.1.1.7 24qos 100 ro 7.7.7.7ar 0net 67.1.1.0 0.0.0.255 ip route-static 192.168.1.0 24 g0&#x2F;0&#x2F;0 47.1.1.4 R6:syssys R6un in enint g0&#x2F;0&#x2F;0ip a 56.1.1.6 24int g0&#x2F;0&#x2F;1ip a 67.1.1.6 24int g0&#x2F;0&#x2F;2ip a 200.1.1.254 24qos 100 ro 6.6.6.6ar 0net 56.1.1.0 0.0.0.255net 67.1.1.0 0.0.0.255net 200.1.1.0 0.0.0.255 ip route-static 192.168.1.0 24 g0&#x2F;0&#x2F;0 56.1.1.5 preference 40ip route-static 192.168.1.0 24 g0&#x2F;0&#x2F;1 67.1.1.7 OSPF原理：1.发送Hello报文 建立邻居关系2.进行LSA泛洪，同步LSDB数据库3.运行SPF算法，得出最优路由 静态配置中只跟下一跳问题：迭代查询现象：到达目的网段需查多次路由表，查速慢，可能丢包；只跟出接口问题：默认不可通信（点到点除外） 如何互通：开启ARP代理：某接口开启ARP代理后，代理目的IP地址回复MAC地址（前提是该接口可以与目的IP地址互通） 路由表比较规则1、掩码长度 越长越优先2、优先级 越小越优先3、度量：开销 跳数 越小越优先 OSPF配置：1.进入OSPF进程2.进入路由所属区域3.宣告直连网段 动态路由分类：协议 运行范围 距离矢量 RIP BGP链路状态 OSPF ISIS 内部网关 IGP RIP OSPF ISIS外部网关 EGP BGP OSPF 报文实验^OSPF 报文消息(Open Shortest Path First)Hello 建立、维护邻居关系DBD&#x2F;DD报文：数据库描述报文 描述本地链路状态数据库信息（LSA摘要）LSR：链路状态请求报文 请求所缺少的LSA的详细信息LSU：链路状态更新报文 更新所请求LSA的详细信息LSACK：链路状态确认报文 确认接收到的LSA R1：syssys R1un in enos 1 ro 1.1.1.1ar 0int g0&#x2F;0&#x2F;0ip a 12.1.1.1 24os en 1 ar 0 R2:syssys R2un in enint g0&#x2F;0&#x2F;0ip a 12.1.1.2 24qos 1 ro 2.2.2.2ar 0net 12.1.1.2 0.0.0.0 两个验证第一个验证：R1：syssys R1un in enint g0&#x2F;0&#x2F;0ip a 1.1.1.1 24qos 1 ro 1.1.1.1ar 0net 1.1.1.1 0.0.0.0 qqint g0&#x2F;0&#x2F;0os au md 1 pl hcie R2:syssys R2un in enint g0&#x2F;0&#x2F;0ip a 1.1.1.2 24qos 1 ro 2.2.2.2ar 0net 1.1.1.2 0.0.0.0 au md 1 pl hcie ospf reset process 结果：验证一是通的 第二个验证： R1：syssys R1un in enint g0&#x2F;0&#x2F;0ip a 1.1.1.1 24qos 1 ro 1.1.1.1ar 0net 1.1.1.1 0.0.0.0 au md 1 pl huawei qqint g0&#x2F;0&#x2F;0os au simple pl bossay R2:syssys R2un in enint g0&#x2F;0&#x2F;0ip a 1.1.1.2 24qos 1 ro 2.2.2.2ar 0net 1.1.1.2 0.0.0.0 au m 1 p huawei qqint g0&#x2F;0&#x2F;0os au s p bossay OSPF HeaderAuth Type: Simple password (1)Auth Data (Simple): bossay 结果：接口认证优先于区域认证原因：OSPF区域基于接口划分 loopback接口：环回接口 可以配置IP地址—模拟网段 [R3]int loopback ?&lt;0-1023&gt; LoopBack interface number[R3]int loopback 0[R3-LoopBack0]ip address 3.3.3.3 32 在广播型多路访问环境下，LSA泛洪过多，占用大量带宽资源如何解决：选举DR（指定路由器） 路由器都向DR进行LSA泛洪,由DR将LSA向其他路由器泛洪其他路由器之间，不在进行LSA泛洪 为了保证DR可靠，选举出BDR（备份DR）非DR&#x2F;BDR的路由—DRother DR&#x2F;BDR选举规则（可能的多路访问环境必定选BR&#x2F;BDR：40s：先选两个BDR，再升一个为DR）：1、先比较路由器优先级(默认值1)，越大越优先 【优先级0–不参与DR&#x2F;BDR选举】2、router id 越大越优先 DR:123.1.1.4 BDR: 123.1.1.2 MTU: 0 [R1-GigabitEthernet0&#x2F;0&#x2F;0]ospf dr-priority ? INTEGER&lt;0-255&gt; Router priority value[R1-GigabitEthernet0&#x2F;0&#x2F;0]ospf dr-priority 100 DR&#x2F;BDR抢占规则：DR具有不可抢占性 DR&#x2F;BDR&#x2F;DRother关系：邻居关系(DRother-DRother)：hello-建立&#x2F;维护邻居关系邻接关系(DR&#x2F;BDR-DRother)(DR&#x2F;BDR)：hello-建立&#x2F;维护邻居关系 + 进行LSA泛洪 [R1]ospf 1 router-id 1.1.1.1[R1-ospf-1]area 0[R1]int g0&#x2F;0&#x2F;0[R1-GigabitEthernet0&#x2F;0&#x2F;0]ip address 12.1.1.1 24[R1-GigabitEthernet0&#x2F;0&#x2F;0]ospf enable 1 area 0 *[R2]ospf 1 router-id 2.2.2.2[R2-ospf-1]area 0[R2-ospf-1-area-0.0.0.0]network 12.1.1.2 0.0.0.0 宣告地址 display ospf peer brief OSPF Process 1 with Router ID 1.1.1.1 Peer Statistic Information display ospf peer OSPF Process 1 with Router ID 1.1.1.1 NeighborsArea 0.0.0.0 interface 12.1.1.1(GigabitEthernet0&#x2F;0&#x2F;0) ‘s neighborsRouter ID: 2.2.2.2 Address: 12.1.1.2State: Full Mode:Nbr is Master Priority:100DR: 12.1.1.2 BDR: 12.1.1.1 MTU: 0……………… OSPF 报文消息(Open Shortest Path First)Hello 建立、维护邻居关系DBD&#x2F;DD报文：数据库描述报文 描述本地链路状态数据库信息（LSA摘要）LSR：链路状态请求报文 请求所缺少的LSA的详细信息LSU：链路状态更新报文 更新所请求LSA的详细信息LSACK：链路状态确认报文 确认接收到的LSA reset ospf processWarning: The OSPF process will be reset. Continue? [Y&#x2F;N]:y 抓包：OSPF基于IP封装，协议号89 更新：采用组播更新，更新地址：224.0.0.5、224.0.0.6 IP规划:A: 0.0.0.0-127.255.255.255B: 128.0.0.0- 191.255.255.255C: 192.0.0.0223.255.255.255 可以在主机上配置的地址D: 224.0.0.0-239.255.255.255 组播地址E: 240.0.0.0- 255.255.255.255 保留地址&#x2F;实验地址 OSPF Header (ospf头部字段）Version: 2 版本号：2，主要用于IPV4路由获取Message Type: Hello Packet (1) 消息类型(什么报文)：Hello报文(代号为1)Packet Length: 48 数据包长度：48bitSource OSPF Router: 1.1.1.1 源Router ID字段：1.1.1.1 【Router ID 必须唯一】Area ID: 0.0.0.0 区域号：0（骨干区域）Checksum: 0xdc8f 校验和Auth Type: Null (0) 认证类型：无Auth Data (none): 0000000000000000 认证数据 OSPF Hello Packet （OSPF Hello 报文 — 建立并维护邻居关系）Network Mask: 255.255.255.0 网络掩码Hello Interval [sec]: 10 Hello间隔：10s （心跳更新间隔）Options: 0x02 选项字段Router Priority: 1 路由器优先级（用于选举DR和BDR）Router Dead Interval [sec]: 40 路由器失效时间：40s （心跳失效时间）Designated Router: 12.1.1.2 指定路由器（DR)Backup Designated Router: 12.1.1.1 备份指定路由器（BDR）Active Neighbor: 2.2.2.2 活跃的邻居 Hello 报文成立条件：1、Router ID 必须唯一2、区域ID 必须相同3、认证类型、认证数据 必须相同4、网络掩码必须相同5、hello timer，dead timer 必须相同6、选项字段必须相同 认证方式：基于区域的认证：区域内所有路由器配置基于接口的认证 认证类型：不认证、明文认证、MD5密文认证 认证数据：认证密码 接口的认证:[R1-GigabitEthernet0&#x2F;0&#x2F;0]ospf authentication-mode ?[R1-GigabitEthernet0&#x2F;0&#x2F;0]ospf authentication-mode md5 ? INTEGER&lt;1-255&gt; Key ID [R1-GigabitEthernet0&#x2F;0&#x2F;0]ospf authentication-mode md5 1 ? STRING&lt;1-255&gt;&#x2F;&lt;20-392&gt; The password (key) cipher Encryption type (Cryptogram) plain Encryption type (Plain text)[R1-GigabitEthernet0&#x2F;0&#x2F;0]ospf authentication-mode md5 1 cipher huawei [R1-GigabitEthernet0&#x2F;0&#x2F;0]undo ospf authentication-mode 区域的认证:[R1-ospf-1-area-0.0.0.0]authentication-mode md5 1 cipher bossay 手工修改Hello时间和死亡时间：[R1-GigabitEthernet0&#x2F;0&#x2F;0]ospf timer hello 5[R1-GigabitEthernet0&#x2F;0&#x2F;0]ospf timer dead 10 undo ospf timer hello 邻居关系建立标志：收到hello报文中，发现本路由器的router id（活跃的邻居字段中） 邻居状态机制（OSPF邻居状态机）Down 开启OSPF但无报文交互Init 收到的Hello中，没有发现自己的router id\t2Way 收到的hello中，发现自己的router id（邻居关系建立标志）Exstart 进行主从关系的选举，保证DBD报文可靠Exchange 进行DBD报文的交互Loading 进行LSR&#x2F;LSU&#x2F;LSACK报文的交互Full 运行SPF算法，得出最优路由（邻接关系建立标志） Interface MTU: 0 接口MTUOptions: 0x02 选项字段DB Description：0x07\tDBD描述字段{…. .1.. &#x3D; (I) Init: Set 是否为第一个DBD报文（1是第一个； 0不是第一个）…. ..1. &#x3D; (M) More: Set 更多位 后续是否还有DBD报文（1：是；0：否）…. …1 &#x3D; (MS) Master: Yes 主从位（1：主 ；0：从0）}DD Sequence: 277 DBD序列号（DBD报文） 何时一直卡在2way：当两台路由器都为DRother路由器 为什么要保证DBD可靠？1、OSPF由IP封装，IP无可靠性机制；2、Hello 周期性 无需保障3、LLL相互保证可靠4、因此 Exstract 选举主从保证DBD可靠 如何保证DBD可靠？1.互发空DBD报文选举主从(router id越大越优先)2.从照主序列号发送含LSA摘要的DBD报文；主序列号+1回复；3.从比主多一个DBD报文,目的保证主最后一个DBD报文的可靠 什么时候会卡在Exchange？？？？包交换有问题，发出DBD后没有收到LSACK MTU：最大传输单元 1500B在OSPF协议中默认MTU不进行协商，也可开启MTU协商[R1]int g0&#x2F;0&#x2F;0[R1-GigabitEthernet0&#x2F;0&#x2F;0] ospf mtu-enable 1.OSPF 工作原理发送Hello报文，建立邻居关系进行LSA泛洪，形成相同LSDB运行SPF算法，得出最优路由 2.Ospf 更新方式基于IP封装，协议号89组播，更新地址224.0.0.5，224.0.0.6 3.OSPF五种报文消息Hello\t建立并维护邻居关系DBD 发送数据库概要LSR 数据库补全请求LSU 数据库更新信息LSACK\t确认补全数据库 4.OSPF划分区域原因，部署原则LSDB随链路增多而增大，路由表增大，查表转发速率降低原则：非骨干区域间通信需与骨干区域相连 5.OSPF选举DR&#x2F;BDR的原因，如何选举防止LSA泛洪过多占用带宽选举：先比较路由器优先级，在比较router id优先级（均越大越优先） 6.OSPF什么是邻居关系、什么是邻接关系邻居：DRother之间，只建立维护邻居关系邻接：DR&#x2F;BDR-DRother以及DR-BDR之间，建立维护邻居关系并LSA泛洪 7.OSPF邻居关系建立的条件，标志条件：router id 唯一区域 相同认证类型和认证数据 相同网络掩码 相同hello timer，dead timer 相同选项字段 相同 标志：收到的Hello中发现自己的router id（2-Way） 8.OSPF 状态机分别作用Down 开OSPF，无交互Init hello 无 router id2-Way hello 有 router idExstart 选主从，保DBD可靠Exchange DBD交互Loading LSR\\LSU\\LSACT交互Full 运行SPF算法，得出最优路由 9.如何保证DBD可靠？互发空DBD，根据router id大选主从从照主序列号发送含LSA摘要DBD，主序列号+1回复；从比主多一报文以保证主最后一DBD可靠 10.何时卡2-Wayospf dr pri 0 接口优先级改为0 不参与DR&#x2F;BDR选举dis ospf pe br 看看在哪个状态机 reset ospf process 重置OSPF进程11.何时卡Exstart（State： ExStart）int g0&#x2F;0&#x2F;0ospf mtu-enablemtu 1400 VLAN间路由练习^R3：syssys R3un in en int g0&#x2F;0&#x2F;0ip a 192.168.3.254 24int g0&#x2F;0&#x2F;1ip a 23.1.1.3 24q v b 10 20 40 LSW2:syssys SW2un in en v b 10 20 40 int v 10ip a 192.168.1.254 24int v 20ip a 192.168.2.254 24int v 40ip a 23.1.1.2 24 int g0&#x2F;0&#x2F;1port link-type trunkpo tr a v 10 20 40po tr pvid vl 40 [SW2]interface Vlanif 10[SW2-Vlanif10]ip address 192.168.1.254 24[SW2]interface Vlanif 20[SW2-Vlanif10]ip address192.168.2.254 24 [SW1]int g0&#x2F;0&#x2F;5[SW1-GigabitEthernet0&#x2F;0&#x2F;5]port link-type trunk[SW1-GigabitEthernet0&#x2F;0&#x2F;5]port trunk allow-pass vlan 10 20[SW1-GigabitEthernet0&#x2F;0&#x2F;5]port trunk pvid vlan 100 [SW1]vlan batch 20 30 display vlandisplay port vlan 二层技术： VLAN：虚拟局域网为什么要有VLAN？交换机工作原理：学习，泛洪，转发广播域：能收到广播消息的范围&#x2F;区域交换机默认所有接口都在同一个广播域广播域大–占用带宽资源，安全性低；VLAN作用：隔离广播域如何实现隔离？交换机为数据打上Tag，利用Tag区分不同VLAN 不带tag数据（untagged）帧头(DMAC&lt;–SMAC type)|ip(SIP–&gt;DIP)|tcp&#x2F;udp|data|帧尾 携带tag数据（tagged）帧头(DMAC&lt;–SMAC|tag(4bytes)|type)|ip(SIP–&gt;DIP)|tcp&#x2F;udp|data|帧尾 Tag&#x3D;4B1.Type 类型 0X8100-802.1Q标准—-vlan2.PRI 优先级 用于QOS (服务质量)3.CFI MAC地址是否支持经典格式4.VID(12bits 2^12&#x3D;4096vlan 范围：0-4095 能用的：1-4094) VLAN标识 VLAN 对于tag不同处理动作–端口处理类型Access：接入链路：只允许一个vlan通过 交换机–终端设备Trunk： 干道链路：允许多个vlan通过 交换机–交换机Hybrid：混合链路：手工定义允许通过的vlan及vlan通过时的动作\t默认类型 VLAN配置：创建单个vlan：[SW1]vlan 10 –&gt; [SW1-vlan10]描述备注vlan：[SW1-vlan10]description HR创建多个vlan：[SW1]vlan batch 20 30创建连续vlan：[SW1]vlan batch 40 to 100查看vlan：[sw1]display vlan查看端口和vlan关系：display port vlan Access配置：1. 进入接口 2. 端口链路类型-access 3. 端口所属的vlan[SW1]int g0&#x2F;0&#x2F;1[SW1-GigabitEthernet0&#x2F;0&#x2F;1]port link-type access[SW1-GigabitEthernet0&#x2F;0&#x2F;1]port default vlan 10 Trunk配置：1. 进入接口 2. 端口链路类型-trunk 3. trunk端口允许通过的vlan[SW1]int g0&#x2F;0&#x2F;5[SW1-GigabitEthernet0&#x2F;0&#x2F;5]port link-type trunk[SW1-GigabitEthernet0&#x2F;0&#x2F;5]port trunk allow-pass vlan 10 20*[SW1-GigabitEthernet0&#x2F;0&#x2F;5]undo port trunk allow-pass vlan 1 删除vlan1[SW1-GigabitEthernet0&#x2F;0&#x2F;5]port trunk pvid vlan 100 修改trunk接口pvid 删除命令 倒着删看到回车 Hybrid配置：tagged：携带标记untagged：不携带标记[SW1]int g0&#x2F;0&#x2F;6[SW1-GigabitEthernet0&#x2F;0&#x2F;6]port link-type hybrid[SW1-GigabitEthernet0&#x2F;0&#x2F;6]port hybrid untagged vlan 30[SW1-GigabitEthernet0&#x2F;0&#x2F;6]port hybrid pvid vlan 30 Tag的处理：允许列表下，不带标记打标记，相同标记去标转发，不同标记A丢T转{Access：（不带标记打标记，相同标记去标转发，不同标记直接丢弃）入：不带标记，打上PVID出：PVID比较，同就去标记转发，不同就丢弃Trunk：出：允许列表下，不同标记直接转发，相同标记去标转发入：允许列表下，不带标记打标记，带着标记直接转发Hybrid：出：允许列表下，手工定义允许通过的vlan及通过时动作入：在满足允许列表前提下，收到数据带标记，直接转发；收到数据不带标记，打上该接口的pvid的标记} 三层交换机&#x3D;路由器(IP+静态+动态) +二层交换机(vlan stp)集合 三层交换机物理接口无法配置IP地址（交换机接口默认二层接口）如何在交换机上配置IP地址?1、将二层接口转换为三层接口[SW2]int g0&#x2F;0&#x2F;5[SW2-GigabitEthernet0&#x2F;0&#x2F;5]undo portswitch 删除端口交换功能2、在交换机上配置vlan虚拟接口 vlanif[SW2]interface Vlanif 10[SW2-Vlanif10]ip address 192.168.1.254 24[SW2]interface Vlanif 20[SW2-Vlanif10]ip address192.168.2.254 24 交换机出来的数据一定带标记，路由器不带（1）全程带标记 trunk（2）出来去标记，进入打标记 access hybrid 配置实验:配置思路 先二层（聚合 vlan stp）再三层（vlan if 静态 OSPF)每配置完一个技术——-验证是否正确Vlan：dis port vlan dis vlanVlanif ip地址：dis ip int brief配置完毕两端IP地址测试直连连通性：ping 对端地址静态：dis ip roOspf：dis ospf pe br (full状态) dis ip ro 将静态路由引入到ospf中，参考命令如下：[R3]ospf 1[R3-ospf-1]import-route staticospf 外部路由 150 单臂路由：Dot1q&#x3D;802.1q 0x8100k [R6]int g0&#x2F;0&#x2F;0.1 开启子接口[R6-GigabitEthernet0&#x2F;0&#x2F;0.1]ip address 192.168.5.254 24 接口IP[R6-GigabitEthernet0&#x2F;0&#x2F;0.1]dot1q termination vid 50 允许通过的vlan[R6-GigabitEthernet0&#x2F;0&#x2F;0.1]arp broadcast enable 子接口默认广播功能没开 链路聚合：产生背景：为了提升网络可靠性，增大带宽单板可靠—多冗余设备可靠—双冗余链路可靠—多链路 STP：生成树协议阻塞端口如何在保证可靠前提下，提升带宽，减少丢包定义：将多条物理链路聚合成一条聚合链路（eth-trunk） 模式：手工链路聚合模式：聚合链路中的所有链路都参数据的转发1、创建聚合接口2、将物理接口加入聚合接口 SW1：syssys SW1 un in en int Eth-Trunk 1qint g0&#x2F;0&#x2F;1eth-trunk 1qint g0&#x2F;0&#x2F;2eth-trunk 1qint g0&#x2F;0&#x2F;3eth-trunk 1或者int Eth-Trunk 1trunkport g0&#x2F;0&#x2F;1trunkport g0&#x2F;0&#x2F;2trunkport g0&#x2F;0&#x2F;3或者int Eth-Trunk 1 trunkport g 0&#x2F;0&#x2F;1 to 0&#x2F;0&#x2F;3 dis eth-trunk 1 查看聚合接口1 LACP链路聚合模式：存在备份链路: M:N备份 M-活跃链路 N-非活跃链路LACP：链路聚合控制协议设备之间发送LACPDU：链路聚合控制协议数据单元 要素：LACPDU:设备系统优先级MАC接口优先级接口编号 如何选举活跃链路：在两台交换机之间选举出主动端先比LACP系统优先级（32768），越小越优先再比MAC：越小越优先 在主动端设备上选举活跃链路：先比LACP接口优先级（32768），越小越优先再比接口编号：越小越优先 SW3：syssys SW3un in enint eth-trunk 2 创建聚合接口mode lacp-static 改为LACP模式max active-linknumber 3 配置最大活跃链路数量lacp preempt enable （默认抢占关闭）开启抢占lacp preempt delay 10 配置抢占延迟(s)trunkport g 0&#x2F;0&#x2F;1 to 0&#x2F;0&#x2F;4 将物理接口加入聚合接口 lacp priority 4000 修改lacp系统优先级 int g0&#x2F;0&#x2F;2lacp priority 40000 修改LACP接口优先级 qdis eth-trunk 2 SW4:syssys SW4un in enint eth 2mode lacp-staticmax active- 3lacp preempt enable&#x2F;&#x2F;lacp pr enla pr de 10tr g 0&#x2F;0&#x2F;1 to 0&#x2F;0&#x2F;4 int g0&#x2F;0&#x2F;2lacp priority 40000 STP：生成树协议（在保证可靠的前提下，解决环路问题）产生原因：二层环境为了保证可靠性，采用双冗余设备环形连接方式—环路问题 问题：广播风暴—&gt;设备宕机 MAC地址表震荡—-&gt;数据转发丢包 原理：阻塞端口-拓扑稳定时，阻塞端口处于阻塞状态，当链路出现故障时，阻塞端口自动开启，开始转发数据。 应用场景：二层交换网络—交换机默认运行STP STP模式：STP：生成树协议RSTP：快速生成树协议MSTP：多实例生成树协议 [SW2]display stp 查看STP（默认MSTP模式）[SW3]display stp brief 查看STP简要信息[sw2]stp mode stp 修改为stp模式[sw2]display int g0&#x2F;0&#x2F;2 查看端口 STP 工作原理—阻塞端口如何选出来的？ 根-选举根交换机（根桥）—–网桥ID：定义：运行STP协议的交换机唯一标识组成：网桥优先级（默认32768，4096倍数，越小越优先）+MAC地址比较网桥ID：(先比较优先级、在比较mac地址，越小越优先) [SW2]stp priority 4096 修改优先级 干：根端口定义：非根交换机到达根交换机最优的端口比较规则:1、根路径开销 802.1t 10M&#x3D;2000000 100M&#x3D;200000 1000M&#x3D;20000 10GM&#x3D;2000 链路聚合简要介绍：背景：设备之间存在多条链路时，由于STP（生成树）的存在，实际只会有一条链路转发流量，设备间链路带宽无法得到提升。用途：不进行硬件升级的前提下增加链路带宽 链路聚合基本术语&#x2F;概念：• 聚合组（Link Aggregation Group，LAG）：若干条链路捆绑在一起所形成的的逻辑链路。每个聚合组唯一对应着一个逻辑接口，这个逻辑接口又被称为链路聚合接口或Eth-Trunk接口。• 成员接口和成员链路：组成Eth-Trunk接口的各个物理接口称为成员接口。成员接口对应的链路称为成员链路。• 活动接口和活动链路：活动接口又叫选中（Selected）接口，是参与数据转发的成员接口。活动接口对应的链路被称为活动链路（Active link）• 非活动接口和非活动链路：又叫非选中（Unselected）接口，是不参与转发数据的成员接口。非活动接口对应的链路被称为非活动链路（Inactive link）。• 聚合模式 ：根据是否开启LACP（Link Aggregation Control Protocol，链路聚合控制协议），链路聚合可以分为手工模式和LACP模式。• 其他概念：活动接口上限阈值和活动接口下限阈值。 链路聚合（手工和lacp） SW1:sys 进入管理模式sys SW1 命名（SW1）un in en 取消信息中心提醒 int e 1 创建聚合接口，编号为1t g 0&#x2F;0&#x2F;1 to 0&#x2F;0&#x2F;4\t将物理接口g0&#x2F;0&#x2F;1到0&#x2F;0&#x2F;4加入聚合接口 qdis eth 1 查看聚合接口1 SW2:syssys SW2un in en int e 1t g 0&#x2F;0&#x2F;1 to 0&#x2F;0&#x2F;4 qdis eth 1 SW3:sys sys SW3un in en int e 2 创建聚合接口，编号为2mo la 将此聚合接口改为LACP模式m ac 3 配置最大活跃链路数量：3la pr en (默认关闭)开启LACP抢占模式lacp pr de 10 配置抢占延迟(s) t g 0&#x2F;0&#x2F;1 to 0&#x2F;0&#x2F;4\t将物理接口加入聚合接口 lacp pri 4000 修改lacp优先级（抢占主动端） int g0&#x2F;0&#x2F;2 进入 GE0&#x2F;0&#x2F;2 接口lacp pri 40000 修改LACP接口优先级(默认32768，改大使其变为备用链路) qdis eth 2 查看聚合接口 2 SW4:syssys SW4un in en int e 2mo lam ac 3lacp pr enlacp pr de 10 t g 0&#x2F;0&#x2F;1 to 0&#x2F;0&#x2F;4 int g0&#x2F;0&#x2F;2lacp pri 40000 qdis eth 2 STP1.环路问题导致的现象广播风暴—&gt;设备宕机MAC地址表震荡—-&gt;数据转发丢包 生成树协议（作用：在保证可靠的前提下，解决环路问题）原理：阻塞端口-拓扑稳定时，阻塞端口处于阻塞状态，当链路出现故障时，阻塞端口自动开启，开始转发数据。 STP模式：STP：生成树协议RSTP：快速生成树协议MSTP：多实例生成树协议 STP报文–BPDU（桥协议数据单元）Protocol Identifier: Spanning Tree Protocol (0x0000) 协议标识符:生成树协议Protocol Version Identifier: Spanning Tree (0) 协议版本标识符:生成树(0)BPDU Type: Configuration (0x00) BPDU类型：Confiquration 配置BPDU：进行STP角色计算、维护拓扑；（1：请求知道啦！0：相安无事） TCN BPDU(拓扑变化 BPDU)：通告拓扑变化（1：拓扑变化啦！0：相安无事）BPDU flags: 0x00 BPDU标志 0… …&#x3D; Topology Change Acknowledgment: No TCA:拓扑变化确认 …0 &#x3D; Topology Change: No TC：拓扑变化（老化MAC地址，学习新MAC地址，阻塞端口进入转发状态）（1：可以老化MAC地址啦！0：相安无事）Root Identifier: 4096 &#x2F;0&#x2F; 4c:1f:cc:b9:3f:59 根标识符（根网桥ID）Root Path Cost: 0 根路径开销Bridge Identifier: 4096 &#x2F;0&#x2F; 4c:1f:cc:b9:3f:59 本交换机网桥IDPort identifier: 0x8002 端口标ID:0x8002 Message Age: 0 消息寿命（BPTU存放时间，最多20秒）Max Age: 20 最大寿命Hello Time: 2 发送间隔Forward Delay: 15 发送延迟 STP：（越小越优先）根：根据网桥ID：先看网桥优先级，再看MAC地址优先级根端口：非根交换机到达根交换机最优的端口：1、根路径开销 （802.1t）2、对端交换机的网桥ID3、对端端口ID\t端口优先级+端口编号\t默认128 16倍数4、本端端口ID 端口优先级+端口编号指定端口 ：每一条链路到达根交换机最优的端口1、根路径开销2、两端交换机的网桥ID3、本端端口ID 5种STP端口状态：禁用(Disable)：该接口不能收发BPDU,也不能收发业务数据帧,例如接口为down阻塞(Blocking)：该接口被STP阻塞。处于阻塞状态的接口不能发送BPDU,但是会持续侦听BPDU,而且不能收发业务数据帧,也不会进行MAC地址学习侦听（Listening)：当接口处于该状态时,表明STP初步认定该接口为根接口或指定接口,但接口依然处于STP计算的过程中,此时接口可以收发BPDU,但是不能收发业务数据帧,也不会进行MAC地址学习学习（Learning）：当接口处于该状态时，会侦听业务数据帧（但是不能转发业务数据帧),并且在收到业务数据帧后进行MAC地址学习转发(Forwarding)：处于该状态的接口可以正常地收发业务数据帧,也会进行BPDU处理。接口的角色需是根接口或指定接口才能进入转发状态 6.STP故障恢复时间直接30s，间接50s. MSTP练习^syssys SW2un in en stp mo msst rere HWrev 1ins 1 vlan 10ins 2 vlan 20ac restp ins 1 ro prstp ins 2 ro se syssys SW3un in en stp mo msst rere HWrev 1ins 1 vlan 10ins 2 vlan 20ac restp ins 2 ro prstp ins 1 ro se syssys SW1un in en int g0&#x2F;0&#x2F;1p l ap d v 10int g0&#x2F;0&#x2F;2p l ap d v 10int g0&#x2F;0&#x2F;3p l ap d v 20int g0&#x2F;0&#x2F;4p l ap d v 20 MSTP练习^syssys SW1un in en v b 10 20 int g0&#x2F;0&#x2F;1p l ap d v 10int g0&#x2F;0&#x2F;2p l ap d v 10int g0&#x2F;0&#x2F;3p l ap d v 20int g0&#x2F;0&#x2F;4p l ap d v 20 int g0&#x2F;0&#x2F;5p l tp t a v 10 20int g0&#x2F;0&#x2F;7p l tp t a v 10 20 qstp mode mstpstp rere HWrev 1ins 1 v 10 30ins 2 v 20 40 ac re syssys SW2un in en v b 30 40 int g0&#x2F;0&#x2F;1p l ap d v 30int g0&#x2F;0&#x2F;2p l ap d v 30int g0&#x2F;0&#x2F;3p l ap d v 40int g0&#x2F;0&#x2F;4p l ap d v 40 int g0&#x2F;0&#x2F;5p l tp t a v 30 40int g0&#x2F;0&#x2F;7p l tp t a v 30 40 qstp mode mstpstp rere HWrev 1ins 1 v 10 30ins 2 v 20 40 ac re syssys SW3un in en v b 3 4 10 20 30 40 int g0&#x2F;0&#x2F;5p l tp t a v 10 20 30 40int g0&#x2F;0&#x2F;7p l tp t a v 10 20 30 40 int g0&#x2F;0&#x2F;5p l tp t a v 10 20 30 40int g0&#x2F;0&#x2F;7p l tp t a v 10 20 30 40 int g0&#x2F;0&#x2F;3p l tp t a v 3 4 10 20 30 40 int e 1mo lam ac 2lacp pr enlacp pr de 10 t g 0&#x2F;0&#x2F;1 to 0&#x2F;0&#x2F;3 lacp pri 2000 int g0&#x2F;0&#x2F;2lacp pri 30000 int v 3ip a 35.1.1.3 24int v 10ip a 192.168.1.254 24int v 30ip a 192.168.3.254 24 qospf 1 ro 3.3.3.3ar 1net 35.1.1.3 0.0.0.0net 192.168.1.254 0.0.0.0net 192.168.3.254 0.0.0.0 qqstp mode mstpstp rere HWrev 1ins 1 v 10 30ins 2 v 20 40ac re stp ins 1 roo prstp ins 2 roo se syssys SW4un in en v b 3 4 10 20 40 int g0&#x2F;0&#x2F;5p l tp t a v 10 20 30 40int g0&#x2F;0&#x2F;7p l tp t a v 10 20 30 40 int g0&#x2F;0&#x2F;4p l tp t a v 3 4 10 20 30 40 int e 1mo lam ac 2lacp pr enlacp pr de 10 t g 0&#x2F;0&#x2F;1 to 0&#x2F;0&#x2F;3 int g0&#x2F;0&#x2F;2lacp pri 30000 int v 4ip a 45.1.1.4 24int v 20ip a 192.168.2.254 24int v 40ip a 192.168.4.254 24 qos 1 ro 4.4.4.4ar 1net 45.1.1.4 0.0.0.0net 192.168.2.254 0.0.0.0net 192.168.4.254 0.0.0.0 qqstp mode mstpstp rere HWrev 1ins 1 v 10 30ins 2 v 20 40ac re stp ins 2 roo prstp ins 1 roo se syssys SW5un in en v b 3 4 10 20 30 40 int v 3ip a 35.1.1.5 24int v 4ip a 45.1.1.5 24 int g0&#x2F;0&#x2F;1p l tp t a v 3 4 10 20 30 40int g0&#x2F;0&#x2F;2p l tp t a v 3 4 10 20 30 40 os 1 ro 5.5.5.5ar 1net 35.1.1.5 0.0.0.0net 192.168.2.254 0.0.0.0 总结0.配PCIP地址：192.168.1.1子网掩码：255.255.255.0网关：192.168.1.254 0.交换机&#x2F;路由器初始化：syssys R1&#x2F; SW1un in en 2.链路聚合：int e 1mo lacpmax act 3la pr entr g 0&#x2F;0&#x2F;1 to 0&#x2F;0&#x2F;4lacp preempt delay 20\t抢占延迟20s2.(1).链路聚合主动端优先级2000：la pri 2000(2)选举非活跃链路：（似乎也是主动端配就好了）int g0&#x2F;0&#x2F;3la pri 40000 2.(N).链路聚合检查：qdis eth 1 3.vlanv b 10 20 30 40 3.(1).与PC相接（与PC最近的交换机）：int g0&#x2F;0&#x2F;1p l ap d v 10int g0&#x2F;0&#x2F;2p l ap d v 10int g0&#x2F;0&#x2F;3p l ap d v 20int g0&#x2F;0&#x2F;4p l ap d v 20 3.(2).与上位交换机相接（通常是与带链路聚合的上位）：int g0&#x2F;0&#x2F;5p l tp t a v 10 20 30 40int g0&#x2F;0&#x2F;7p l tp t a v 10 20 30 40 3.(3).带链路聚合的上位交换机与(2)中交换机相接：int g0&#x2F;0&#x2F;5p l tp t a v 10 20 30 40int g0&#x2F;0&#x2F;7p l tp t a v 10 20 30 40 int e 1p l tp t a v 10 20 30 40 3.(4).链路聚合vlan（与3.3有所重复）：int e 1p l tp t a v 10 20 30 40 3.(N).vlan检查：qdis port vlan 4.STP：stp mo mstpstp region-configurationreg HWre 1ins 1 v 10 30ins 2 v 20 40act reg 4.(1).STP实例主&#x2F;副根配置：stp ins 1 root prstp ins 2 root se 4.(2).连接PC接口开启边缘端口功能,并开启边缘端口保护功能int g0&#x2F;0&#x2F;1stp edged-port enableint g0&#x2F;0&#x2F;2stp edged-port enableint g0&#x2F;0&#x2F;3stp edged-port enableint g0&#x2F;0&#x2F;4stp edged-port enable qstp bpdu-protection—或—-port-group 1group-member g0&#x2F;0&#x2F;3group-member g0&#x2F;0&#x2F;4group-member g0&#x2F;0&#x2F;5group-member g0&#x2F;0&#x2F;6stp edged-port enable qstp bpdu-protection 4.(3)接口开启根保护int g0&#x2F;0&#x2F;8stp root-protection 4.(4)开启TC BPDU防攻击,规定时间内处理的阈值调整为nstp tc-protection threshold 3 5.vlanif IP地址配置（上位交换机朝向顶层交换机的配置）v b 3 10 20 int g0&#x2F;0&#x2F;6p l ap d v 3 qintint v 3ip a 15.1.1.1 24 q#ping 15.1.1.5 顶层交换机朝向上位交换机的接口 int v 10ip a 192.168.1.254 24int v 20ip a 192.168.2.254 24 6.VRRPint v 10 #一个vlanif配一次vr vr 1 vir 192.168.1.101 (必须是vlan x 相同网段) 6.(1)VRRP主备优先级配置，大为主，100为缺省不用配vrrp vrid 1 priority 120 6.(2)跟踪上行链路接口，若g0&#x2F;0&#x2F;x连接的链路坏掉，让其自动降级，默认降10vrrp vrid 1 track interface g0&#x2F;0&#x2F;6 reduced 30 6.(N)检查VRRPdis vrrp brief 7.单臂路由interface GigabitEthernet0&#x2F;0&#x2F;1.1 dot1q termination vid 30 ip address 192.168.3.254 255.255.255.0 arp broadcast enable interface GigabitEthernet0&#x2F;0&#x2F;1.2 dot1q termination vid 40 ip address 192.168.4.254 255.255.255.0 arp broadcast enable 8.OSPF（顶层路由器）（顶层交换机没有接口配置）int g0&#x2F;0&#x2F;0ip a 35.1.1.5 24int g0&#x2F;0&#x2F;1ip a 45.1.1.5 24 os 1 ro 1.1.1.1ar 1net 35.1.1.5 0.0.0.0net 45.1.1.5 0.0.0.0 qq#dis ospf peer brief VRRP 虚拟路由冗余协议作用概括：实现网关备份，解决多个网关间冲突问题，提高网络可靠性 使用范围：三层（网络层）设备接口可部署 定义：多物理路由虚拟成一虚拟路由； 由多物理路由器共同维护； 虚拟路由IP变为终端网关 相关名词解释：VRID【virtuality router id】：虚拟路由标识符VIP【virtual-ip】：虚拟路由IP（由所有VRRP路由共同维护）【配置时指定】VMAC：虚拟路由MAC地址【(0000-5e 00-01 xx)，其中xx为VRID】 保留 VRRP vridVRRP路由成员身分：Master路由（只有一台）：进行网关数据转发和报文转发任务。 1.在每一个VRRP组中，只有Master路由器才会响应针对虚拟IP地址的ARP Request。 2.Master路由器会以一定的时间间隔周期性地发送VRRP报文，以便通知同一个VRRP组中的Backup路由器关于自己的存活情况。Backup路由（备份路由器）：1.备份网关数据 2.Master故障时升变为Master接替转发 实时侦听Master路由器发送出来的VRRP报文,随时准备接替Master路由器的工作。 成员选举规则：1.优先级：1-默认100-254 越大越优先【当物理路由IP地址与维护的IP地址为同一个IP地址时该路由器优先级自动修改为255】【Master挂了就向Backup发送优先级为0的通告报文，此时Backup将不在等待失效时间，直接变Master&#x2F;竞选Master】2.接口IP：1-默认100-254 越大越优先3.认证模式不一会出现多个主的现象 成员抢占规则：（抢占功能默认开启，开启后可被随时抢占（即Master可及时变化））1.优先级：默认100 越大越优先 主备切换规则：1.VRRP协议中定义两个定时器:Adver_interval定时器： Master发送VRRP通告报文时间周期，缺省值为1秒。Master_down定时器：超时即意味着Master挂了，Backup设备监听该定时器超时后，会升变为Master状态。 Master_Down定时器计算公式如下:MASTER_DOWN &#x3D; (3* ADVER_INTERVAL) +Skew_time (偏移时间)【大约三秒】其中，Skew_Time&#x3D; (256-Priority) &#x2F;256 2.主路由器不在运行VRRP时，发送优先为0的vrrp报文，备设备切换为主设备3.备设备收到优先级低的VRRP报文时,备设备切换为主设备 VRRP配置：1.进接口—-配IP2.进接口—[R1-GigabitEthernet0&#x2F;0&#x2F;0] vrrp vrid 1 virtual-ip 192.168.1.100接口进入VRRP模式–虚拟路由标识符编号为1—虚拟IP 192.168.1.100#查看 VRRP 简要信息[R1]display vrrp brief#查看 VRP 信息[R1]display vrrp#删除进程1[R1-GigabitEthernet0&#x2F;0&#x2F;0]undo vrrp vrid 1*修改某接口VRRP–指定虚拟路由标识符优先级[R1-GigabitEthernet0&#x2F;0&#x2F;0]vrrp vrid 1 priority 120*某接口–身份验证模式–md5密文认证–密码[R1-GigabitEthernet0&#x2F;0&#x2F;0]vrrp vrid 1 authentication-mode md5 huawei某接口出现故障时优先级减小[R1-GigabitEthernet0&#x2F;0&#x2F;0]vrrp vrid 1 track interface g0&#x2F;0&#x2F;2 reduced 30 ###ping XXX.XXX.XXX.XXX -t 一直ping VRRP协议报文：基于IP协议封装，协议号112更新方式：采用组播更新 224.0.0.18 虚拟路由器冗余协议版本2，包类型1(广告)虚拟Rtr ID: 1优先级:120(非默认备份优先级)Addr Count: 1Auth Type: No Authentication (0)Adver Int: 1校验和:Oxa4ef[正确][校验和状态:Good]IP地址:192.168.1.100 拓扑名：VRRPR1：syssys R1un in en int g0&#x2F;0&#x2F;0ip a 192.168.1.253 vr vr 1 vir 192.168.1.100vr vr 1 pri 120 vr vr 1 au m huawei R2：syssys R2un in en int g0&#x2F;0&#x2F;0ip a 192.168.1.254 vr vr 1 vir 192.168.1.100 vr vr 1 au m huawei VRRP状态机Initialize (初始状态)、Master (活动状态)、Backup (备份状态)。 I:收到Startup（pri&#x3D;?)——-&gt; SHO&#x3D;255 —-&gt;M 收到优先级比自己大的报文 —-&gt;B&lt;255 —-&gt;B 设置抢占延迟（让让OSPF）[R1-GigabitEthernet0&#x2F;0&#x2F;0]vrrp vrid 1 preempt-mode timer delay 40 VRRP STP 主应在同一交换机 拓扑名：VRRP下午R1：syssys R1un in en int g0&#x2F;0&#x2F;2ip a 13.1.1.1 24 int g0&#x2F;0&#x2F;0ip a 192.168.1.253 24vr vr 1 vir 192.168.1.100vrrp vr 1 pri 120vr vr 1 au m huaweivrrp vr 1 pr ti de 40vrrp vr 1 tr int g0&#x2F;0&#x2F;2 re 30 qos 1 ro 1.1.1.1ar 0net 192.168.1.253 0.0.0.0net 13.1.1.1 0.0.0.0 dis cu R2：syssys R2un in en int g0&#x2F;0&#x2F;2ip a 23.1.1.2 24 int g0&#x2F;0&#x2F;0ip a 192.168.1.254 24vr vr 1 vir 192.168.1.100vr vr 1 au m huaweivrrp vr 1 pr ti de 40 qos 1 ro 2.2.2.2ar 0net 23.1.1.2 0.0.0.0net 192.168.1.254 0.0.0.0 dis cu R3:syssys R3un in en int g0&#x2F;0&#x2F;0ip a 192.168.3.254 24int g0&#x2F;0&#x2F;1ip a 23.1.1.3 24int g0&#x2F;0&#x2F;2ip a 13.1.1.3 24 qos 1 ro 3.3.3.3ar 0net 13.1.1.3 0.0.0.0net 23.1.1.3 0.0.0.0net 192.168.3.254 0.0.0.0 dis cu 二层技术：VLAN：虚拟局域网为什么要有VLAN？交换机工作原理：学习，泛洪，转发广播域：能收到广播消息的范围&#x2F;区域交换机默认所有接口都在同一个广播域广播域大–占用带宽资源，安全性低；VLAN作用：隔离广播域如何实现隔离？交换机为数据打上Tag，利用Tag区分不同VLAN 不带tag数据（untagged）帧头(DMAC&lt;–SMAC type)|ip(SIP–&gt;DIP)|tcp&#x2F;udp|data|帧尾 携带tag数据（tagged）帧头(DMAC&lt;–SMAC|tag(4bytes)|type)|ip(SIP–&gt;DIP)|tcp&#x2F;udp|data|帧尾 Tag&#x3D;4B1.Type 类型 0X8100-802.1Q标准—-vlan2.PRI 优先级 用于QOS (服务质量)3.CFI MAC地址是否支持经典格式4.VID(12bits 2^12&#x3D;4096vlan 范围：0-4095 能用的：1-4094) VLAN标识 VLAN 对于tag不同处理动作–端口处理类型Access：接入链路：只允许一个vlan通过 交换机–终端设备Trunk： 干道链路：允许多个vlan通过 交换机–交换机Hybrid：混合链路：手工定义允许通过的vlan及vlan通过时的动作\t默认类型 VLAN配置：创建单个vlan：[SW1]vlan 10 –&gt; [SW1-vlan10]描述备注vlan：[SW1-vlan10]description HR创建多个vlan：[SW1]vlan batch 20 30创建连续vlan：[SW1]vlan batch 40 to 100查看vlan：[sw1]display vlan查看端口和vlan关系：display port vlan Access配置：1. 进入接口 2. 端口链路类型-access 3. 端口所属的vlan[SW1]int g0&#x2F;0&#x2F;1[SW1-GigabitEthernet0&#x2F;0&#x2F;1]port link-type access[SW1-GigabitEthernet0&#x2F;0&#x2F;1]port default vlan 10 Trunk配置：1. 进入接口 2. 端口链路类型-trunk 3. trunk端口允许通过的vlan[SW1]int g0&#x2F;0&#x2F;5[SW1-GigabitEthernet0&#x2F;0&#x2F;5]port link-type trunk[SW1-GigabitEthernet0&#x2F;0&#x2F;5]port trunk allow-pass vlan 10 20*[SW1-GigabitEthernet0&#x2F;0&#x2F;5]undo port trunk allow-pass vlan 1 删除vlan1[SW1-GigabitEthernet0&#x2F;0&#x2F;5]port trunk pvid vlan 100 修改trunk接口pvid 删除命令 倒着删看到回车 Hybrid配置：tagged：携带标记untagged：不携带标记[SW1]int g0&#x2F;0&#x2F;6[SW1-GigabitEthernet0&#x2F;0&#x2F;6]port link-type hybrid[SW1-GigabitEthernet0&#x2F;0&#x2F;6]port hybrid untagged vlan 30[SW1-GigabitEthernet0&#x2F;0&#x2F;6]port hybrid pvid vlan 30 Tag的处理：允许列表下，不带标记打标记，相同标记去标转发，不同标记A丢T转{Access：（不带标记打标记，相同标记去标转发，不同标记直接丢弃）入：不带标记，打上PVID出：PVID比较，同就去标记转发，不同就丢弃Trunk：出：允许列表下，不同标记直接转发，相同标记去标转发入：允许列表下，不带标记打标记，带着标记直接转发Hybrid：出：允许列表下，手工定义允许通过的vlan及通过时动作入：在满足允许列表前提下，收到数据带标记，直接转发；收到数据不带标记，打上该接口的pvid的标记} 三层交换机&#x3D;路由器(IP+静态+动态) +二层交换机(vlan stp)集合 三层交换机物理接口无法配置IP地址（交换机接口默认二层接口）如何在交换机上配置IP地址?1、将二层接口转换为三层接口[SW2]int g0&#x2F;0&#x2F;5[SW2-GigabitEthernet0&#x2F;0&#x2F;5]undo portswitch 删除端口交换功能2、在交换机上配置vlan虚拟接口 vlanif[SW2]interface Vlanif 10[SW2-Vlanif10]ip address 192.168.1.254 24[SW2]interface Vlanif 20[SW2-Vlanif10]ip address192.168.2.254 24 交换机出来的数据一定带标记，路由器不带（1）全程带标记 trunk（2）出来去标记，进入打标记 access hybrid 配置实验:配置思路 先二层（聚合 vlan stp）再三层（vlan if 静态 OSPF)每配置完一个技术——-验证是否正确Vlan：dis port vlan dis vlanVlanif ip地址：dis ip int brief配置完毕两端IP地址测试直连连通性：ping 对端地址静态：dis ip roOspf：dis ospf pe br (full状态) dis ip ro 将静态路由引入到ospf中，参考命令如下：[R3]ospf 1[R3-ospf-1]import-route staticospf 外部路由 150 单臂路由：Dot1q&#x3D;802.1q 0x8100k [R6]int g0&#x2F;0&#x2F;0.1 开启子接口[R6-GigabitEthernet0&#x2F;0&#x2F;0.1]ip address 192.168.5.254 24 接口IP[R6-GigabitEthernet0&#x2F;0&#x2F;0.1]dot1q termination vid 50 允许通过的vlan[R6-GigabitEthernet0&#x2F;0&#x2F;0.1]arp broadcast enable 子接口默认广播功能没开 链路聚合：产生背景：为了提升网络可靠性，增大带宽单板可靠—多冗余设备可靠—双冗余链路可靠—多链路 STP：生成树协议阻塞端口如何在保证可靠前提下，提升带宽，减少丢包定义：将多条物理链路聚合成一条聚合链路（eth-trunk） 模式：手工链路聚合模式：聚合链路中的所有链路都参数据的转发1、创建聚合接口2、将物理接口加入聚合接口 SW1：syssys SW1 un in en int Eth-Trunk 1qint g0&#x2F;0&#x2F;1eth-trunk 1qint g0&#x2F;0&#x2F;2eth-trunk 1qint g0&#x2F;0&#x2F;3eth-trunk 1或者int Eth-Trunk 1trunkport g0&#x2F;0&#x2F;1trunkport g0&#x2F;0&#x2F;2trunkport g0&#x2F;0&#x2F;3或者int Eth-Trunk 1 trunkport g 0&#x2F;0&#x2F;1 to 0&#x2F;0&#x2F;3 dis eth-trunk 1 查看聚合接口1 LACP链路聚合模式：存在备份链路: M:N备份 M-活跃链路 N-非活跃链路LACP：链路聚合控制协议设备之间发送LACPDU：链路聚合控制协议数据单元 要素：LACPDU:设备系统优先级MАC接口优先级接口编号 如何选举活跃链路：在两台交换机之间选举出主动端先比LACP系统优先级（32768），越小越优先再比MAC：越小越优先 在主动端设备上选举活跃链路：先比LACP接口优先级（32768），越小越优先再比接口编号：越小越优先 SW3：syssys SW3un in enint eth-trunk 2 创建聚合接口mode lacp-static 改为LACP模式max active-linknumber 3 配置最大活跃链路数量lacp preempt enable （默认抢占关闭）开启抢占lacp preempt delay 10 配置抢占延迟(s)trunkport g 0&#x2F;0&#x2F;1 to 0&#x2F;0&#x2F;4 将物理接口加入聚合接口 lacp priority 4000 修改lacp系统优先级 int g0&#x2F;0&#x2F;2lacp priority 40000 修改LACP接口优先级 qdis eth-trunk 2 SW4:syssys SW4un in enint eth 2mode lacp-staticmax active- 3lacp preempt enable&#x2F;&#x2F;lacp pr enla pr de 10tr g 0&#x2F;0&#x2F;1 to 0&#x2F;0&#x2F;4 int g0&#x2F;0&#x2F;2lacp priority 40000 STP：生成树协议（在保证可靠的前提下，解决环路问题）产生原因：二层环境为了保证可靠性，采用双冗余设备环形连接方式—环路问题 问题：广播风暴—&gt;设备宕机 MAC地址表震荡—-&gt;数据转发丢包 原理：阻塞端口-拓扑稳定时，阻塞端口处于阻塞状态，当链路出现故障时，阻塞端口自动开启，开始转发数据。 应用场景：二层交换网络—交换机默认运行STP STP模式：STP：生成树协议RSTP：快速生成树协议MSTP：多实例生成树协议 [SW2]display stp 查看STP（默认MSTP模式）[SW3]display stp brief 查看STP简要信息[sw2]stp mode stp 修改为stp模式[sw2]display int g0&#x2F;0&#x2F;2 查看端口 STP 工作原理—阻塞端口如何选出来的？ 根-选举根交换机（根桥）—–网桥ID：定义：运行STP协议的交换机唯一标识组成：网桥优先级（默认32768，4096倍数，越小越优先）+MAC地址比较网桥ID：(先比较优先级、在比较mac地址，越小越优先) [SW2]stp priority 4096 修改优先级 干：根端口（RP）定义：非根交换机到达根交换机最优的端口比较规则:1、根路径开销 802.1t 10M&#x3D;2000000 100M&#x3D;200000 1000M&#x3D;20000 10GM&#x3D;2000 根路径开销RPC(root path cost)：根桥到达该设备沿途交换机入方向每个接口cost值之和 （根交换机上所有端口都叫指定端口） [SW1]int g0&#x2F;0&#x2F;1[SW1-GigabitEthernet0&#x2F;0&#x2F;1]stp cost 200000 修改接口cost 2、对端交换机的网桥ID3、对端端口ID\t端口优先级+端口编号\t默认128 16倍数 [SW1-GigabitEthernet0&#x2F;0&#x2F;2]stp port priority 16 修改STP接口优先级 4.本端端口ID 端口优先级+端口编号 枝：指定端口（DP）定义：每一条链路到达根交换机最优的端口比较规则:1、根路径开销2、两端交换机的网桥ID3、本端端口ID 阻塞端口（BP，block port；AP）：阻塞端口 Role（端口角色：）DESI: 指定ROOT：根ALTE：预备 BPDU：STP报文 STP State（状态）：Discarding:丢弃Learning:学习Forwording：提出 STP：（越小越优先）根：根据网桥ID：先看网桥优先级，再看MAC地址优先级根端口：非根交换机到达根交换机最优的端口：1、根路径开销2、对端交换机的网桥ID3、对端端口ID\t端口优先级+端口编号\t默认128 16倍数4、本端端口ID 端口优先级+端口编号指定端口 ：每一条链路到达根交换机最优的端口1、根路径开销2、两端交换机的网桥ID3、本端端口ID STP报文–BPDU（桥协议数据单元）Protocol Identifier: Spanning Tree Protocol (0x0000) 协议标识符:生成树协议Protocol Version Identifier: Spanning Tree (0) 协议版本标识符:生成树(0)BPDU Type: Configuration (0x00) BPDU类型：Confiquration 配置BPDU：进行STP角色计算、维护拓扑；（1：请求知道啦！0：相安无事） TCN BPDU(拓扑变化 BPDU)：通告拓扑变化（1：拓扑变化啦！0：相安无事）BPDU flags: 0x00 BPDU标志 0… …&#x3D; Topology Change Acknowledgment: No TCA:拓扑变化确认 …0 &#x3D; Topology Change: No TC：拓扑变化（老化MAC地址，学习新MAC地址，阻塞端口进入转发状态）（1：可以老化MAC地址啦！0：相安无事）Root Identifier: 4096 &#x2F;0&#x2F; 4c:1f:cc:b9:3f:59 根标识符（根网桥ID）Root Path Cost: 0 根路径开销Bridge Identifier: 4096 &#x2F;0&#x2F; 4c:1f:cc:b9:3f:59 本交换机网桥IDPort identifier: 0x8002 端口标ID:0x8002 Message Age: 0 消息寿命（BPTU存放时间，最多20秒）Max Age: 20 最大寿命Hello Time: 2 发送间隔Forward Delay: 15 发送延迟 STP端口状态：禁用(Disable)：该接口不能收发BPDU,也不能收发业务数据帧,例如接口为down阻塞(Blocking)：该接口被STP阻塞。处于阻塞状态的接口不能发送BPDU,但是会持续侦听BPDU,而且不能收发业务数据帧,也不会进行MAC地址学习侦听（Listening)：当接口处于该状态时,表明STP初步认定该接口为根接口或指定接口,但接口依然处于STP计算的过程中,此时接口可以收发BPDU,但是不能收发业务数据帧,也不会进行MAC地址学习学习（Learning）：当接口处于该状态时，会侦听业务数据帧（但是不能转发业务数据帧),并且在收到业务数据帧后进行MAC地址学习转发(Forwarding)：处于该状态的接口可以正常地收发业务数据帧,也会进行BPDU处理。接口的角色需是根接口或指定接口才能进入转发状态 禁用：不能收发BPDU，不能收发业务数据帧；接口Down阻塞：只收不发BPDU，不能收发业务数据帧；不学MAC侦听：可以收发BPDU，不能收发业务数据帧，不学MAC；初步认定接口类型；15s转发延迟：1.加速老化MAC地址表（正常MAC地址表老化时间：300s）2.避免临时环路学习：侦听业务数据帧1，收到业务数据帧后学MAC；15s转发延迟：加速mac地址学习转发：收发BPDU，收发业务数据帧；接口的角色需是根接口或指定接口才能进入转发状态 STP 拓扑维护直接故障：阻塞端口所在交換机链路发生故障，阻塞端口恢复至少需要30sTCN：拓扑变更通知间接故障：阻塞端口恢复至少需要50s20sBPDU才超时 STP模式缺点：收敛速度慢 改进模式：RSTP：快速生成树协议RSTP相对于STP改进：STP：802.1DRSTP：802.1W（2001年） 改进点1：端口角色RSTP根端口指定端口替代端口(Alternate)以后将成为根端口，作为根端口的备份备份端口(Backup)以后将成为指定端口，作为指定端口的备份 改进点2：端口状态RSTPDiscarding状态：不转发用户流量也不学习MAC地址；学习(Learning)：不转发用户流量但是学习MAC地址；转发(Forwarding)：既转发用户流量又学习MAC地址。 改进点3：报文BPDU改进STP BPDU：配置BPDURSTP BPDU：RST BPDU Protocol Identifier: Spanning Tree Protocol (0x0000)Protocol Version Identifier: Rapid Spanning TreeBPDU Type: Rapid&#x2F;Multiple Spanning Tree (0x02)BPDU flags: ox7d, Agreement, Forwarding, Learning, Port Role: Designated, Topology Change 0… …. &#x3D; Topology Change Acknowledgment: No\t拓扑变化确认位 .1.. …. &#x3D; Agreement: Yes 同意位 ..1. …. &#x3D; Forwarding: Yes 转发位 …1 …. &#x3D; Learning: Yes 学习位 …. 11..&#x3D; Port Role: Designated (3) 端口角色（10根端口 01替代端口&#x2F;备份端口 00保留 11指定端口 …. ..0. &#x3D; Proposal: No 提议&#x2F;协商位 ….. …1 &#x3D; Topology Change: Yes 拓扑变化位 &gt;Root Identifier: 32768 &#x2F;0&#x2F; 4c:1f:cc:3d:13:34 根网桥ID Root Path Cost: 0 根路径开销 Bridge Identifier: 32768 &#x2F;0 &#x2F; 4c:1f:cc:3d:13:34 本交换机网桥ID Port identifier: 0x8001 端口标识 Message Age: 0 消息寿命 Max Age: 20 最大寿命 Hello Time: 2 发送间隔 Forward Delay: 15 转发延迟 Version 1 Length: 0 版本1长度 改进点4：BPDU处理动作（1）BPDU发送在STP中由根桥发送配置BPDU，交换机收到根桥发送的配置BPDU后，才会向下游发送配置BPDU,收敛慢,计算复杂在RSTP中,无论非根桥设备是否收到根桥发送BPDU，都会向下游交换机发送BPDU（2）判断根桥&#x2F;链路故障在STP中，根据max age (20s)超时判定在RSTP中，根据超时时间(hello*3倍），超时判定（3）次等BPDU的处理在STP中，只能由指定端口处理此等BPDU在RSTP中，当接口收到BPDU后,和本地缓存表中BPDU进行比较，若优于收到BPDU，则将更有BPDU从该接口返回 收敛机制改进（仅限于单交换机设备上）根端口快速切换：当根端口出现故障时，替代端口可以快速切换为根端口，端口状态换为转发状态指定端口快速切换：当指定端口出现故障时，备份端口可以快速切换为指定端口，端口状态切换为转发状态边缘端口机制：定义：交换机连接终端设备的端口可以生成边缘端口作用：边缘端口不参与STP计算，会直接进入转发状态特点：当边缘端口收到bpdu，该端口转为STP普通端口，重新进行STP计算配置：[SW3]int g0&#x2F;0&#x2F;3 [SW3-GigabitEthernet0&#x2F;0&#x2F;3]stp edged-port enable P&#x2F;A机制（提议&#x2F;同意机制）： 如何用命令修改主根&#x2F;备份根[SW1]stp root primary[SW2]stp root secondary RSTP故障恢复：SW1与SW3之间的链路故障，SW3的g0&#x2F;0&#x2F;2口开启tewell计时器并向SW2发送tc位置位的BPDU（计时器发送后停止发送），并老化所有MAC，学习新MAC地址；SW2收到后tc位置位的BPDU后老化除接收口以外的MAC地址，向SW1发送tc位置位的BPDU，学习新MAC地址，以此类推。 保护机制：1.BPDU保护&#x2F;边缘端口保护：从边缘端口收到RST BPDU后，该端口进入down状态[SW3]stp bpdu-protection 2.根保护&#x2F;指定端口保护一旦启用根保护功能的指定端口，收到优先级更高的RST BPDU时，端口将进入Discarding状态，不再转发报文。经过一段时间(通常为两倍的Forward Delay) ，如果端口一直没有再收到优先级较高的RST BPDU，端口会自动恢复到正常的Forwarding状态。[SW1]int g0&#x2F;0&#x2F;3[SW1-GigabitEthernet0&#x2F;0&#x2F;3]stp root-protection 开启根保护 3.环路保护在启动了环路保护功能后，如果根端口或Alternate端口长时间收不到来自上游设备的BPDU报文时，则向网管发出通知信息(此时根端口会进入Discarding状态,角色切换为指定端口) ，而Alternate端口则会一直保持在Discarding状态（角色也会切换为指定端口) ，不转发报文，从而不会在网络中形成环路。[SW3]int g0&#x2F;0&#x2F;5[SW3-GigabitEthernet0&#x2F;0&#x2F;5]stp loop-protection 防TC-BPDU攻击&#x2F;TC BPDU保护启用防TC-BPDU报文攻击功能后，在单位时间内，交换设备处理TC BPDU报文的次数可配置。如果在单位时间(2s)内，交换设备在收到TC BPDU报文数量大于配置的阈值(3次)，那么设备只会处理阈值指定的次数。[SW3]stp tc-protection 开启TC BPDU保护[SW3]stp tc-protection threshold 2 修改tc bpdu接收的阈值 MSTP:多实例生成树单个RSTP不足之处：1、无法实现流量的负载分担2、次优路径问题 定义：MSTP可以将一个或多个VLAN映射到一个实例(实例),再基于实例计算生成树,映射到同一个实例的VLAN共享同一棵生成的树。每一个实例都是单独RSTP。原理—名词认知：MST Region (Multiple Spanning Tree Region,多生成树域），也可简称MST域同一个MST域的设备具有下列特点:都启动了MSTP.具有相同的域名。具有相同的VLAN到生成树实例映射配置。具有相同的MSTP修订级别配置。 MSTI (Multiple Spanning Tree Instance，多生成树实例)： 一个MST域内可以生成多棵生成树,每棵生成树都称为一个MSTI MSTI使用Instance ID标识，华为设备取值为0~4094 Instance0是缺省存在的,而且缺省时,华为交换机上所有的VLAN都映射到了Instance0。 CST (Common Spanning Tree，公共生成树）IST (Internal Spanning Tree,内部生成树)；IST是一个特殊的MSTI, MSTI的Instance ID为0。CIST (Common and Internal Spanning Tree,公共和内部生成树）；通过生成树协议计算生成的,连接一个交换网络内所有交换设备的单生成树。SST (Single Spanning Tree，单生成树） 总根(CIST Root) 是CIST的根桥域根（Regional Root) 分为IST域根和MSTI域根 IST域根，在MST域中IST生成树中距离总根最近的交换设备是IST域根 MSTI域根是每个多生成树实例的树根主桥（Master Bridge） 是IST Master，它是域内距离总根最近的交换设备 如果总根在MST域中,则总根为该域的主桥。 MSTP中定义的所有端口角色包括：根端口、指定端口、Alternate端口、Backup端口 Master端口、域边缘端口和边缘端口。Master端口是特殊的边缘端口。 [SW2]stp mode mstp 模式修改为MSTP[SW2]stp region-configuration 进入stp域配置[SW2-mst-reqion]reqion-name HW 修改域名称[SW2-mst-region]revision-level 1 修改域修订等级[SW2-mst-region]instance 1 vlan 10 实例关联vlan[SW2-mst-region]instance 2 vlan 20\t[SW2-mst-region]active region-configuration\t激活域配置[SW2]stp instance 1 root primary\t[SW2]stp instance 2 root secondary 配置实例主根和备份根 stp mode mstpstp rere HWrev 1ins 1 v 10 30ins 2 v 20 40ac re stp ins 2 roo prstp ins 1 roo se [SW2]port-group 1[SW2-port-group-1]group-member g0&#x2F;0&#x2F;1[SW2-port-group-1]group-member g0&#x2F;0&#x2F;2[SW2-port-group-1]group-member g0&#x2F;0&#x2F;3[SW2-port-group-1]group-member g0&#x2F;0&#x2F;4[SW2-port-group-1]stp edged-port enable display ospf peer brief display ip int br display ip routing-table ACL 访问控制列表产生背景：为了提升网络的安全性，控制数据的转发，需要流量控制工具 作用：能够对于报文进行区分和匹配；流量控制工具 工作原理动作：permit：允许 deny：拒绝 匹配条件：帧头(Dmac–Smac)|IP(Sip-Dip)|tcp&#x2F;udp(Sport-Dport)|data|帧尾 匹配顺序：按照rule编号从上到下依次匹配默认动作：允许所有—ACL对于数据的处理 基本ACL 2000-2999\t仅使用报文的源IP地址、分片信息和生效时间段信息来定义规则。高级ACL 3000-3999\t可使用IPv4报文的源IP地址、目的IP地址、IP协议类型、ICMP类型、TCP源&#x2F;目的端口号、UDP源&#x2F;目的端口号、生效时间段等来定义规则。二层ACL 4000-4999\t使用报文的以太网帧头信息来定义规则，如根据源MAC地址、目的MAC地址、二层协议类型等。用户自定义ACL\t5000-5999\t使用报文头、偏移位置、字符串掩码和用户自定义字符串来定义规则。用户ACL 6000-6999\t既可使用IPv4报文的源IP地址或源UCL (User Control List)组,也可使用目的IP地址或目的UCL组、IP协议类型、ICMP类型、TCP源端口&#x2F;目的端口、UDP源端口&#x2F;目的端口号等来定义规则。 基本ACL配置： 创建ACL：[R3]acl 2001[R3-acl-basic-2001]rule deny source 192.168.1.0 0.0.0.255\t拒绝源是192.168.1.0的数据 调用ACL：[R3]int g0&#x2F;0&#x2F;2[R3-GigabitEthernet0&#x2F;0&#x2F;2]traffic-filter outbound acl 2001 高级ACL：创建ACL：[R2]acl 3000[R2-acl-adv-3000]rule deny tcp source 192.168.1.1.0 destination 192.168.2.2 0 destination-port eq www调用ACL：[R2]int g0&#x2F;0&#x2F;0[R2-GigabitEthernet0&#x2F;0&#x2F;0]traffic-filter inbound acl 3000 NAT在网络边界设备上(路由器、防火墙)，将数据中的私网地址和公网地址进行转换 NAT分类：静态NAT\t1对1转换\t1个私有IP地址转换为固定的某1个公有IP地址动态NAT 多对多转换\t多个私有IP地址基于公网地址池进行转换NAPT（网络地址端口转换）多对1转换\t多个私有IP地址转换为一个&#x2F;多个公网IP地址（利用端口号区分不同的私有IP地址） [R5]ospf[R5-ospf-1]default-route-advertise always 自动下发缺省路由 [R5]int g0&#x2F;0&#x2F;0[R5-GigabitEthernet0&#x2F;0&#x2F;0]nat static global 100.1.1.100 inside 192.168.1.1静态内网连接全局公网 NAPT配置：[R5]acl 2000\t定义出要转换的内网数据[R5-acl-basic-2000]rule permit source 192.168.2.0 0.0.0.255[R5]nat address-group 1 100.1.1.50 100.1.1.51 创建公网地址池[R5]int g0&#x2F;0&#x2F;0\t将内网数据和公网地址池进行映射[R5-GigabitEthernet0&#x2F;0&#x2F;0]nat outbound 2000 address-group 1 动态NAT配置：[R5]int g0&#x2F;0&#x2F;0 将内网数据和公网地址池进行映射[R5-GigabitEthernet0&#x2F;0&#x2F;0]nat outbound 2000 address-group 1 no-pat easy-ip：将多个私有IP地址转换为公网出接口的IP地址[R5]ACL 2001\t定义出要转换的内网数据[R5-acl-basic-2001]rule permit source 192.168.3.00.0.0.255 [R5]int g0&#x2F;0&#x2F;0 将内网数据和接口进行映射[R5-GigabitEthernet0&#x2F;0&#x2F;0]nat outbound 2001 ​"},{"title":"Net","path":"/Net/","content":"软件定义网络（Software Defined Network，SDN）应用层、控制层、转发层 异构网络 有a台主机，使用xxx.xxx.xxx.xxx作为网络地址，求合适的子网掩码 2^n-2&gt;&#x3D;主机数，其中n为主机位 网络位+主机位&#x3D;32 CIDR - 无类别域间路由 - Classless Inter Domain RoutingCIDR表示法：例：192.168.0.0&#x2F;16 表示前十六位是网络地址，剩余的32-16&#x3D;16位用于主机地址。这种表示方法允许将IP地址块划分为不同大小的子网，每个子网可以拥有不同数量的主机地址。 CIDR的主要优势包括：1.减少IP地址浪费；2.路由表简化；3.灵活的子网划分 移动IP技术移动IP技术是一种网络协议，它允许移动设备在改变物理位置时保持其IP地址不变，从而使得设备可以无缝地在不同网络之间切换而不会中断正在进行的网络通信。 代理发现 - 注册 - 数据包路由 - 注销 ARP - 地址解析协议 - Address Resolution ProtocolARP 是一种将网络层的IP地址映射为链路层的物理地址（即MAC地址）的协议。"},{"title":"Web-Development","path":"/Web-Development/","content":"编辑器：VSCode 扩展：Live Server"},{"title":"Windows 10 优化策略/必要组件","path":"/Win10-Update/","content":"禁用 Windows 10 自动更新在Windows 10中，自动更新是由Windows Update服务管理的，通常用户无法完全禁用它，因为微软设计这个系统是为了确保用户的电脑能够及时获得安全更新和补丁。但是，你可以暂停更新或延迟更新的安装。以下是一些可以尝试的方法： 通过设置暂停更新： 打开“设置”（Settings）。 点击“更新与安全”（Update &amp; Security）。 选择“Windows Update”。 在“高级选项”（Advanced options）下，点击“暂停更新”（Pause updates）按钮。 延迟更新： 在“Windows Update”设置中，你可以选择“延迟更新”（Defer updates），这样你可以在一段时间内不接收最新的功能更新。 通过组策略编辑器： 按Win + R键打开“运行”对话框，输入gpedit.msc并回车，打开“本地组策略编辑器”（Local Group Policy Editor）。 导航到“计算机配置”（Computer Configuration）&gt;“管理模板”（Administrative Templates）&gt;“Windows 组件”（Windows Components）&gt;“Windows Update”。 找到“配置自动更新”（Configure Automatic Updates）并双击打开。 选择“已禁用”（Disabled），然后点击“确定”。 通过服务管理器： 打开“服务”（Services）应用程序（可以在运行对话框中输入services.msc）。 找到“Windows Update”服务，双击打开。 将启动类型设置为“禁用”（Disabled），然后停止服务。 通过注册表编辑器： 按Win + R键打开“运行”对话框，输入regedit并回车，打开“注册表编辑器”（Registry Editor）。 导航到HKEY_LOCAL_MACHINE\\SOFTWARE\\Policies\\Microsoft\\Windows\\WindowsUpdate\\AU。 如果“AU”键不存在，你需要创建它。右键点击“WindowsUpdate”键，选择“新建”（New）&gt;“键”（Key），并命名为“AU”。 在“AU”键下，新建一个名为“NoAutoUpdate”的DWORD（32位）值，设置值为“1”。 警告：修改组策略、服务或注册表可能会对系统造成不可预测的影响，并且可能会使你的电脑面临安全风险。在进行这些更改之前，请确保你了解它们的含义，并且已经创建了系统还原点，以便在出现问题时可以恢复。 此外，如果你使用的是企业版或教育版的Windows 10，你的IT管理员可能会控制更新设置，这时你可能需要联系他们来管理更新。 缺少必要的运行库 Microsoft Visual C++ Runtime最新受支持的 Visual C++ 可再发行程序包下载 | Microsoft Learn DirectX RuntimeDownload DirectX 最终用户运行时 Web 安装程序 from Official Microsoft Download Center AMD Ryzen™ 7 6800H 驱动程序"},{"title":"三级嵌入式笔记","path":"/NCRE3-Embedded/","content":"题型分析1.选择\t1分1空\t40分 2.填空\t2分1空\t40分 3.综合\t20分 收集选择：1.不属于嵌入式系统：巨型计算机2.4位，8位，32位，64位 3.8位MCU 4.SoC:片上系统通用SoC：可以有一个或多个CPU（或DSP），称为单&#x2F;多核SoC 5.数码相机由前端和后端两部分组成 前端负责数字图像获取，后端负责数字图像的处理 后端通常是以嵌入式DSP作为核心的SoC芯片，DSP用于完成数字图像处理 还有一个超低功耗的8位MCU，负责进行操作控制； 配置有实时操作系统和图像处理软件 6..txt文字统计nKB*1024 如果是汉字则&#x2F;2 7.数字有线电视所传输的数字视频采用的压缩编码标准 - MPEG-2MPEG-2 - 1994 - 传输率在3-10Mbits&#x2F;sec间 - NTSC制式下的分辨率可达720X486 8.C类IP地址范围：192.0.0.1到223.255.255.254。C类网络地址数量较多，适用于小规模的局域网络，每个网络最多只能包含254台计算机。 9.嵌入式处理器 体系结构按 指令集 分：CISC 和 RISC 按 存储机制 分：冯诺·依曼结构 及 哈佛结构 按 字长 分：8位、16位、32位和64位 10.ARM内核主要特点耗电省、功能强、成本低、 16位Thumb与32位ARM和Thumb-2双指令集并存 ARM有许多系列，如ARM7，ARM9，ARM10E，XScale，Cortex等 哈佛结构和冯诺依谩结构都有 （如控制领域最常用的ARM7系列是冯诺依谩结构，而Cortex-M3系列是哈佛结构。） ARM公司在经典处理器ARM11以后的产品改用Cortex命名，并分成A、R和M三类，旨在为各种不同的市场提供服务。 Cortex系列属于ARMv7架构，这是到2010年为止ARM公司最新的指令集架构。（2011年，ARMv8 架构在 TechCon 上推出）ARMv7架构定义了三大分工明确的系列：“A”系列面向尖端的基于虚拟内存的操作系统和用户应用；“R”系列针对实时系统；“M”系列对微控制器。 11.在ARM的体系结构中，处理器可以工作在3种不同的状态，①ARM状态②是Thumb状态及Thumb-2状态③调试状态。除支持Thumb-2的ARM处理器外，其他所有ARM处理器都可以工作在ARM状态。ARM状态是ARM处理器工作于32位指令的状态，所有指令均为32位宽度。 12.CPSR(当前程序状态寄存器)在任何处理器模式下被访问。它包含了条件标志位、中断禁止位、当前处理器模式标志以及其他的一些控制和状态位。 13.大端模式 - 反过来所谓的大端模式，是指数据的高位，保存在内存的低地址中，而数据的低位，保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位存放。 14.在Thumb指令集中，8位数据变32位可以通过数字左移完成15.指令LDR R2，[R5，#2]！执行后，LDR是存储器到寄存器的数据传送指令，#是立即数符号，题中是基址加变址寻址，表示［R5+2］→R2，执行过后，R5的值为R5+2。16.将ARM处理器R0中的一个字节的数据，存入由R1+4指示的内存区域，且地址自动更新，则使用的ARM指令是：需采用基址加变址寻址方式，字节数据存储指令用STRB 17.汇编中使用逻辑或指令和1进行或运算可以达到让寄存器中的指定位置位的作用 18.前向通道：输入接口 - 模拟量输入接口、数字量输入接口，包括传感器，信号调节电路（滤波，放大器等），A&#x2F;D转换器（Analog模拟 to Digital数字 Converter）等构成 19.后向通道：输出接口 - 模拟量输出接口、数字量输出接口，包括D&#x2F;A转换器，功率放大器，执行器等 20.AMBA 是ARM公司公布的总线协议，用于连接和管理片上系统 (SoC) 中功能模块的开放标准和片上互连规范。 21.系统总线通过桥接器与外围总线互连。 外围总线连接的硬件组件包括：GPIO、UART、SPI、I2C、USB设备ADC(Analog模拟-to-Digital数字 Converter)、DAC等等。DMA（Direct Memory Access，直接存储器访问）控制器 22. ARM芯片内部 定时计数组件看门狗定时器（WDT，WatchDog Timer） Timer通用定时器、 RTC(Real Time Clock)、 脉冲宽度调制器（PWM） 23. ARM芯片内部 可互联通信组件UART、I2C、SPI、CAN、USB、Ethernet 24.嵌入式系统使用的存储器以半导体存储器为主 RAM - SRAM(静态RAM) - DRAM(Dynamic RAM,动态RAM) FRAM、MRAM 闪存技术：NOR Flash和NAND Flash 在性能高的嵌入式处理器中都会集成内部Cache，ARM9和ARM11都有Cache存储器 25.串行外设接口：SPI使用4跳线：SCK、MISO、MOSI和SSEL 采用SPI可以构成“一主一从式”、 “一主多从式”、 “多主多从式”和“互为主从式”系统 26.USB接口提供了内置电源 即插即用、热插拔 USB 2.0采用半双工差分方式传送信息，目前USB2.0的速度为480Mb&#x2F;s，USB3.0达到5Gb&#x2F;s即640MB&#x2F;s 27.8段共阴极LED数码管 段码8段共阴极LED数码管如下图所示，为使其显示数字5，其段代码（高位到低位的顺序是：dp g f e d c b a）为( )。按题目要求，LED为共阴极接法，要显示数字5，则a、f、g、e、d是高，段码应该是01101101，0X6D。 28.实时操作系统 7个特征 (IEEE的实时UNIX分委会) 具有异步I&#x2F;O和中断处理能力； 任务切换时间和中断延迟时间确定； 优先级中断和调度； 抢占式调度； 内存锁定； 连续文件； 同步。 29.嵌入式操作系统 - 强实时型 和 普通实时型强实时嵌入式操作系统有VxWorks，pSOS，μC&#x2F;OS-II 30.单内核结构单内核结构是传统操作系统采用的结构，也称为宏内核（Macro Kernel）。 缺点：占内存空间大，缺乏可扩展性，维护困难，任务执行时间的可预测性较低，可靠性较低，排除故障和增加新功能需要重编译。 优点：应用程序生成效率高，系统花在内核功能切换上的开销非常小，对外来事件反应速度快，操作系统内核的运行效率高。 31.U-Boot以POCBoot和ARMBoot 计划为基础。除了支持Power PC系列处理器外，还支持X86、ARM、Mips、Alpha、IA64、SupcrHSPARC等多种常用体系结构处理器。 32.μC&#x2F;OS-IIμC&#x2F;OS-II是抢占式实时操作系统内核，只能管理64个任务。目前的版本保留8个任务给系统，这样用户编写的应用程序最多可以有56个任务。不支持时间片轮转调度法，因此赋给每一个任务的优先级是不相同的。每个任务拥有自用栈。 33.保护任务之间的共享数据和提供任务之间的通信 的方法：在μC&#x2F;OS-II中有多种方法可以保护任务之间的共享数据和提供任务之间的通信。其中主要有以下三种：利用宏OS_ENTER_CRITICAL()和OS_EXIT_CRITICAL()来关闭中断和打开中断；利用函数OSSchedLock()和OSSchedUnlock()对任务调度函数上锁和开锁；利用信号量、互斥信号量、邮箱和消息队列进行任务间通信。 利用内存文件进行任务间的大规模数据共享是达不到保护任务之间的共享数据的作用。 34.移植μC&#x2F;OS-II到一个嵌入式电路板上正常运行移植μC&#x2F;OS-II到一个嵌入式电路板上正常运行，必须满足以下要求： 处理器的C编译器能产生可重入代码； 用C语言就可以打开和关闭中断； 处理器支持中断，并且能产生定时中断（通常在10~100Hz之间）； 处理器支持能够容纳一定量数据（可能是几千字节）的硬件栈区； 处理器有将栈区指针和其他CPU寄存器读出和存储到栈区或内存中的指令。存储管理单元可以不需要。 35.Nios II软核处理器的硬件抽象层（HAL）系统库 结合Newlib ANSI C标准库，向用户提供熟知的标准库函数； 提供设备驱动，使用户可以访问系统中的所有设备； 为用户提供了与HAL服务相统一的标准接口（HAL API），例如数据访问、中断处理和报警设施； 系统初始化，在main（）函数之前完成软核处理器Nios和运行库环境的初始化任务； 设备初始化，在main（）函数之前完成每个设备的实例化和初始化。 36.IOS的前身是UNIX-BSD37.微内核操作系统微内核操作系统是对单内核做了结构改进后推出的，内核小巧， 传统操作系统内核中的许多部分都被移出内核，采取服务器方式实现； 接口一致，所有进程请求使用统一接口，进程不区分内核模式和用户模式服务； 各个功能模块之间松散耦合，只完成服务功能，系统管理功能交给一个或多个特权服务程序； 微内核功能扩充方便，但是各个功能之间的切换而引起的开销比较大。 38.裸机状态的目标机当然更需要采用 JTAG调试 方式39.采用开发工具的主要目的：提高开发质量，缩短开发周期，降低开发成本 40.ARM处理器所处于的状态ARM状态：所有指令均为32位宽度:； Thunb状态：ARM执行16位指令的状态:； Thunb-2状态是ARMv7版本的ARK处理器所具有的新状态,新的Thunb-2内核技术兼有16位及32位指令长度;除支持Thumb-2的ARM处理器外,其他所有ARM处理器都可以工作在ARM状态. 41.ARM处理器中用作程序计数器PC的通用寄存器是R15；R12是通用寄存器；R13和R14除了用户模式和系统模式分别为堆栈指针(Stack Pointer, SP)和程序链接寄存器(Link Register, LR)之外,其他模式下均有自己独特的标记方式,是专门用于特定模式的寄存器。 42.已知内存0x30000010~0x30000013以大端模式存放一个32位无符号数0xAABBCCDD,R1&#x3D;0x30000010,R0&#x3D;0,执行ARM指令LDRH R0,[R1,#2]之后, R0的值为()。在大端模式（Big-Endian）中，一个32位无符号数0xAABBCCDD存储在内存地址0x30000010到0x30000013中时，其字节顺序是： 12340x30000010: AA0x30000011: BB0x30000012: CC0x30000013: DD LDRH指令用于从内存中加载一个半字（16位）到寄存器中。当执行LDRH R0,[R1,#2]这条指令时，它会从R1指向的地址加上偏移2开始的内存地址读取16位数据。在这个例子中，R1&#x3D;0x30000010，所以它会从0x30000012开始读取。 因此，R0将接收内存地址0x30000012和0x30000013中的16位数据，即CC DD。在ARM架构中，半字数据被加载到寄存器的低16位，而高16位则保持不变（通常为零）。由于R0初始值为0，所以执行该指令后： 1R0 = 0x0000CCDD 这是将16位的CC DD加载到R0后的结果，其中CC是高8位，DD是低8位。 43.除了大端模式，还有什么别的模式吗？是的，除了大端模式（Big-Endian），还存在另一种字节序模式，即小端模式（Little-Endian）。这两种模式是计算机存储多字节数据时的两种不同方式： 大端模式（Big-Endian）： 在大端模式中，多字节数据的最高有效字节（MSB）存储在最低的内存地址处，接下来是次高有效字节，以此类推，最低有效字节（LSB）存储在最高的内存地址处。 例如，对于32位的数据0x12345678，在大端模式下存储为：12340x30000010: 0x120x30000011: 0x340x30000012: 0x560x30000013: 0x78 小端模式（Little-Endian）： 在小端模式中，多字节数据的最低有效字节（LSB）存储在最低的内存地址处，接下来是次低有效字节，以此类推，最高有效字节（MSB）存储在最高的内存地址处。 同样以32位的数据0x12345678为例，在小端模式下存储为：12340x30000010: 0x780x30000011: 0x560x30000012: 0x340x30000013: 0x12 大多数现代计算机系统和微处理器，如x86架构，使用小端模式存储数据，而一些其他系统，如网络协议、某些UNIX系统V应用二进制接口（ABI）、以及一些特定的处理器（如Motorola 68000系列）则使用大端模式。 在实际应用中，开发者需要根据目标系统的字节序来正确地读取和解释数据。例如，网络协议通常使用大端模式，而许多个人电脑和服务器则使用小端模式。在进行跨平台数据交换时，字节序问题尤其重要，需要确保数据在不同字节序的系统间正确地转换和解释。 44.ARM指令LDRH 对字节的操作 填空：1.IP核是什么？IP核的分类IP核，全称为Intellectual Property Core，即知识产权核，是集成电路设计中预先设计、经过验证、可重复使用的具有特定功能的模块。这些模块可以是电路的一部分，也可以是整个系统的设计，它们包含了设计所需的关键信息，如逻辑功能、行为描述、代码等。使用IP核可以显著提高设计效率、缩短设计周期、降低开发成本。 IP核的分类主要有三种： 软核（Soft IP Core）：软核是用硬件描述语言（如VHDL或Verilog）编写的代码，它们描述了电路的功能，但不包含具体的物理实现细节。软核的灵活性最高，因为它们可以在不同的工艺节点和不同的设计中重复使用，但可能需要更多的时间和资源来集成和优化。 固核（Firm IP Core）：固核是介于软核和硬核之间的一种形式，它们通常提供了一些布局布线信息，但仍然允许一定程度的灵活性。固核可能包括一些预布局的关键信号路径，以确保特定的时序要求得到满足。 硬核（Hard IP Core）：硬核是已经完成布局布线、具有特定工艺实现的IP。它们通常提供最佳的性能和功耗优化，但牺牲了设计的灵活性，因为硬核是为特定的工艺技术定制的，不易移植到其他工艺中。 除了上述三种主要分类，还有一些特殊的IP核，如嵌入式微处理器IP核，它们通过在FPGA中实现微处理器的逻辑功能，为嵌入式软件设计者提供了在FPGA上开发程序的平台。 在管理IP核时，可能会面临可见性有限、环境复杂等挑战，因此需要有效的IP管理策略和工具来确保IP核的可追溯性和安全性。例如，Perforce公司的Methodics IPLM就是用于IP管理的解决方案之一，它帮助实现IP的可追溯性和安全性。 半导体IP核的应用领域非常广泛，包括消费电子、电信、工业、汽车、商业等，随着技术的发展，智能汽车、AI等领域对IP核的需求日益增长。此外，随着Chiplet技术和RISC-V架构的发展，IP核在集成电路产业中的作用越来越重要，它们为芯片设计提供了新的可能性和灵活性。 2.计算存储器容量65536色 &#x3D; 2^16 &#x3D; 16位 &#x3D; 2B B - KB - MB - GB - TB\t1024 - 1 3.WLAN-无线局域网WLAN是无线局域网（Wireless Local Area Network）的缩写，它是一种利用无线通信技术在局部范围内实现网络连接的方法。WLAN允许电子设备通过无线信号在没有物理网络连接的情况下相互连接和通信。以下是WLAN的一些关键特点和组成部分： 无线标准：WLAN技术遵循特定的国际标准，如IEEE 802.11系列标准。这些标准定义了无线网络的通信协议、频率、数据传输速率和其他技术细节。 频率范围：WLAN通常在2.4 GHz、5 GHz或60 GHz的ISM（工业、科学、医疗）频段上运行，这些频段在全球范围内免费供公众使用。 接入点（AP）：无线接入点是WLAN网络的核心组件，它充当无线网络和有线网络之间的桥梁。接入点负责将无线信号转换为有线信号，并连接到互联网或其他网络资源。 客户端设备：笔记本电脑、智能手机、平板电脑等设备通常内置有WLAN网卡，使它们能够无线连接到网络。 安全性：WLAN使用各种安全协议来保护数据传输，如WEP（有线等效保密）、WPA（Wi-Fi保护访问）、WPA2和最新的WPA3。 应用场景：WLAN广泛应用于家庭、办公室、学校、机场、咖啡店等场所，提供无线上网服务。 速度和范围：WLAN的数据传输速率和覆盖范围取决于多种因素，包括无线标准、设备能力、物理障碍物、干扰等。 漫游：在一些大型WLAN网络中，如企业或校园网络，用户可以在不同接入点之间无缝切换，这称为漫游。 配置和管理：WLAN网络可以通过专门的软件进行配置和管理，包括用户认证、网络监控、性能优化等。 随着技术的发展，WLAN已经成为现代生活中不可或缺的一部分，为人们提供了极大的便利和灵活性。 WLAN所采用的主要通信协议是802. 11;数据传输速率可达到11 Mbps、 54Mbps、 108Mbps甚至更高。 4.ARM处理器的7种异常及相应优先级在ARM架构中，处理器支持多种异常模式，这些异常模式用于处理不同的系统事件和错误条件。ARM7处理器支持7种异常模式，每种模式都对应一个特定的异常处理程序，这些处理程序被称为异常向量。当异常发生时，处理器会自动切换到相应的模式，并从异常向量表中的固定地址开始执行异常处理程序。 ARM7处理器的7种异常及其优先级如下： Reset (复位) - 这是最高优先级的异常，用于系统启动或复位时的初始化。 Undefined Instruction (未定义指令) - 当处理器尝试执行一个未定义的指令时触发。 Software Interrupt (软件中断) - 由SWI指令触发，通常用于操作系统的系统调用。 Prefetch Abort (预取中止) - 当处理器尝试获取一个无法访问的指令时触发。 Data Abort (数据中止) - 当处理器尝试进行非法的数据访问时触发。 Reserved (保留) - 这个异常向量地址是保留的，不用于任何异常处理。 Interrupt Request (中断请求) - 用于响应外部或内部的中断请求。 Fast Interrupt Request (快速中断请求) - 用于需要快速响应的中断，如直接内存访问(DMA)。 每种异常模式都有固定的优先级，其中Reset具有最高的优先级，而其他异常则根据需要和设计有不同的优先级设置。在多任务或多中断源的系统中，优先级设置非常重要，它决定了在多个异常同时发生时，哪个异常处理程序将首先被执行。 在ARMv7架构中，异常处理程序通常由向量表中的入口地址指定，该表在内存中有一个固定的起始位置。当异常发生时，处理器会自动跳转到对应的入口地址执行异常处理程序。异常处理程序执行完毕后，处理器会返回到异常发生前执行的指令。 请注意，ARM架构随着版本的不同，支持的异常类型和处理方式可能会有所变化。例如，在ARMv6和ARMv7架构中，异常处理机制相对简单，而在ARMv8架构中，引入了更复杂的异常级别和安全状态，以支持更高级的操作系统和安全需求。上述信息主要基于ARMv7架构。 5.CortexCortex-A 尖端 Cortex-R 实时应用 Cortex-M 控制 6.Thumb-2指令集Thumb-2指令集是ARM架构中的一部分，它是为了提高代码密度和执行效率而设计的。Thumb-2在ARMv6T2架构及以上版本中被引入，包括ARMv7-A架构。Thumb-2指令集通过使用16位和32位的变长指令来提高代码的紧凑性，同时保持与ARM指令集的兼容性。 Thumb-2指令集的主要特点包括： 条件执行：Thumb-2指令集中的大多数指令都可以进行条件执行，这减少了分支指令的开销，并通过使用IT（如果-那么）指令来实现复杂的条件执行序列。 寄存器访问：Thumb-2指令可以访问全部的32个通用寄存器（R0-R15），而早期的Thumb指令集只允许访问R0-R7。 指令集扩展：Thumb-2增加了对32位指令的支持，这使得它能够执行更复杂的操作，同时保持了与ARM指令集的兼容性。 统一汇编语言：Thumb-2支持统一汇编语言（UAL），这意味着同一段代码可以生成Thumb或ARM指令，从而简化了编程和代码维护。 与ARM指令集的兼容性：Thumb-2指令集设计为与ARM指令集完全兼容，允许在两种模式之间无缝切换。 优化的中断和异常处理：Thumb-2提供了优化的中断和异常处理能力，这对于实时操作系统和嵌入式系统非常重要。 Thumb-2指令集在ARMv7架构中得到了广泛应用，它为开发者提供了更高的灵活性和效率，特别是在资源受限的环境中，如嵌入式系统和移动设备。随着ARM架构的发展，Thumb-2指令集也在不断地得到增强和扩展，以满足不断增长的性能和功能需求。 开关中断指令属于程序状态类指令,用于更改处理器状态。关外部中断使用的指令为: CPSID I,开外部中断的指令为: CPSIE I。 Change Processor State 7.ARM 寄存器问：已知ARM处理器R1&#x3D;0x12345678, R2&#x3D;0xFF008899,则执行指令AND R0,R1,R2后,寄存器R0&#x3D; , R1&#x3D; 解：ARM 指令 AND R0, R1, R2 执行的是逻辑与（AND）操作。它会将寄存器 R1 和 R2 的内容进行按位与操作，并将结果存储在 R0 中。R1 的值不会改变，因为它不是该操作的目标寄存器。 给定的寄存器值如下： R1 &#x3D; 0x12345678 R2 &#x3D; 0xFF008899 按位与操作的规则是，只有两个相应的位都为 1 时结果才为 1，否则为 0。 我们可以将两个寄存器的值转换为二进制形式，然后进行按位与操作： R1 &#x3D; 0x12345678 &#x3D; 0001 0010 0011 0100 0101 0110 0111 1000 (二进制) R2 &#x3D; 0xFF008899 &#x3D; 1111 1111 0000 0000 1000 1000 1001 1001 (二进制) 执行按位与操作：（同1为1,否则为0） 1234 0001 0010 0011 0100 0101 0110 0111 1000&amp; 1111 1111 0000 0000 1000 1000 1001 1001----------------------------------------- 0001 0010 0000 0000 0000 0000 0001 1000 将上述二进制结果转换回十六进制： R0 &#x3D; 0x12000018 因此，执行指令 AND R0, R1, R2 后，寄存器 R0 的值为 0x12000018，而 R1 的值不变，仍为 0x12345678。 8.ARM 调用 子程序已知ARM处理器R1&#x3D;0x12345678, R2&#x3D;0xFF008899,则执行指令AND R0,R1,R2后,寄存器R0&#x3D; , R1&#x3D; 在 ARM 汇编语言中，调用子程序通常使用 BL （Branch with Link）指令。这条指令会将返回地址（即子程序返回后继续执行的地址）保存在链接寄存器 LR 中，然后跳转到子程序的地址执行。 调用子程序 MySubroutine 的指令为： 1BL MySubroutine 子程序执行完毕后，要返回调用程序，通常使用 BX 指令配合链接寄存器 LR。在子程序的末尾，可以放置以下指令来返回调用程序： 1BX LR 这条指令会使程序跳转到 LR 寄存器中存储的地址继续执行，即返回到调用子程序的地方。在 ARMv7 架构中，也可以使用 MOV 指令将 LR 的值移动到 PC（程序计数器）来实现返回： 1MOV PC, LR 在某些情况下，如果子程序非常短，也可以直接使用 B 指令返回，但这通常不推荐，因为它不会更新 LR 寄存器，可能会影响其他复杂的调用和返回流程。 总结： 调用子程序的指令：BL MySubroutine 子程序返回调用程序的指令：BX LR 或 MOV PC, LR 9.AMBA总线AMBA（Advanced Microcontroller Bus Architecture）是由ARM公司推出的一种高级微控制器总线架构，它定义了一种片上通信标准，用于设计高性能嵌入式微控制器。AMBA总线规范主要包括以下几种不同的总线： AHB（Advanced High-performance Bus）：这是AMBA体系中的核心总线，专为连接高性能模块而设计，如处理器、片上存储器和外部存储器接口。AHB支持高速数据传输和多种工作模式，具备较大的数据总线带宽，适用于对速度和效率要求较高的系统。 ASB（Advanced System Bus）：ASB是高性能系统总线，主要为高性能系统模块之间的连接提供解决方案。它在不需要AHB时可用，能够有效连接处理器和内存，同时保持高效的性能。 APB（Advanced Peripheral Bus）：APB是低功耗和简单接口的选择，适合连接外围设备和系统总线。它的特点是低能耗和简化的设计，适合连接诸如定时器、ADC等外围功能，对于电源管理优化的系统非常适用。 AMBA总线规范的发展历程包括了多个版本，从最初的AMBA 1.0（包含ASB和APB）到后来的AMBA 2.0（新增了AHB总线），再到AMBA 3.0（引入了AXI），以及后续的AMBA 4和AMBA 5。每个新版本的推出都伴随着新特性和性能的提升，以适应不断增长的系统需求。 在系统设计中，开发者需要根据应用的需求和功耗限制来决定采用哪种总线结构。例如，如果需要高数据传输速率和处理能力，AHB是首选；对于高性能但对功耗有严格要求的系统，ASB可能更为合适；而APB则适合连接那些对性能要求不高但需要节能的外设。 AMBA总线规范提供了嵌入式系统设计者所需的关键信息，帮助他们构建高效、低功耗且可扩展的系统架构，适应不断发展的电子技术需求。 10.嵌入式系统的存储器嵌入式系统的存储器以半导体存储器为主， FRAM - Ferroelectric Random Access Memory - 铁电随机存取存储器 MRAM - Magnetic Random Access Memory - 磁性随机存取存储器 存储器芯片的容量完全取决于存储器芯片的地址线条数和数据线的位数 11.I^2C 总线I2C总线被启动后,多个主机在每发送一个数据位时都要对SDA信号线电平进行检测,只要检测的电平与自己发出的电平相同就会继续占用总线。总线的控制遵循“低电平优先”的原则。 12.UART 构成UART（Universal Asynchronous Receiver&#x2F;Transmitter，通用异步收发传输器） UART由发送器、接收器、控制单元及波特率发生器等构成。 13.嵌入式系统与通用计算机系统软件的相同之处嵌入式系统通常也具备引导加载程序，外设驱动程序，操作系统，文件系统，网络协议栈，图形用户界面，数据库，以及各种各样的应用程序等。 14.基于操作系统的外围工具软件运行在嵌入式系统上，往往具有内部结构精简，代码轻量化 ，占用存储资源少的特点。 15.实时系统的两种任务时限:截止时间：任务开始执行时间到任务必须完成的时间间隔。 任务执行预设时间&#x2F;任务最快完成时间：这是无中断响应情况下的任务最快执行时间。 16.实时系统可预测性：实时系统对时间约束要求的严格性,使可预测性成为实时系统的一项重要性能要求,它是**指RTOS能够对 外部事件的响应时间 和 实时任务的执行时间 **进行判断,以确定被事件触发的实时任务能否在规定的时间内完成。 17.实时系统按响应时间分类强实时系统：其响应时间一般在毫秒级或微秒级； 普通实时系统：其响应时间一般在秒级； 弱实时系统：其响应时间一般在数十秒级。 18.嵌入式系统的开发过程：通常分为4个阶段 需求分析与规格说明、 系统设计、 构件设计、 系统集成与测试 19.嵌入式系统的开发工具软件GCC的命令及参数在Linux操作系统下开发该目标机的Linux应用程序，通常使用 arm-linux-gcc 交叉编译器来编译应用程序。 对一个应用程序进行调试排错：在编译命令中加 g 参数对它进行编译。 综合： 设计电路、采用部件 寄存器读写地址、采用引脚 相关驱动程序：初始化引脚语句 初始化UART2&#x2F;UART1 初始化寄存器 采样频率，存储容量 构建软件平台 家庭网关上的应用程序设计、编程语言 下面是试题解答时需要用到的寄存格式及相关说明： 1.嵌入式最小硬件系统： 嵌入式处理器 时钟电路 电源电路 复位电路 存储器 调试测试接口 2.通信接口：UARTchu 3.已知谐波频率范围求最小采样频率：范围内最大频率*2（根据香农定律） 4.已知频率，采集信号，采集时间，求存储容量最小采样频率*时间(按秒算)，再 进制转换(可能会有四舍五入) 5.嵌入式系统由硬件和软件两部分组成；硬件部分的主体是中央处理器和存储器；它们通过输入&#x2F;输出(I&#x2F;O)接口与外部世界联系。 6.数字图像：JPEG采用有损压缩方法，压缩率较高，在数码相机&#x2F;互联网&#x2F;计算机 中广泛使用。 GIF采用无损压缩方法，图像的颜色数目较少，文件特别小，适合在网页中作为插图或剪切贴使用。 7.构建无线网的技术： 802.11(WiFi) 蓝牙：最高数据传输速率在1Mbps左右，传输距离大约在10m之内。 8.简单的汇编指令操作： MOV - move - 移动数据 原理：将数据从一个位置（寄存器或内存地址）移动到另一个位置。 例子：MOV AX, BX 将寄存器BX的内容复制到寄存器AX。 ADD - add - 相加 原理：将两个数相加，并将结果存储在其中一个操作数的位置。 例子：ADD AX, BX 将寄存器BX的内容加到寄存器AX的内容上，并将结果存储在AX中。 SUB - subtract - 相减 原理：从一个数中减去另一个数，并将结果存储在第一个操作数的位置。 例子：SUB AX, BX 从寄存器AX的内容中减去寄存器BX的内容，并将结果存储在AX中。 MUL - multiply - 乘法 原理：将两个数相乘，并将结果存储在指定的寄存器中。 例子：MUL BX 将寄存器AX的内容与寄存器BX的内容相乘，并将结果存储在AX中（对于16位操作数）。 DIV - divide - 除法 原理：将一个数除以另一个数，并将商存储在指定的寄存器中。 例子：DIV BX 将寄存器AX的内容除以寄存器BX的内容，并将商存储在AX中，余数存储在DX中（对于16位操作数）。 PUSH - 入栈 原理：将数据压入栈中，栈顶指针（SP）会自动减小，为新的栈顶位置。 例子：PUSH AX 将寄存器AX的内容压入栈中。 POP - 出栈 原理：从栈中弹出数据，栈顶指针（SP）会自动增加，指向新的栈顶位置。 例子：POP AX 从栈中弹出数据到寄存器AX。 JMP - jump - 无条件跳转 原理：跳转到指定的内存地址继续执行指令。 例子：JMP Label 跳转到标签Label处继续执行。 CALL - 调用过程 原理：调用一个过程（函数），并将下一条指令的地址压入栈中，然后跳转到过程的起始地址。 例子：CALL Function 调用名为Function的过程。 RET - return - 返回过程 原理：从栈中弹出返回地址并跳转到该地址，结束过程调用。 例子：RET 返回到调用过程的地方继续执行。 CMP - comparison - 比较 原理：比较两个数，但不存储结果，而是根据比较结果设置标志寄存器。 例子：CMP AX, BX 比较寄存器AX和BX的内容，但不存储结果。 AND, OR, XOR - 逻辑运算 (XOR:Exclusive OR) 原理：执行逻辑运算，并将结果存储在第一个操作数的位置。 例子： AND AX, BX 执行逻辑与操作。 OR AX, BX 执行逻辑或操作。 XOR AX, BX 执行逻辑异或操作。"},{"title":"MMD","path":"/MMD/","content":"模型：佬YYB【【模型配布_YYB式Miku_NT ＆ Miku_default】Primary Star】 https://www.bilibili.com/video/BV1Bg411D7Me/?share_source=copy_web&amp;vd_source=a9248fac1911da7678699a591ef91b0c BowRoll网站 YYB模型下载YYB Hatsune Miku_NT - BowlRoll 使用blenderblender4.0 导入MMD模型 – mmd-tools - 哔哩哔哩 (bilibili.com) MMD插件UuuNyaa&#x2F;blender_mmd_tools: MMD Tools is a blender addon for importing&#x2F;exporting Models and Motions of MikuMikuDance. (github.com) https://wwi.lanzoul.com/iBdSz264heed 上面的蓝奏云 MMD Tools&#x2F;手册 |MMD &amp; Blender 维基 |影迷 (fandom.com) 该插件使用手册 模型着色【bender导入mmd模型和动作，最快工作流来了！】 https://www.bilibili.com/video/BV1Cm421G7FV/?share_source=copy_web&amp;vd_source=a9248fac1911da7678699a591ef91b0c 1:30 动作：佬MaSalty人生リセットボタンぽち―wモーション配布 - BowlRoll 密码：沙花叉クロヱ 通过网盘分享的文件：MMD链接: https://pan.baidu.com/s/1qzK4Qi0y7v-kejn--t4rbA 提取码: npju–来自百度网盘超级会员v3的分享 MMD资源站： BowRoll:https://bowlroll.net/ 模之屋:https://www.aplaybox.com/ MMD教程： blender做MMD心得（一） - euph - 博客园 (cnblogs.com) 最系统的MMD零基础入门教程宝典 - 知乎 (zhihu.com) 借物表：当你在制作MMD视频并准备借物表时，应该包括以下信息： 模型（Model）：模型的名称和作者。 动作（Motion）：动作数据的名称和作者。 镜头（Camera）：镜头的名称和作者。 场景（Stage）：场景的名称和作者。 纹理&#x2F;材质（TEX）：使用到的纹理或材质的作者。 音乐（Music）：音乐的名称和演唱者或作曲者。 渲染效果（Effect）：使用的渲染效果插件或脚本的名称和作者。 使用工具（Tool）：制作过程中使用到的软件工具名称。 MMD - MikumikuDance 可能是官方下载网站：下载 - 学习 MikuMikuDance - MMD 教程 - 免费 3D 动画软件 (learnmmd.com) ayaka-mmd (github.com)"},{"title":"git","path":"/git/","content":"手把手教你用git上传项目到GitHub（图文并茂，这一篇就够了），相信你一定能成功！！ - 知乎 (zhihu.com) MINGW64 &#x2F;d&#x2F;Documents&#x2F;Output&#x2F;Project MZ&#x2F;www (master) 1$ git init 1$ git add . 1$ git commit -m &quot;提交文件&quot; 1$ git remote add origin git@github.com:immortal3180/Project_RPG.git 1$ git push -u origin main 123456git init //把这个目录变成Git可以管理的仓库git add README.md //文件添加到仓库git add . //不但可以跟单一文件，还可以跟通配符，更可以跟目录。一个点就把当前目录下所有未追踪的文件全部add了 git commit -m &quot;first commit&quot; //把文件提交到仓库git remote add origin git@github.com:wangjiax9/practice.git //关联远程仓库git push -u origin main //把本地库的所有内容推送到远程库上 RPGMAKER MZ 部署更新流程 12345git initgit add .git commit -m &quot;20240918 commit&quot;git remote add origin git@github.com:immortal3180/Project_RPG.gitgit push -u/--force origin master"},{"title":"Android-Studio","path":"/Android-Studio/","content":"下载 Android Studio 和应用工具 - Android 开发者 | Android Developers (google.cn)"},{"title":"live2d","path":"/live2d/","content":"给hexo博客添加Live2d小人1.安装 hexo-helper-live2d 插件 1npm install --save hexo-helper-live2d 2.在根目录下config.yml 添加以下代码 123456789101112131415161718192021# live2dlive2d: enable: true # 是否启动 scriptFrom: local # 默认 pluginRootPath: live2dw/ # 插件在站点上的根目录(相对路径) pluginJsPath: lib/ # 脚本文件相对与插件根目录路径 pluginModelPath: assets/ # 模型文件相对与插件根目录路径 tagMode: false # 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中 debug: false # 调试, 是否在控制台输出日志 model: use: nepmaid ## 模型文件 display: position: right # 定位方向 left right top bottom width: 150 # 小人宽度 height: 300 # 小人高度 hOffset: -15 # 向 偏移 vOffset: -15 # 像 偏移 mobile: show: false # 手机端是否显示 react: opacity: 0.7 # 模型透明度 3.EYHN&#x2F;hexo-helper-live2d: Add the Sseexxyyy live2d to your hexo! (github.com)上下载live2d-widget-models-master包 4.在根目录下新建名为live2d_models的文件夹，复制 live2d-widget-models-master &gt; packages &gt; 中任意模型包到该文件夹下，如该图为miku模型 5.回到 config.yml 12model: use: live2d-widget-model-miku ## 改为你使用的模型文件名"},{"title":"英语笔记","path":"/English/","content":"第一节 第二节"},{"title":"大学物理学笔记","path":"/Physics/","content":"第一节课： 1.物质的基本结构 字宙(930亿光年)&lt;-星系&lt;-地星&lt;-行星 卫星&lt;-物质&lt;-分子&lt;-原子&lt;-原子核 电子(轻子)&lt;-质子 中子(重子)&lt;-夸克 上行夸克：上夸克顶夸克絮夸克 下行夸克：下夸克底夸克奇异夸克 基本粒子：62种 夸克：36种 第二节课： 第三节课： 第四节课："},{"title":"STM32 产品资料","path":"/STM32/","content":"ST 相关ST 官网 www.STcom.cn STM32 中文官网 www.STMCU.com.cn STM32中文技术支持邮箱 mpu.china@stcom mcu.chinaost com 大学计划联络邮箱: &#x65;&#x64;&#117;&#x63;&#x68;&#105;&#x6e;&#97;&#64;&#x73;&#x74;&#x2e;&#99;&#x6f;&#x6d; ST中文论坛: shequ.stmicroelectronics.cn STCommunity 全球论坛 https://community.st.com/s/ STM32 21ic论坛 http://www.21ic.com/stm32 STM32 MCUs Wiki页面 wiki.st.com&#x2F;stm32mcu STM32 MPUs Wiki 页面 wiki.st.com&#x2F;stm32mpu STM32 GitHub页面 github.com&#x2F;STMicroelectro NUCLEO-U5A5ZJ-Q 资料STM32U5A5ZJ - Ultra-low-power with FPU Arm Cortex-M33 MCU with TrustZone, 160 MHz with 4 Mbytes of Flash memory - STMicroelectronics NUCLEO-U5A5ZJ-Q - STM32 Nucleo-144开发板，带STM32U5A5ZJ MCU、SMPS，支持Arduino、ST Zio和morpho连接 - 意法半导体STMicroelectronics STM32CubeU5 - STM32Cube MCU Package for STM32U5 series （HAL， Low-Layer APIs and CMSIS， USB， File system， RTOS， TF-M - 附带在意法半导体板上运行的示例） - 意法半导体STMicroelectronics ST 微控制器与微处理器ST MCU (STM32 ARM Cortex 32位微控制器) 产品家族 (下图截选日期2024.9.4)"},{"title":"数据库系统概论笔记","path":"/database/","content":"主要摘自 数据库系统概论(第6版) - 王珊 杜小勇 陈红 编著 数据(data)描述事物的符号记录。是数据库中存储的基本对象。 数据的含义称为数据的语义，数据与其语义是不可分的。 数据库(database，DB)是长期存储在计算机内有组织、可共享的大量数据的集合。(按一定的格式存放数据的仓库) 数据库管理系统包含 数据定义功能(数据定义语言(data definition language，DDL))、数据组织、存储和管理功能、数据操纵功能(数据操纵语言(data manipulation languageDML))、数据库的事务管理和运行管理功能、数据库的建立和维护功能 的，位于用户与操作系统之间的数据管理软件。 数据库系统database system，DBS)指由 数据库、数据库管理系统(及其应用开发工具)、应用系统和数据库管理员(database administrator，DBA)组成的存储、管理、处理和维护数据的系统 数据建模(data modeling)把现实世界中的具体事物抽象、组织为某一数据库管理系统支持的数据模型，这个过程称为数据建模(data modeling)。 概念模型用于信息世界的建模，是现实世界到机器世界的一个中间层次。 关系模型建立在严格的数学概念基础之上，由一组关系组成，每个关系的数据结构是一张规范化的二维表。 关系(relation):一个关系对应通常说的一张二维表。 元组(tuple):表中的一行即为一个元组。 属性:表中的一列即为一个属性，每列的名称即为属性名。 码:又称为码键或键，是表中的某一个属性或一组属性，其值可以唯一确定一个元组。 域(domain):域表示某一属性的取值范围。 分量(component):元组中的一个属性值。 关系模式:对关系的描述，一般表示为:关系名(属性1,属性2,·,属性n)。 关系模型要求关系必须是规范化(normalization)的。关系的每一个分量必须是一个不可分的数据项。 优点： 关系模型建立在严格的数学概念基础上。 关系模型的概念单一。 关系模型的存取路径对用户隐蔽。 缺点： 存取路径对用户是隐蔽的，其查询效率往往不如层次模型和网状模型。 为了提高性能，关系数据库管理系统必须对用户的查询请求进行优化，因此增加了开发关系数据库管理系统的难度。 数据库系统的三级模式结构模式、外模式和内模式 三级模式结构。 这三级模间提供了两级映像: 外模式&#x2F;模式映像和模式&#x2F;内模式映像。这两级映像保证了数据库系统中的数据能够具有较强的逻辑独立性和物理独立性"},{"title":"OpenCV-Python 文档汉化","path":"/OpenCV-Python/","content":"OpenCV-Python Tutorials - OpenCV-Python 教程Gui Features in OpenCV - OpenCV的Gui特性(在这里，您将学习如何显示和保存图像和视频，控制鼠标事件和创建跟踪栏。) OpenCV-Python 图像处理入门上一篇教程: Building OpenCV for Tegra with CUDA下一篇教程: Writing documentation for OpenCV 原作者 Ana Huamán 兼容性 OpenCV &gt;&#x3D; 3.4.4 警告 ​ 本教程可能包含过时的信息。 目标在本教程中，您将学习如何: 从文件中读取图像 (使用 cv::imread) 在 OpenCV 窗口中显示图像 (使用 cv::imshow) 将图像写入文件 (使用 cv::imwrite) 源代码 可下载的源代码: Click here 代码如下: 1234567891011121314import cv2 as cvimport sysimg = cv.imread(cv.samples.findFile(&quot;starry_night.jpg&quot;))if img is None:\tsys.exit(&quot;Could not read the image./找不到图像.&quot;)cv.imshow(&quot;Display window&quot;, img)k = cv.waitKey(0)if k == ord(&quot;s&quot;):\tcv.imwrite(&quot;starry_night.png&quot;, img) 解释作为第一步，导入OpenCV python库。正确的方法是额外为其分配名称 cv，该名称在下面的代码中用于引用库。 12import cv2 as cvimport sys 现在，让我们分析一下主代码。作为第一步，我们从 OpenCV 样本读取图像”starry_night.ipg”。为了做到这一点，调用 cv::imread 函数使用第一个参数指定的文件路径加载图像。第二个参数是可选的，它指定了我们想要的图像格式。这可能是: IMREAD_COLOR 以 BGR 8位格式加载图像. 这是这里使用的默认值。 IMREAD_UNCHANGED 按原样加载图像(包括alpha通道，如果它存在的话) IMREAD_GRAYSCALE 以灰度图形式加载图像 读取后的图像数据将存储在 cv::Mat 对象中。 1img = cv.imread(cv.samples.findFile(&quot;starry_night.jpg&quot;)) 注意 OpenCV 提供了对 Windows位图(bmp)图像格式，便携式图像格式(pbm, pgm, ppm) 和 Sun raster(sr, ras)的支持。您也可以借助插件 (你需要在自行构建库时指定使用它们，不过在我们提供的包中，这些功能默认是包含的) 来加载如 JPEG (jpeg, jpg, jpe), JPEG 2000 (jp2 - codenamed in the CMake as Jasper), TIFF files (tiff, tif) 以及 portable network graphics (png) 一类的图像格式。 此外，OpenEXR也是一种可能性。 之后，如果映像加载正确，则执行检查。 12if img is None:\tsys.exit(&quot;Could not read the image.&quot;) 然后，调用 cv::imshow 函数以显示图像。第一个参数是窗口的标题，第二个参数是将要显示的 cv::Mat 对象。 因为我们想要让我们的窗口直到用户按下任意按键前一直显示(否则这个项目会结束得太快)，我们使用 cv::waitKey 函数，它的唯一参数是等待用户输入的时间(以毫秒为单位)。0表示永远等待。返回值是按下的键。 12cv.imshow(&quot;Display window&quot;, img)k = cv.waitKey(0) 最后，如果按下的键是“s”键，则将图像写入文件。为此 cv::imwrite 函数被调用，其中包含文件路径和 作为一个参数的 cv::Mat 函数 12if k == ord(&quot;s&quot;):\tcv.imwrite(&quot;starry_night.png&quot;, img) [^注]: 本文翻译最初编辑于 2024.08.26，最终编辑于 2024.09.07 OpenCV-Python 视频处理入门目标 学习读取视频，显示视频，保存视频。 学习从相机捕捉视频并显示。 您将学习这些函数 : cv.VideoCapture(), cv.VideoWriter() 从摄像机捕捉视频通常，我们必须用摄像机捕捉实时视频流。OpenCV 提供了一个非常简单的接口来做到这一点。让我们从摄像机中捕捉一段视频 (我用的是笔记本电脑的内置摄像头)，转换成灰度视频并显示。这只是一个简单的开始任务。 要捕获视频，需要创建一个 VideoCapture 对象。它的参数可以是设备索引或视频文件的名称。设备索引只是指定哪个相机的数字，通常会连接一台相机(就像我的情况一样)，所以我只用参数0(或-1)。您可以用参数1来选择第二个摄像机，以此类推。之后，您可以逐帧捕获。但最后，别忘了释放捕捉到的画面。 12345678910111213141516171819202122232425import numpy as npimport cv2 as cvcap = cv.VideoCapture(0)if not cap.isOpened(): print(&quot;Cannot open camera&quot;) exit()while True: # Capture frame-by-frame / 获取一帧 ret, frame = cap.read() # if frame is read correctly ret is True / 如果frame被正确读取，ret为True if not ret: print(&quot;Can&#x27;t receive frame (stream end?). Exiting ...&quot;) break # Our operations on the frame come here / 我们对坐标系的操作到这里 gray = cv.cvtColor(frame, cv.COLOR_BGR2GRAY) # Display the resulting frame cv.imshow(&#x27;frame&#x27;, gray) if cv.waitKey(1) == ord(&#x27;q&#x27;): break# When everything done, release the capture / 当一切完成后，释放捕获cap.release()cv.destroyAllWindows() cap.read() 返回一个bool值 (True&#x2F;False)。如果帧读取正确该值将变为 True. 所以你可以通过检查这个返回值来检查视频是否结束。 有时，cap可能没有初始化捕获。在这种情况下，这段代码显示了一个错误。你可以通过 **cap.isOpened() **方法来检查它是否已经初始化。如果返回值为 True, 那么OK。否则使用 cap.open() 打开它。 您还可以使用 cap.get(propId) 方法访问本视频的一些功能，propld 为0 ~ 18之间的数字。每个数字代表视频的一个属性 (如果它适用于该视频)。完整的细节可以在这里看到: cv::VideoCapture::get()。其中一些值可以使用 cap.set(propId, value) 修改。Value is the new value you want. 例如，我可以通过 cap.get(cv.CAP_PROP_FRAME_WIDTH) 和 cap.get(cv.CAP_PROP_FRAME_HEIGHT) 检查帧的宽度和高度。它默认是 640x480。但我想将它改为 320x240，只需使用 ret = cap.set(cv.CAP_PROP_FRAME_WIDTH,320) 和 ret = cap.set(cv.CAP_PROP_FRAME_HEIGHT,240). 注意 如果你的代码报错，可能是你的相机正在使用任何其他相机应用程序工作 (比如 Linux 中的 Cheese)。 从文件播放视频从文件中播放视频和从相机中捕获视频是一样的，只需将相机索引更改为视频文件名。在显示框架时也是如此，为 cv.waitKey() 选择适当的时间。如果它太小，视频将非常快，如果它太高，视频将很慢 (嗯，这就是如何用慢动作显示视频的方法)。在正常情况下，25毫秒就可以了。 1234567891011121314151617181920import numpy as npimport cv2 as cvcap = cv.VideoCapture(&#x27;vtest.avi&#x27;)while cap.isOpened(): ret, frame = cap.read() # if frame is read correctly ret is True if not ret: print(&quot;Can&#x27;t receive frame (stream end?). Exiting ...&quot;) break gray = cv.cvtColor(frame, cv.COLOR_BGR2GRAY) cv.imshow(&#x27;frame&#x27;, gray) if cv.waitKey(1) == ord(&#x27;q&#x27;): breakcap.release()cv.destroyAllWindows() 注意 确保安装了正确版本的 ffmpeg 或 gstreamer。有时使用视频捕捉是一件令人头疼的事情，主要是由于错误安装 ffmpeg&#x2F;gstreamer。 保存视频所以我们捕捉一段视频并逐帧处理，然后我们想保存这个视频。对于图像，它非常简单：只需使用 cv.imwrite()。 这里，还需要再多做一点工作。 这次我们创建一个 VideoWriter 对象。我们应该指定输出文件名 (如:output.avi)。然后我们应该指定 FourCC 代码 (详情见下一段)。然后应该传递每秒帧数(fps)和帧大小。最后一个是 isColor 标志。 如果它的值为 True，编码器期望彩色帧，否则它适用于灰度帧。 FourCC 是一个用于指定视频编解码器的 4-byte 代码。可用代码的列表可以在 fourcc.org 上找到。它依赖于平台。以下编解码器对我来说很好。 In Fedora: DIVX, XVID, MJPG, X264, WMV1, WMV2. (XVID is more preferable. MJPG results in high size video. X264 gives very small size video) In Windows: DIVX (More to be tested and added) In OSX: MJPG (.mp4), DIVX (.avi), X264 (.mkv). FourCC code is passed as ‘cv.VideoWriter_fourcc(‘M’,’J’,’P’,’G’)or cv.VideoWriter_fourcc(*’MJPG’)&#96; for MJPG. 下面的代码从摄像机捕获，在垂直方向翻转每一帧，并保存视频。 123456789101112131415161718192021222324252627import numpy as npimport cv2 as cvcap = cv.VideoCapture(0)# Define the codec and create VideoWriter objectfourcc = cv.VideoWriter_fourcc(*&#x27;XVID&#x27;)out = cv.VideoWriter(&#x27;output.avi&#x27;, fourcc, 20.0, (640, 480))while cap.isOpened(): ret, frame = cap.read() if not ret: print(&quot;Can&#x27;t receive frame (stream end?). Exiting ...&quot;) break frame = cv.flip(frame, 0) # write the flipped frame out.write(frame) cv.imshow(&#x27;frame&#x27;, frame) if cv.waitKey(1) == ord(&#x27;q&#x27;): break# Release everything if job is finishedcap.release()out.release()cv.destroyAllWindows() 额外的资源练习[^注]: 本文翻译最初编辑于 2024.08.27，最终编辑于 2024.09.07 OpenCV中的绘图函数目标 学习使用 OpenCV 绘制不同的几何形状 你将学习这些函数：cv.line()**, cv.circle(), cv.rectangle(), cv.ellipse(), cv.putText() 等. 代码在上述所有函数中，您将看到一些常见的参数，如下所示： img ： 要绘制形状的图像 color ：形状的颜色。对于 BGR，请将其作为元组传递，例如：(255,0,0) 表示蓝色。对于灰度而言，只需传递标量值。 thickness ： 线或圆等的粗细。如果为闭合图形(如圆形)传递 -1，它将填充形状。默认厚度 &#x3D; 1 lineType ：线路类型，是否为 8-connected、抗锯齿线等。*默认情况下，它是 8-connected。cv.LINE_AA 提供抗锯齿线，非常适合曲线。 绘制直线要绘制一条线，您需要设置线的起点和终点坐标。我们将创建一个黑色图像，并在其上从左上角到右下角绘制一条蓝线。 12345678import numpy as npimport cv2 as cv # Create a black imageimg = np.zeros((512,512,3), np.uint8) # Draw a diagonal blue line with thickness of 5 pxcv.line(img,(0,0),(511,511),(255,0,0),5) 绘制矩形要绘制矩形，您需要矩形的左上角和右下角。这次我们将在图像的右上角绘制一个绿色矩形。 1cv.rectangle(img,(384,0),(510,128),(0,255,0),3) 绘制圆要绘制圆，您需要其中心坐标和半径。我们将在上面绘制的矩形内画一个圆。 1cv.circle(img,(447,63), 63, (0,0,255), -1) 绘制椭圆要绘制椭圆，我们需要设置多个参数。一个参数是中心位置 (x，y)。下一个参数是轴长度 (长轴长度、短轴长度)。angle 是椭圆逆时针方向的旋转角度。startAngle 和 endAngle 表示从长轴开始按顺时针方向测量的椭圆弧的起点和终点。即，给出值 0 和 360 得到完整的椭圆。有关更多详细信息，请查看 cv.ellipse() 的文档。以下示例在图像中心绘制一个半椭圆。 1cv.ellipse(img,(256,256),(100,50),0,0,180,255,-1) 绘制多边形要绘制多边形，首先需要顶点的坐标。将这些点制作成形状为 ROWSx1x2 的数组，其中 ROWS 是顶点数，其类型应为 int32。在这里，我们绘制一个带有四个黄色顶点的小多边形。 123pts = np.array([[10,5],[20,30],[70,20],[50,10]], np.int32)pts = pts.reshape((-1,1,2))cv.polylines(img,[pts],True,(0,255,255)) 注意 如果第三个参数为 False，您将获得连接所有点的多段线，而不是闭合形状。 cv.polylines() 可用于绘制多条线。只需创建一个包含您要绘制的所有线条的列表，并将其传递给函数即可。所有线条都将单独绘制。与为每行调用 cv.line() 相比，绘制一组行是一种更好、更快的方法。 在图像中添加文本：要将文本放入图像中，您需要指定以下内容。 要写入的文本数据 将坐标放在你想要放置的位置（即数据开始的左下角）。 字体类型（查看 cv.putText() 文档了解支持的字体） 字体比例 （指定字体的大小） 常规内容，如 color、thickness、lineType 等。为了更好地查看，建议使用 lineType &#x3D; cv.LINE_AA。 我们将在我们的图像上以白色书写 OpenCV。 12font = cv.FONT_HERSHEY_SIMPLEXcv.putText(img,&#x27;OpenCV&#x27;,(10,500), font, 4,(255,255,255),2,cv.LINE_AA) 结果是时候看看我们绘图的最终结果了。正如您在前几篇文章中所学习的，请显示图像以查看它。 其他资源 ellipse(椭圆) 函数中使用的角度不是我们的圆角。有关更多详细信息，请访问此讨论。 习题 尝试使用 OpenCV 中提供的绘图功能创建 OpenCV 的徽标。 [^注]: 本文翻译最初编辑于 2024.09.07 鼠标作为画笔目标 学习在 OpenCV 中处理鼠标事件 您将学习这些函数：cv.setMouseCallback() 简单演示在这里，我们创建了一个简单的应用程序，它在图像双击图像的任何位置都会画一个圆圈。 首先，我们创建一个鼠标回调函数，该函数在鼠标事件发生时执行。鼠标事件可以是与鼠标相关的任何内容，例如左键按下、左键向上、左键双击等。它为我们提供了每个鼠标事件的坐标 （x，y）。有了这个活动和地点，我们可以做任何我们想做的事。要列出所有可用的事件，请在 Python 终端中运行以下代码： 123import cv2 as cvevents = [i for i in dir(cv) if &#x27;EVENT&#x27; in i]print( events ) 创建鼠标回调函数具有特定的格式，该格式在任何地方都是相同的。它仅在函数的作用上有所不同。所以我们的鼠标回调函数只做了一件事，它在我们双击的地方画了一个圆圈。所以请看下面的代码。代码从注释中不言自明： 123456789101112131415161718import numpy as npimport cv2 as cv # mouse callback functiondef draw_circle(event,x,y,flags,param): if event == cv.EVENT_LBUTTONDBLCLK: cv.circle(img,(x,y),100,(255,0,0),-1) # Create a black image, a window and bind the function to windowimg = np.zeros((512,512,3), np.uint8)cv.namedWindow(&#x27;image&#x27;)cv.setMouseCallback(&#x27;image&#x27;,draw_circle) while(1): cv.imshow(&#x27;image&#x27;,img) if cv.waitKey(20) &amp; 0xFF == 27: breakcv.destroyAllWindows() 更高级的演示现在我们寻求更好的应用程序。在这种情况下，我们像在 Paint 应用程序中一样通过拖动鼠标来绘制矩形或圆形（取决于我们选择的模式）。所以我们的鼠标回调函数有两部分，一部分是画矩形，一部分是画圆。这个具体示例对于创建和理解一些交互式应用程序（如对象跟踪、图像分割等）非常有帮助。 12345678910111213141516171819202122232425262728import numpy as npimport cv2 as cv drawing = False # true if mouse is pressedmode = True # if True, draw rectangle. Press &#x27;m&#x27; to toggle to curveix,iy = -1,-1 # mouse callback functiondef draw_circle(event,x,y,flags,param): global ix,iy,drawing,mode if event == cv.EVENT_LBUTTONDOWN: drawing = True ix,iy = x,y elif event == cv.EVENT_MOUSEMOVE: if drawing == True: if mode == True: cv.rectangle(img,(ix,iy),(x,y),(0,255,0),-1) else: cv.circle(img,(x,y),5,(0,0,255),-1) elif event == cv.EVENT_LBUTTONUP: drawing = False if mode == True: cv.rectangle(img,(ix,iy),(x,y),(0,255,0),-1) else: cv.circle(img,(x,y),5,(0,0,255),-1) 接下来，我们必须将这个鼠标回调函数绑定到 OpenCV 窗口。在主循环中，我们应该为键 ‘m’ 设置一个键盘绑定，以便在矩形和圆形之间切换。 12345678910111213img = np.zeros((512,512,3), np.uint8)cv.namedWindow(&#x27;image&#x27;)cv.setMouseCallback(&#x27;image&#x27;,draw_circle) while(1): cv.imshow(&#x27;image&#x27;,img) k = cv.waitKey(1) &amp; 0xFF if k == ord(&#x27;m&#x27;): mode = not mode elif k == 27: break cv.destroyAllWindows() 其他资源习题 在上一个例子中，我们绘制了填充矩形。修改代码以绘制未填充的矩形。 [^注]: 本文翻译最初编辑于 2024.09.07 Trackbar 作为调色板目标 了解如何将跟踪条绑定到 OpenCV 窗口 您将学习这些函数：**cv.getTrackbarPos()**, cv.createTrackbar() 等。 代码演示在这里，我们将创建一个简单的应用程序，显示您指定的颜色。您有一个显示颜色的窗口和三个跟踪条来指定 B、G、R 颜色中的每一种。滑动跟踪条并相应地更改窗口颜色。默认情况下，初始颜色将设置为 Black。 对于 cv.createTrackbar() 函数，第一个参数是跟踪栏名称，第二个参数是它所附加的窗口名称，第三个参数是默认值，第四个参数是最大值，第五个参数是每次跟踪栏值更改时执行的回调函数。回调函数始终具有一个默认参数，即跟踪栏位置。在我们的例子中，function 什么都不做，所以我们简单地传递。 跟踪栏的另一个重要应用是将其用作按钮或开关。默认情况下，OpenCV 没有按钮功能。因此，您可以使用 trackbar 来获得此类功能。在我们的应用程序中，我们创建了一个开关，该应用程序仅在开关打开时工作，否则屏幕始终为黑色。 1234567891011121314151617181920212223242526272829303132333435363738import numpy as npimport cv2 as cv def nothing(x): pass # Create a black image, a windowimg = np.zeros((300,512,3), np.uint8)cv.namedWindow(&#x27;image&#x27;) # create trackbars for color changecv.createTrackbar(&#x27;R&#x27;,&#x27;image&#x27;,0,255,nothing) cv.createTrackbar(&#x27;G&#x27;,&#x27;image&#x27;,0,255,nothing)cv.createTrackbar(&#x27;B&#x27;,&#x27;image&#x27;,0,255,nothing) # create switch for ON/OFF functionalityswitch = &#x27;0 : OFF 1 : ON&#x27;cv.createTrackbar(switch, &#x27;image&#x27;,0,1,nothing) while(1): cv.imshow(&#x27;image&#x27;,img) k = cv.waitKey(1) &amp; 0xFF if k == 27: break # get current positions of four trackbars r = cv.getTrackbarPos(&#x27;R&#x27;,&#x27;image&#x27;) g = cv.getTrackbarPos(&#x27;G&#x27;,&#x27;image&#x27;) b = cv.getTrackbarPos(&#x27;B&#x27;,&#x27;image&#x27;) s = cv.getTrackbarPos(switch,&#x27;image&#x27;) if s == 0: img[:] = 0 else: img[:] = [b,g,r] cv.destroyAllWindows() 应用程序的屏幕截图如下所示： 习题 使用跟踪条创建具有可调整颜色和画笔半径的 Paint 应用程序。有关绘图，请参阅前面的鼠标操作教程。 [^注]: 本文翻译最初编辑于 2024.09.07 Core Operations - 核心业务(在本节中，您将学习图像的基本操作，如像素编辑，几何变换，代码优化，一些数学工具等) 对图像的基本操作(学习读取和编辑像素值，处理图像ROl等基本操作) 目标学习： 访问像素值并对其进行修改 访问图像属性 设置感兴趣区域 （ROI） 拆分和合并图像 本节中几乎所有的操作都主要与 Numpy 有关，而不是 OpenCV。要使用 OpenCV 编写更好的优化代码，需要对 Numpy 有很好的了解。 （ 示例将显示在 Python 终端中，因为它们中的大多数只是单行代码 ） 访问和修改像素值让我们先加载一张彩色图片： 12345&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; import cv2 as cv &gt;&gt;&gt; img = cv.imread(&#x27;messi5.jpg&#x27;)&gt;&gt;&gt; assert img is not None, &quot;file could not be read, check with os.path.exists()&quot; 您可以通过像素值的行和列坐标来访问像素值。对于 BGR 图像，它返回 Blue、Green、Red 值的数组。对于灰度图像，仅返回相应的强度。 12345678&gt;&gt;&gt; px = img[100,100]&gt;&gt;&gt; print( px )[157 166 200] # accessing only blue pixel&gt;&gt;&gt; blue = img[100,100,0]&gt;&gt;&gt; print( blue )157 您可以用相同的方式修改像素值。 123&gt;&gt;&gt; img[100,100] = [255,255,255]&gt;&gt;&gt; print( img[100,100] )[255 255 255] 警告 Numpy 是一个用于快速数组计算的优化库。因此，简单地访问每个像素值并对其进行修改将非常缓慢，并且不建议这样做。 注意 上述方法通常用于选择数组的区域，例如前 5 行和后 3 列。对于单个像素访问，Numpy 数组方法 array.item（） 和 array.itemset（） 被认为更好。但是，它们总是返回一个标量，因此如果您想访问所有 B，G，R 值，则需要为每个值单独调用 array.item（）。 更好的像素访问和编辑方法： 12345678# accessing RED value&gt;&gt;&gt; img.item(10,10,2)59 # modifying RED value&gt;&gt;&gt; img.itemset((10,10,2),100)&gt;&gt;&gt; img.item(10,10,2)100 访问图像属性图像属性包括行数、列数和通道数;图像数据类型;像素数;等。 图像的形状由 img.shape 访问。它返回行数、列数和通道数的 Tuples（如果图像是彩色的）： 12&gt;&gt;&gt; print( img.shape )(342, 548, 3) 注意 如果图像是灰度图像，则返回的元组仅包含行数和列数，因此检查加载的图像是灰度还是彩色的好方法。 像素总数的访问方式为 ：img.size 12&gt;&gt;&gt; print( img.size )562248 Image 数据类型由 ‘img.dtype’ 获取： 12&gt;&gt;&gt; print( img.dtype )uint8 注意 img.dtype 在调试时非常重要，因为 OpenCV-Python 代码中的大量错误都是由无效的数据类型引起的。 图像 ROI有时，您将不得不处理图像的某些区域。对于图像中的眼睛检测，首先对整个图像进行人脸检测。获得人脸后，我们单独选择人脸区域并搜索其中的眼睛，而不是搜索整个图像。它提高了准确性（因为眼睛总是:D人脸上）和性能（因为我们在小区域内搜索）。 ROI 再次使用 Numpy 索引获得。在这里，我选择球并将其复制到图像中的另一个区域： 12&gt;&gt;&gt; ball = img[280:340, 330:390]&gt;&gt;&gt; img[273:333, 100:160] = ball 检查下面的结果： 拆分和合并图像通道有时，您需要单独处理图像的 B、G、R 通道。在这种情况下，您需要将 BGR 图像拆分为单个通道。在其他情况下，您可能需要加入这些单独的通道以创建 BGR 图像。您可以简单地通过以下方式执行此操作： 12&gt;&gt;&gt; b,g,r = cv.split(img)&gt;&gt;&gt; img = cv.merge((b,g,r)) 或 1&gt;&gt;&gt; b = img[:,:,0] 假设您要将所有红色像素设置为零 - 您无需先拆分通道。Numpy 索引更快： 1&gt;&gt;&gt; img[:,:,2] = 0 警告 cv.split() 是一个昂贵的操作（就时间而言）。因此，请仅在必要时使用它。否则选择 Numpy 索引。 为图像创建边框（填充）如果你想在图像周围创建一个边框，比如相框，你可以使用 cv.copyMakeBorder()但它有更多的应用，用于卷积运算、零填充等。此函数采用以下参数： src - 输入图像 top， bottom， left， right - 相应方向的边框宽度（以像素数为单位） borderType - 定义要添加的边框类型的标志。它可以是以下类型： cv.BORDER_CONSTANT - 添加恒定的彩色边框。该值应作为 next 参数给出。 cv.BORDER_REFLECT - 边界将是边界元素的镜像反射，如下所示 ： fedcba|abcdefgh|hgfedcb cv.BORDER_REFLECT_101 或 cv.BORDER_DEFAULT - 同上，但略有变化，如下所示 ： gfedcb|abcdefgh|gfedcba cv.BORDER_REPLICATE - 最后一个元素在整个过程中被复制，如下所示：aaaaaa|abcdefgh|hhhhhh cv.BORDER_WRAP - 无法解释，它看起来像这样 ： cdefgh|abcdefgh|abcdefg value - 如果 border type 为 cv.BORDER_CONSTANT，则边框的颜色 下面是一个示例代码，演示了所有这些边框类型，以便更好地理解： 1234567891011121314151617181920212223import cv2 as cvimport numpy as npfrom matplotlib import pyplot as plt BLUE = [255,0,0] img1 = cv.imread(&#x27;opencv-logo.png&#x27;)assert img1 is not None, &quot;file could not be read, check with os.path.exists()&quot; replicate = cv.copyMakeBorder(img1,10,10,10,10,cv.BORDER_REPLICATE)reflect = cv.copyMakeBorder(img1,10,10,10,10,cv.BORDER_REFLECT)reflect101 = cv.copyMakeBorder(img1,10,10,10,10,cv.BORDER_REFLECT_101)wrap = cv.copyMakeBorder(img1,10,10,10,10,cv.BORDER_WRAP)constant= cv.copyMakeBorder(img1,10,10,10,10,cv.BORDER_CONSTANT,value=BLUE) plt.subplot(231),plt.imshow(img1,&#x27;gray&#x27;),plt.title(&#x27;ORIGINAL&#x27;)plt.subplot(232),plt.imshow(replicate,&#x27;gray&#x27;),plt.title(&#x27;REPLICATE&#x27;)plt.subplot(233),plt.imshow(reflect,&#x27;gray&#x27;),plt.title(&#x27;REFLECT&#x27;)plt.subplot(234),plt.imshow(reflect101,&#x27;gray&#x27;),plt.title(&#x27;REFLECT_101&#x27;)plt.subplot(235),plt.imshow(wrap,&#x27;gray&#x27;),plt.title(&#x27;WRAP&#x27;)plt.subplot(236),plt.imshow(constant,&#x27;gray&#x27;),plt.title(&#x27;CONSTANT&#x27;) plt.show() 请参阅下面的结果。（图像使用 matplotlib 显示。所以 RED 和 BLUE 通道将互换）： 其他资源习题 图像的算术运算(对图像执行算术运算) 目标 学习图像上的几种算术运算，如加法、减法、按位运算等。 了解这些函数：cv.add()**, **cv.addWeighted(), 等。 图像添加您可以使用 OpenCV 函数 cv.add() 添加两张图像，或者简单地通过 numpy 操作 res &#x3D; img1 + img2。两个图像应具有相同的深度和类型，或者第二个图像只能是标量值。 注意 OpenCV 加法和 Numpy 加法是有区别的。OpenCV 加法是饱和运算，而 Numpy 加法是模运算。 例如，请考虑以下示例： 12345678&gt;&gt;&gt; x = np.uint8([250])&gt;&gt;&gt; y = np.uint8([10]) &gt;&gt;&gt; print( cv.add(x,y) ) # 250+10 = 260 =&gt; 255[[255]] &gt;&gt;&gt; print( x+y ) # 250+10 = 260 % 256 = 4[4] 当您添加两张图片时，这将更加明显。坚持使用 OpenCV 函数，因为它们会提供更好的结果。 图像混合这也是图像添加，但为了给人一种混合或透明的感觉，对图像赋予了不同的权重。根据以下公式添加图像：$$g(x)&#x3D;(1-\\alpha)f_0(x)+\\alpha f_1(x)$$通过变化α从0→1中，您可以在一个图像到另一个图像之间执行很酷的过渡。 在这里，我拍了两张图片混合在一起。第一个图像的权重为 0.7，第二个图像的权重为 0.3。cv.addWeighted() 将以下公式应用于图像：$$dst&#x3D;\\alpha\\cdot img1+\\beta\\cdot img2+\\gamma$$这里γ视为零。 12345678910img1 = cv.imread(&#x27;ml.png&#x27;)img2 = cv.imread(&#x27;opencv-logo.png&#x27;)assert img1 is not None, &quot;file could not be read, check with os.path.exists()&quot;assert img2 is not None, &quot;file could not be read, check with os.path.exists()&quot; dst = cv.addWeighted(img1,0.7,img2,0.3,0) cv.imshow(&#x27;dst&#x27;,dst)cv.waitKey(0)cv.destroyAllWindows() 检查下面的结果： 按位运算这包括按位 AND、OR、NOT 和 XOR 运算。它们在提取图像的任何部分（我们将在后面的章节中看到）、定义和使用非矩形 ROI 等时非常有用。下面我们将看到如何更改图像特定区域的示例。 我想将 OpenCV 徽标放在图像上方。如果我添加两张图片，它会改变颜色。如果我混合它们，我会得到一个透明的效果。但我希望它是不透明的。如果它是一个矩形区域，我可以像上一章中那样使用 ROI。但 OpenCV 标志不是矩形。所以你可以用按位运算来实现，如下所示： 12345678910111213141516171819202122232425262728# Load two imagesimg1 = cv.imread(&#x27;messi5.jpg&#x27;)img2 = cv.imread(&#x27;opencv-logo-white.png&#x27;)assert img1 is not None, &quot;file could not be read, check with os.path.exists()&quot;assert img2 is not None, &quot;file could not be read, check with os.path.exists()&quot; # I want to put logo on top-left corner, So I create a ROIrows,cols,channels = img2.shaperoi = img1[0:rows, 0:cols] # Now create a mask of logo and create its inverse mask alsoimg2gray = cv.cvtColor(img2,cv.COLOR_BGR2GRAY)ret, mask = cv.threshold(img2gray, 10, 255, cv.THRESH_BINARY)mask_inv = cv.bitwise_not(mask) # Now black-out the area of logo in ROIimg1_bg = cv.bitwise_and(roi,roi,mask = mask_inv) # Take only region of logo from logo image.img2_fg = cv.bitwise_and(img2,img2,mask = mask) # Put logo in ROI and modify the main imagedst = cv.add(img1_bg,img2_fg)img1[0:rows, 0:cols ] = dst cv.imshow(&#x27;res&#x27;,img1)cv.waitKey(0)cv.destroyAllWindows() 请参阅下面的结果。左图显示了我们创建的蒙版。右图显示最终结果。为了更好地理解，请显示上述代码中的所有中间图像，尤其是 img1_bg 和 img2_fg。 其他资源习题 使用 cv.addWeighted 函数在文件夹中创建图像的幻灯片，并在图像之间平滑过渡 性能测量和改进技术(找到解决方案很重要。但以最快的方式获得解决方案更为重要。学会检查代码的运行速度，优化代码等等。) 目标在图像处理中，由于您每秒要处理大量操作，因此您的代码不仅必须提供正确的解决方案，而且还必须以最快的方式提供解决方案。因此，在本章中，您将学习： 测量代码的性能。 提高代码性能的一些技巧。 您将看到以下函数：**cv.getTickCount、cv.getTickFrequency** 等。 除了 OpenCV，Python 还提供了一个模块 time，有助于测量执行时间。另一个模块配置文件有助于获取有关代码的详细报告，例如代码中每个函数花费的时间、函数被调用的次数等。但是，如果您使用的是 IPython，所有这些功能都以用户友好的方式集成。我们将看到一些重要的 VPN，有关更多详细信息，请查看 Additional Resources 部分中的链接。 使用 OpenCV 测量性能cv.getTickCount 函数返回引用事件（如机器打开的那一刻）到调用此函数的时钟周期数。因此，如果您在函数执行之前和之后调用它，您将获得用于执行函数的 clock-cycles 数。 cv.getTickFrequency 函数返回 clock-cycles 的频率，或每秒的 clock-cycles 数。因此，要查找以秒为单位的执行时间，您可以执行以下操作： 1234e1 = cv.getTickCount()# your code executione2 = cv.getTickCount()time = (e2 - e1)/ cv.getTickFrequency() 我们将通过以下示例进行演示。以下示例对奇数大小（从 5 到 49）的内核应用中位数筛选。（不要担心结果会是什么样子 - 这不是我们的目标）： 1234567891011img1 = cv.imread(&#x27;messi5.jpg&#x27;)assert img1 is not None, &quot;file could not be read, check with os.path.exists()&quot; e1 = cv.getTickCount()for i in range(5,49,2): img1 = cv.medianBlur(img1,i)e2 = cv.getTickCount()t = (e2 - e1)/cv.getTickFrequency()print( t ) # Result I got is 0.521107655 seconds 注意 你可以对 time 模块做同样的事情。使用 time.time() 函数，而不是 cv.getTickCount。然后取两次的差值。 OpenCV 中的默认优化许多 OpenCV 函数都使用 SSE2、AVX 等进行了优化。它还包含未优化的代码。因此，如果我们的系统支持这些功能，我们应该利用它们（几乎所有现代处理器都支持它们）。默认情况下，它在编译时处于启用状态。因此，如果启用，OpenCV 将运行优化的代码，否则它将运行未优化的代码。您可以使用 cv.useOptimized() 来检查它是否被启用&#x2F;禁用，并使用 cv.setUseOptimized() 来启用&#x2F;禁用它。让我们看一个简单的例子。 123456789101112131415# check if optimization is enabledIn [5]: cv.useOptimized()Out[5]: True In [6]: %timeit res = cv.medianBlur(img,49)10 loops, best of 3: 34.9 ms per loop # Disable itIn [7]: cv.setUseOptimized(False) In [8]: cv.useOptimized()Out[8]: False In [9]: %timeit res = cv.medianBlur(img,49)10 loops, best of 3: 64.1 ms per loop 如您所见，优化的中值滤波比未优化的版本快 2 倍。如果检查其来源，您可以看到中值滤波是 SIMD 优化的。因此，您可以使用它来在代码顶部启用优化（请记住，默认情况下它是启用的）。 在 IPython 中测量性能有时，您可能需要比较两个类似操作的性能。IPython 为您提供了一个神奇的命令 timeit 来执行此操作。它会多次运行代码以获得更准确的结果。同样，它适用于测量单行代码。 例如，您知道以下哪个加法运算更好吗，x = 5；y = x**2， x = 5；y = x*x， x = np.uint8([5])；y = x*x，还是 y = np.square(x)？我们将在 IPython shell 中使用 timeit 来找出答案。 123456789101112131415In [10]: x = 5 In [11]: %timeit y=x**210000000 loops, best of 3: 73 ns per loop In [12]: %timeit y=x*x10000000 loops, best of 3: 58.3 ns per loop In [15]: z = np.uint8([5]) In [17]: %timeit y=z*z1000000 loops, best of 3: 1.25 us per loop In [19]: %timeit y=np.square(z)1000000 loops, best of 3: 1.16 us per loop 你可以看到， x = 5 ;y = x*x 是最快的，与 Numpy 相比，它快了大约 20 倍。如果您还考虑数组创建，它可能会快 100 倍。很酷，对吧？（Numpy 开发人员正在努力解决这个问题） 注意 Python 标量运算比 Numpy 标量运算更快。因此，对于包含一个或两个元素的操作，Python 标量优于 Numpy 数组。当数组的大小稍大时，Numpy 具有优势。 我们将再尝试一个例子。这一次，我们将比较 cv.countNonZero() 和 np.count_nonzero() 对同一图像的性能。 12345In [35]: %timeit z = cv.countNonZero(img)100000 loops, best of 3: 15.8 us per loop In [36]: %timeit z = np.count_nonzero(img)1000 loops, best of 3: 370 us per loop 你看，OpenCV 函数比 Numpy 函数快近 25 倍。 注意 通常，OpenCV 函数比 Numpy 函数更快。所以对于相同的操作，OpenCV 函数是首选。但是，可能会有例外，尤其是当 Numpy 使用视图而不是副本时。 更多 IPython 魔术命令还有其他几个魔术命令来测量性能、分析、行分析、内存测量等。他们都有据可查。因此，此处仅提供指向这些文档的链接。建议有兴趣的读者尝试一下。 性能优化技术有几种技术和编码方法可以充分利用 Python 和 Numpy 的最大性能。这里只注明相关的，并给出重要来源的链接。这里要注意的主要一点是，首先尝试以简单的方式实现算法。一旦它开始工作，就对其进行分析，找到瓶颈并对其进行优化。 尽量避免在 Python 中使用循环，尤其是双&#x2F;三循环等。它们本质上是缓慢的。 尽可能地矢量化算法&#x2F;代码，因为 Numpy 和 OpenCV 针对矢量运算进行了优化。 利用缓存一致性。 除非必要，否则切勿复制数组。尝试改用视图。数组复制是一项成本高昂的操作。 如果在执行所有这些操作后代码仍然很慢，或者如果不可避免地使用大循环，请使用 Cython 等其他库来使其更快。 其他资源 Python 优化技术 Scipy 讲义 - 高级 Numpy IPython 中的计时和分析 习题 Image Processing in OpenCV - OpenCV中的图像处理(在本节中，您将学习OpencV中不同的图像处理函数。) 改变颜色(学会在不同的色彩空间之间改变图像。另外学习在视频中跟踪有颜色的物体。) 目标 在本教程中，您将学习如何将图像从一个色彩空间转换为另一个色彩空间，例如 BGR ↔ Gray，BGR ↔ HSV 等 除此之外，我们还将创建一个应用程序来提取视频中的彩色对象 您将学习以下函数：cv.cvtColor(), cv.inRange() 等。 更改色彩空间OpenCV 中有 150 多种颜色空间转换方法。但我们只研究两个，它们是使用最广泛的：BGR ↔ Gray 和 BGR ↔ HSV。 对于颜色转换，我们使用函数 cv.cvtColor(input_image, flag)，其中 flag 确定转换的类型。 对于 BGR → Gray 转换，我们使用 cv.COLOR_BGR2GRAY 标志。BGR → HSV 也是如此，我们使用 cv.COLOR_BGR2HSV 标志。要获取其他标志，只需在 Python 终端中运行以下命令： 123&gt;&gt;&gt; import cv2 as cv&gt;&gt;&gt; flags = [i for i in dir(cv) if i.startswith(&#x27;COLOR_&#x27;)]&gt;&gt;&gt; print( flags ) 注意 对于 HSV，色相范围为 [0,179]，饱和度范围为 [0,255]，值范围为 [0,255]。不同的软件使用不同的尺度。因此，如果要将 OpenCV 值与它们进行比较，则需要对这些范围进行标准化。 对象跟踪现在我们知道了如何将 BGR 图像转换为 HSV，我们可以使用它来提取彩色对象。在 HSV 中，表示颜色比在 BGR 颜色空间中更容易。在我们的应用程序中，我们将尝试提取蓝色对象。所以这是方法： 拍摄视频的每一帧 从 BGR 转换为 HSV 色彩空间 我们将 HSV 图像阈值设置为蓝色范围 现在单独提取蓝色对象，我们可以对该图像执行任何操作。 下面是详细注释的代码： 12345678910111213141516171819202122232425262728293031import cv2 as cvimport numpy as np cap = cv.VideoCapture(0) while(1): # Take each frame _, frame = cap.read() # Convert BGR to HSV hsv = cv.cvtColor(frame, cv.COLOR_BGR2HSV) # define range of blue color in HSV lower_blue = np.array([110,50,50]) upper_blue = np.array([130,255,255]) # Threshold the HSV image to get only blue colors mask = cv.inRange(hsv, lower_blue, upper_blue) # Bitwise-AND mask and original image res = cv.bitwise_and(frame,frame, mask= mask) cv.imshow(&#x27;frame&#x27;,frame) cv.imshow(&#x27;mask&#x27;,mask) cv.imshow(&#x27;res&#x27;,res) k = cv.waitKey(5) &amp; 0xFF if k == 27: break cv.destroyAllWindows() 下图显示了对蓝色对象的跟踪： 注意 图像中有一些杂色。我们将在后面的章节中看到如何删除它。 这是对象跟踪中最简单的方法。一旦你学会了等值线的功能，你就可以做很多事情，比如找到对象的质心并使用它来跟踪对象，只需在相机前移动你的手就可以画图表，以及其他有趣的事情。 如何找到要跟踪的 HSV 值？这是 stackoverflow.com 中的常见问题。这非常简单，您可以使用相同的函数 cv.cvtColor()。您无需传递图像，只需传递所需的 BGR 值。例如，要查找 Green 的 HSV 值，请在 Python 终端中尝试以下命令： 1234&gt;&gt;&gt; green = np.uint8([[[0,255,0 ]]])&gt;&gt;&gt; hsv_green = cv.cvtColor(green,cv.COLOR_BGR2HSV)&gt;&gt;&gt; print( hsv_green )[[[ 60 255 255]]] 现在，您分别将 [H-10, 100, 100] 和 [H+10, 255, 255] 作为下限和上限。除了这种方法，您还可以使用任何图像编辑工具(如 GIMP)或任何在线转换器来查找这些值，但不要忘记调整 HSV 范围。 其他资源习题 尝试找到一种方法来提取多个彩色对象，例如，同时提取红色、蓝色和绿色对象。 图像的几何变换(学习应用不同的几何变换图像，如旋转，平移等。) 目标 学习对图像应用不同的几何变换，如平移、旋转、仿射变换等。 您将看到以下函数：cv.getPerspectiveTransform 转换OpenCV 提供了两个变换函数，cv.warpAffine and cv.warpPerspective，**你可以使用它们执行各种变换。 **cv.warpAffine 采用 2x3 变换矩阵，而 cv.warpPerspective 采用 3x3 变换矩阵作为输入。 缩放缩放只是调整图像的大小。为此 OpenCV 附带了一个函数 cv.resize()。可以手动指定图像的大小，也可以指定缩放因子。使用不同的插值方法。首选的插值方法是 cv.INTER_AREA 用于缩小，cv.INTER_CUBIC (慢速) &amp; cv.INTER_LINEAR 用于缩放。默认情况下，插值方法 cv.INTER_LINEAR 用于所有大小调整目的。您可以使用以下任一方法调整输入图像的大小： 1234567891011121314151617181920212223import numpy as npimport cv2 as cv img = [cv.imread](https://docs.opencv.org/4.10.0/d4/da8/group__imgcodecs.html#gab32ee19e22660912565f8140d0f675a8)(&#x27;messi5.jpg&#x27;)assert img is not None, &quot;file could not be read, check with os.path.exists()&quot; res = [cv.resize](https://docs.opencv.org/4.10.0/da/d54/group__imgproc__transform.html#ga47a974309e9102f5f08231edc7e7529d)(img,None,fx=2, fy=2, interpolation = cv.INTER_CUBIC) \\#OR height, width = img.shape[:2]res = [cv.resize](https://docs.opencv.org/4.10.0/da/d54/group__imgproc__transform.html#ga47a974309e9102f5f08231edc7e7529d)(img,(2*width, 2*height), interpolation = cv.INTER_CUBIC) 平移平移是物体位置的移动。如果你知道 (x,y) 方向的位移并设为 (tx,ty), you can create the transformation matrix M as follows: M&#x3D;[10tx01ty] You can take make it into a Numpy array of type np.float32 and pass it into the cv.warpAffine() function. See the below example for a shift of (100,50): import numpy as np import cv2 as cv img &#x3D; cv.imread(‘messi5.jpg’, cv.IMREAD_GRAYSCALE) assert img is not None, “file could not be read, check with os.path.exists()” rows,cols &#x3D; img.shape M &#x3D; np.float32([[1,0,100],[0,1,50]]) dst &#x3D; cv.warpAffine(img,M,(cols,rows)) cv.imshow(‘img’,dst) cv.waitKey(0) cv.destroyAllWindows() warning The third argument of the cv.warpAffine() function is the size of the output image, which should be in the form of (width, height). Remember width &#x3D; number of columns, and height &#x3D; number of rows. See the result below: image RotationRotation of an image for an angle θ is achieved by the transformation matrix of the form M&#x3D;[cosθ−sinθsinθcosθ] But OpenCV provides scaled rotation with adjustable center of rotation so that you can rotate at any location you prefer. The modified transformation matrix is given by [αβ(1−α)⋅center.x−β⋅center.y−βαβ⋅center.x+(1−α)⋅center.y] where: α&#x3D;scale⋅cos⁡θ,β&#x3D;scale⋅sin⁡θ To find this transformation matrix, OpenCV provides a function, cv.getRotationMatrix2D. Check out the below example which rotates the image by 90 degree with respect to center without any scaling. img &#x3D; cv.imread(‘messi5.jpg’, cv.IMREAD_GRAYSCALE) assert img is not None, “file could not be read, check with os.path.exists()” rows,cols &#x3D; img.shape # cols-1 and rows-1 are the coordinate limits. M &#x3D; cv.getRotationMatrix2D(((cols-1)&#x2F;2.0,(rows-1)&#x2F;2.0),90,1) dst &#x3D; cv.warpAffine(img,M,(cols,rows)) See the result: image Affine TransformationIn affine transformation, all parallel lines in the original image will still be parallel in the output image. To find the transformation matrix, we need three points from the input image and their corresponding locations in the output image. Then cv.getAffineTransform will create a 2x3 matrix which is to be passed to cv.warpAffine. Check the below example, and also look at the points I selected (which are marked in green color): img &#x3D; cv.imread(‘drawing.png’) assert img is not None, “file could not be read, check with os.path.exists()” rows,cols,ch &#x3D; img.shape pts1 &#x3D; np.float32([[50,50],[200,50],[50,200]]) pts2 &#x3D; np.float32([[10,100],[200,50],[100,250]]) M &#x3D; cv.getAffineTransform(pts1,pts2) dst &#x3D; cv.warpAffine(img,M,(cols,rows)) plt.subplot(121),plt.imshow(img),plt.title(‘Input’) plt.subplot(122),plt.imshow(dst),plt.title(‘Output’) plt.show() See the result: image Perspective TransformationFor perspective transformation, you need a 3x3 transformation matrix. Straight lines will remain straight even after the transformation. To find this transformation matrix, you need 4 points on the input image and corresponding points on the output image. Among these 4 points, 3 of them should not be collinear. Then the transformation matrix can be found by the function cv.getPerspectiveTransform. Then apply cv.warpPerspective with this 3x3 transformation matrix. See the code below: img &#x3D; cv.imread(‘sudoku.png’) assert img is not None, “file could not be read, check with os.path.exists()” rows,cols,ch &#x3D; img.shape pts1 &#x3D; np.float32([[56,65],[368,52],[28,387],[389,390]]) pts2 &#x3D; np.float32([[0,0],[300,0],[0,300],[300,300]]) M &#x3D; cv.getPerspectiveTransform(pts1,pts2) dst &#x3D; cv.warpPerspective(img,M,(300,300)) plt.subplot(121),plt.imshow(img),plt.title(‘Input’) plt.subplot(122),plt.imshow(dst),plt.title(‘Output’) plt.show() Result: image Additional Resources “Computer Vision: Algorithms and Applications”, Richard Szeliski ExercisesGenerated on Sun Jun 2 2024 21:52:14 for OpenCV by 1.9.8","tags":["计算机视觉","OpenCV-Python","OpenCV"]},{"title":"Python","path":"/Python/","content":"1.python import 【python】关于import你需要知道的一切！一个视频足够了 modole An object that serves as an organizational unit of Python code. Modules have a namespace containing arbitrary Python objects. Modules are loaded into Python by the process of importing. package A Python module which can contain submodules or recursively, subpackages. Technically, a package is a Python module with a _path_ attribute. import 是把文件系统里面的文件或者文件夹变成一个Python的module或者package的过程。 一、了解import 00:56 了解import 1️⃣.我们首先要理清两个概module&#x2F;package 2️⃣.在 Python 中， module 是组织单位，它自己独立构成一个命名空间。它本身是一个 Python object 3️⃣.在 Python object 里面，还可以有很多其他的 Python object 4️⃣.实际应用中， module 对应的是派文件。 5️⃣.module 是拍脏运行时的概念，它本身是一个 Python object 6️⃣.它保存在内存里是 Python 级别的概念 二、package 00:55 package 1️⃣.package是一种特殊的module 2️⃣.在 Python 中， package 几乎和 module 有一样的功能，它只是多了一个path 3️⃣.区分 package 跟module，是因为在操作系统层级， package 往往对应的是一个文件夹 4️⃣.一个文件夹里面可以有其他的文件夹，可以有文件 5️⃣. package 里面儿可以有其他subpackage，也可以有module 6️⃣. module 在组织结构上就是最末端的一个东西了。你可能听过一种说法儿 三、正式说import 01:56 正式说import 1️⃣.import 是把文件系统里面的文件或者文件夹变成一个 Python 的 module 或者 package 的过程 2️⃣、不会在 module 赋值给任何一个变量，而是在这个 module 里面找到这个名字为 a 的variable，把这个变量 a 里面保存的 object 再赋值到我当前 module 下的变量a"},{"title":"learn-mediapipe","path":"/learn-mediapipe/","content":"OpenCV 资料：OpenCV 官方文档索引 OpenCV 官方文档 4.10.0 OpenCV 教程 4.10.0 OpenCV-Python 教程 4.10.0 我优先学这个 OpenCV第三方中文文档 (woshicver.com) 第三方中文文档 apachecn.github.io&#x2F;opencv-doc-zh&#x2F; OpenCV中文论坛 https://www.opencv.org.cn/ Mediapipe 官方资料：MediaPipe 解决方案指南 | Google AI Edge | Google AI for Developers MediaPipe Studio (google.com) 0.配置： IDE：PyCharm Python解释器：python3.8.10 1.下载安装mediapipe 1pip install mediapipe 2.下载 Handmarker手部模型包 ，包含两个打包的模型：手掌检测模型和手部特征点检测模型。 有关该 Handmarker手部模型包 的介绍： 模型卡片(MediaPipe Hands (Lite&#x2F;Full)) 该模型可检测已检测到的手部区域内 21 个手指节坐标(如下图所示)的关键点定位。该模型基于大约 3 万张真实图像以及对各种背景施加的几个渲染的合成手部模型进行了训练。 手部特征点模型包包含一个手掌检测模型和一个手部特征点检测模型。手掌检测模型在输入图片中定位手部，手部特征点检测模型可识别手掌检测模型定义的被剪裁手掌图片上的特定手部特征点。 由于运行手掌检测模型非常耗时，因此在视频或直播跑步模式下，手部特征点会在一帧中使用手部特征点模型定义的边界框，以便为后续帧定位手部区域。仅当手部特征点模型不再识别出手部的存在或未能跟踪画面中的手部时，手部特征点才会重新触发手掌检测模型。这样可以减少手动标志器触发手掌检测模型的次数。 3.然后下载 手势分类模型包 。这个模型可以识别7种手势:👍, 👎, ✌️, ☝️, ✊, 👋, 🤟 有关该 手势分类模型包 的介绍： 模型卡片(MediaPipe Hand Gesture Classification) 获取视频流部分： 1pip install opencv-python 1.下面是一段 使用 OpenCV 获取视频流 基础框架： 12345678910111213141516# 导入OpenCV库import cv2# 打开摄像头(0为默认,1为设备列表第二个摄像头，以此类推;)cap = cv2.VideoCapture(0)# 主进程：while True: ret, img = cap.read() # 读取摄像头的图像帧 img = cv2.flip(img, 1) # 对img图像进行水平翻转 if ret: cv2.imshow(&#x27;img&#x27;, img) # 显示处理后的图像 if cv2.waitKey(1) == ord(&#x27;q&#x27;): break # 如果按下 &#x27;q&#x27; 键，则退出循环 2.如果你想显示一段循环代码运行时的帧率： 12345678910111213# 导入time库(python自带库)import timepTime = 0cTime = 0while True: cTime = time.time() # 返回当前时间的时间戳（1970纪元后经过的浮点秒数） # if cTime - pTime != 0: (如有必要就加上) fps = 1 / (cTime - pTime) # 这里的&#x27;1&#x27;代表&#x27;1秒&#x27;, cTime-pTime 能够指代 while True 内整体代码循环一遍所用时间 pTime = cTime print(f&quot;FPS: &#123;int(fps)&#125;&quot;) # 打印fps帧率 3.将 2. 代入 1. ,即在 OpenCV获取的视频流上显示帧率： 12345678910111213141516171819202122232425import cv2 # 导入OpenCv库import time # 导入时间模块cap = cv2.VideoCapture(0) # 0为打开默认摄像头,1为打开你设备列表的第二个摄像头,以此类推;pTime = 0cTime = 0 # 用于计算帧率while True: # 无限循环 ret, img = cap.read() # 读取摄像头的图像帧 img = cv2.flip(img, 1) # 对img图像进行水平翻转 if ret: imgRGB = cv2.cvtColor(img, cv2.COLOR_BGR2RGB) # 将图像从BGR格式转换为RGB格式 imgHeight = img.shape[0] # 获取图像的高度，并将其赋值给变量imgHeight(其中[0]表示高度的维度) imgWidth = img.shape[1] # 其中，img是一个图像对象，而shape[1]表示图像的宽度 cTime = time.time() # 获取当前时间 fps = 1 / (cTime - pTime) # 计算帧率 pTime = cTime # 更新上一帧的时间 cv2.putText(img, f&quot;FPS : &#123;int(fps)&#125;&quot;, (30, 50), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 3) # 在图像上显示帧率 cv2.imshow(&#x27;img&#x27;, img) # 显示处理后的图像 if cv2.waitKey(1) == ord(&#x27;q&#x27;): break # 如果按下 &#x27;q&#x27; 键，则退出循环 OpenCV实时视频流检测圆形"},{"title":"胶和胶带-当你想把物品粘合起来","path":"/glue-and-tape/","content":"胶的分类：【工具 | 如何使用胶1？固体胶、胶水、糨糊、白乳胶、瞬干胶、氯丁橡胶、AB胶】 【工具 | 如何使用胶2？UV胶、喷胶、热熔胶、U胶、酒精胶、蓝丁胶、玻璃胶以及如何选胶】 1.常见胶水左一：固体胶\t右一：液体胶 2.糨糊：用于粘贴纸张，其粘贴的纸张可以重新揭开不破坏表面，书画装裱的主要粘合剂 原材料是植物淀粉 制作方法： 1冷水稀释淀粉(玉米淀粉) 2.隔水煮(一边煮一边搅拌)，直到淀粉变成半透明的糊状 3(可选)：加入适量的明矾（更好地凝固和防腐） 3.PVA白乳胶：一种白色的粘稠物体，适合粘贴在木纤维的表面(纸、纸板、木) 如果用在纸上，既不要刷太多，也要涂的均匀，因为纤维吸收的水分会膨胀，纸就会变皱 正确涂法： 1.涂适量(两边都涂胶可以避免弯曲) 2.尽快贴 3.上下垫纸吸收水分 4.用重物压平，等待彻底干透 有时乳胶太粘绸，可以用水稀释 如果用在木上，要先把平面清洁好，处理平整， 1.涂 2.放正放好 3.固定夹或重物固定 4.等待白乳胶固化(通常十几小时到一天) 白乳胶承力有限，若受潮，粘合力会大大降低 4.CA瞬干胶常见的有502，一般为丙烯酸乙酯，可以粘合木、金属、大部分塑料 特点：稀，流动快 粘合狭窄面可以借助老鼠尾(细长管) 有时通过透明件可以看到粘合面有白雾，是因为使用瞬干胶粘合的过程中混入了水汽(保持干燥，别用嘴吹干) 瞬干胶粘合面无弹性 瞬干胶有相应的解胶剂 爽身粉+瞬干胶 可以把坑洞填平 5.CR氯丁橡胶俗称万能胶，柔韧性强，耐老化，但不耐高温和低温 使用：1.涂两面 2.等胶水变粘 3.合两面 6.Epoxy AB胶(环氧树脂胶)A胶 和 B胶 混合 会凝固成胶 7.UV胶 (光固化胶)能一直保持适当流动性，直到紫外线照射固化 适用于透明件的粘贴 8.喷胶 - Spray Adhesive适合面积大的快速粘贴，一般用来贴纸张、海报 种类多，有 可以反复粘贴 和 粘上后撕不下 的喷胶 9.热熔胶 - Glue Gun本质是塑料融化再凝固，需配合热熔胶枪使用 什么都能粘，但是不太牢 10.UHU胶、酒精胶 - Liquid Silicone Glue通常用于手工制作，布料表现好 易挥发，拉丝 如果会发过多导致过于黏稠，可以加98%酒精稀释使用 11.蓝丁胶 - Sticky Tack类似有粘性的粘土 粘力一般，但可以反复使用，不留痕迹 12.玻璃胶 - Silicone粘合力好，弹性好，防水性好，常用于家装 种类多，玻璃胶只是这一类胶的统称 需配合玻璃胶枪使用 胶带的组成：胶粘剂 和 各种材料的基材【工具 | 如何使用胶带(1&#x2F;2)？透明胶、封箱胶、静电膜、布基胶带、双面胶、水溶双面胶、点胶、海绵胶、纸胶带、美纹纸、遮盖胶带】 【工具 | 如何使用胶带(2&#x2F;2)？生胶带、绝缘胶带、金属胶带、耐高温胶带，还有久违的用各种胶和胶带，做个东西 :-)】 使用步骤： 清理好粘合的表面 贴的时候尽可能平整，不要起皱，尽量排出粘合面里面的空气 胶带的分类：1.透明胶 - Transparent Tape&#x2F;Sealing Tape用途：封纸箱、粘通知、捆东西、简单的修补、当改错带把字迹贴掉 不小心粘在纸面上时，不要直接撕，同时左右两边用力拉透明胶，这样就能轻松拿掉 遇到不好撕的透明胶带，可以用电吹风加热，让粘胶软化好分离；残留在表面的胶，可以用松节水(Organic Solvent,有机溶剂)把它擦掉(松节水也有可能融化表面的油漆)。 2.静电膜 - Electrostatic film形态：靠本身静电吸附起作用的透明膜 用途：厚的静电膜 用于保护光滑表面(如仪器) 薄的静电膜(保鲜膜) 用来捆扎东西，使用时直接缠绕在物件上 3.布基胶带 - Duct Tape简介：一种易撕、粘合力强的胶带，表面是聚乙烯层(防水耐磨)，中间布基结构让胶带受力不容易撕裂，而在垂直方向很容易撕开，方便使用。还有一种透明纤维胶带也算布基胶带，但区别是纤维布基结构是连续、单向的，要用剪刀断开。 4.双面胶 - Double Sided Tape用途：把两个表面互相贴一起 简介：双面胶有一层滑滑的胶纸(Release Liner,离型纸) 如果难清除可以用松节水擦除或者刮除 水溶布用双面胶 - Water-soluble Double-sided Adhesive Tape 可以溶于水，常用于固定布料以方便车缝 无痕点胶 - Glue Dots 用完就可以把胶搓掉，常用在各种附赠的产品粘贴 双面点胶 - Glue Tape 像修正纸一样的包装，直接划一下，胶就会贴到表面的双面胶 5.海绵胶 - Foam Tape简介：与双面胶类似，都是双面胶带，粘力更大，即使在坑洼表面也能表现良好，中间胶层更厚(海绵) 用途：常用在装修领域，如固定挂钩、相框，在大块饰面或者镜面粘贴与玻璃胶混合使用 海绵胶撕下来常常会留下很难清理的海绵和胶，解决方法是先用铲子铲除，然后配合松节水擦拭 亚克力透明双面强力胶带 - 纳米胶 和海绵胶的作用差不多，但去除会相对容易，而且能使用在全透明的场景 6.纸胶带 - Paper Tape简介：纸胶带的基材是纸，可以在上面印刷各种漂亮的图案，可以在上面写字，可以徒手就撕开，很方便。 最常见的就是美纹纸 - 一种白色、表面带皱纹的纸胶带，撕下来基本不留痕迹，而且还能反复粘贴 用途：日常暂时固定、家装遮盖 模型喷漆可以使用专门的遮盖胶带，因为它的粘度适中，不会粘掉原来的漆面。这种纸胶纸面更薄，更容易调整形态，既可以遮盖出直线的边缘，也可以根据要求贴出弧度。喷漆结束后，要在漆开始干以前把遮盖带撕掉，因为这个时候漆面还是液态可以流动，所以会形成利落的边缘。(遮盖带如果没有完全没贴合表面，喷漆后可能会出现羽化的模糊效果) 报事贴 可以在上面写字。 如果遇到难以撕下的纸胶带或者贴纸，可以用电吹风适当加热，或者撕下后用松节水擦洗或者刮洗 7.生胶带&#x2F;生料带 - Thread Sealing Tape形态：白色、有弹性、没有粘力的胶带 用途：主要用在管道螺纹连接的地方密封防漏，如水管和煤气管 用法：卷胶带不能像用普通胶带一样顺着打开，因为在用力拉的时候胶带会越拉越长，越缠越不紧 反方向卷胶带 缠绕方向与螺纹方向相反 缠绕的时候，先把胶带开始的一段扭成小股，缠在最里面的螺牙上，这样最后缠好的胶带就会呈楔形，能有效防漏 缠绕的时候也要注意不要挡住入水口，否则拧进水管后就会影响进水量 通常我们会缠螺纹的2-3倍圈数的生胶带，譬如没有缠生胶带前，水龙头拧6圈就能拧到尽头，我们就会缠12-18圈；如果不确定圈数，就大概拧15-20圈，宁多勿少。 把缠好的水龙头直接拧进水管。因为缠绕的生胶带已经垫高了螺纹，所以拧的时候会明显觉得水龙头紧了很多。可以提前在拧到尽头前而且水龙头正的角度就停下来，也可以拧到尽头再往回退一点。 8.绝缘胶带 - Electrical Tape简介：也叫电工胶带，是PVC材质，有绝缘阻燃的作用 用途：在电工作业中被广泛使用 用法：断电，先从金属外露的前一段斜着开始，然后螺旋缠绕过去(将胶带拉变形确保够紧)，缠到金属部分可以往回多绕几层以确保绝缘效果，缠的时候把凸起压着缠回去。如果遇上狭窄的位置不方便缠绕，可以先把胶带缠绕在小棍子上，再缠绕上去(热缩管具有同样效果) 9.金属胶带 - Foil Tape特性：防水、耐热、耐腐蚀；由于表面的金属箔可以散热，所以还有一定的防火功能 用途：做密封和屏蔽 铝箔胶带 是比较常用的一种，通常会用在空调管道、抽油烟机的密封，或者固定隔热垫 铝箔胶带比较软，如果要贴或者缠的距离比较长，使用时最好先揭开一小段，一边贴，再一边慢慢撕开 铜箔胶带 因为屏蔽效果好，所以用来做网线、电器，或者音响的信号屏蔽，但铜箔胶带要比铝箔胶带价格更贵。 另外，因为铜箔容易上锡，所以一些彩色玻璃拼接也会用铜箔胶带来给玻璃块封边，以方便焊接 10.耐高温胶带 - Heat Resistant Tape使用耐高温基材，可以耐250-300℃高温 用途：常用在电子工业，在电路板上遮盖需要受保护的元件，或者给充电电池隔热 同时这种胶带也有绝缘、耐化学腐蚀等作用 还有铁氟龙耐高温胶带，使用玻璃纤维基材，结实、牢固、耐磨，可以隔热、耐温、防粘。在热熔胶封口机或者一些需要耐高温的模具表面都可以见到这种胶带。"},{"title":"Android","path":"/Android/","content":"Termux 资料Termux 维基 Termux第三方中文维基 个人 Termux 软件资源备份： 通过百度网盘分享的文件：Termux链接：https://pan.baidu.com/s/1ouhSs68coGcndMep6zioOg提取码：user Android 文件系统目录 结构 初步认识​ Android系统的内核使用的是Linux内核， 所以Android的文件目录结构和Linux系统的文件目录结构类似。​ Android系统使用虚拟文件系统（VFS）， VFS的目录是以&#x2F;为根节点，根节点下又有不同的节点。而我们的物理存储设备就是挂载都这些节点上，如下图所示： 粗略了解一下，然后打开MT模拟器上手看看： (机型:Redmi Note12 Tubro) &#x2F;data&#x2F;app&#x2F; apk的安装目录。注意：该目录需要获取root权限才能查看 &#x2F;system&#x2F;app&#x2F; 存放系统必要应用的apk文件 &#x2F;storage&#x2F; 该节点是内置存储卡和外置SD卡的挂载点，&#x2F;storage&#x2F;emulated&#x2F;0&#x2F;是内置存储卡挂载点， &#x2F;storage&#x2F;sdcard1是外置SD卡挂载点（不同的设备挂载节点不一样，有些设备可能会挂载到&#x2F;mnt&#x2F;节点）。 就先了解这三个。 接下来看看opencv试试(逝世) Android跑OpenCV-Python我们将使用termux 最好在f-droid上下载termux而不是在GooglePlay(GooglePlay上是已不受支持的旧版本) termux介绍： termux本体包括termux中所作所有内容全部储存在&#x2F;data&#x2F;data&#x2F;com.termux&#x2F;files&#x2F;home下，能够直接整体卸载 直接进入termux，开始敲代码： 12# Python环境pkg instal python 12# python下opencv环境pkg install opencv-python 12# 使用termux内置的nano编辑器 (新建)进入first.py文件nano first.py 1234567891011121314151617181920212223242526272829303132# first.py 内容import cv2# 创建一个VideoCapture对象，参数0表示使用第一个摄像头cap = cv2.VideoCapture(0)# 检查摄像头是否成功打开if not cap.isOpened(): print(&quot;无法打开摄像头&quot;) exit()# 创建一个无限循环来持续获取视频帧while True: # 读取一帧 ret, frame = cap.read() # 如果正确读取帧，ret为True if not ret: print(&quot;无法读取帧&quot;) break # 显示帧 cv2.imshow(&#x27;实时视频流&#x27;, frame) # 按下&#x27;q&#x27;键退出循环 if cv2.waitKey(1) == ord(&#x27;q&#x27;): break# 释放VideoCapture对象cap.release()# 关闭所有OpenCV窗口cv2.destroyAllWindows() 1# 文件编辑完成后，Ctrl+O保存，再回车确认，再Ctrl+X退出编辑 打开文件后，下方有一堆文字，那就是快捷键说明。例如：^G 即为 Ctrl+G ，功能为显示帮助文本。 Ctrl+G，显示帮助文本 Ctrl+O，保存当前文件 Ctrl+R，读取其他文件并插入光标位置 Ctrl+Y，跳至上一屏幕 Ctrl+K，剪切当前一行 Ctrl+C，显示光标位置 Ctrl+X，退出编辑文本 Ctrl+J，对其当前段落（以空格为分隔符） Ctrl+W，搜索文本位置 Ctrl+V，跳至下一屏幕 Ctrl+U，粘贴文本至光标处 Ctrl+T，运行拼写检查 Ctrl+_，跳转到某一行 ALT+U，撤销 ALT+E，重做 ALT+Y, 语法高亮 ALT+#，显示行号 12# 运行 first.pypython first.py 这个时候无法打开摄像头： 12# 安装termux api接口pkg install termux-api 使用如下命令行替换官方源为 TUNA 镜像源 12sed -i &#x27;s@^\\(deb.*stable main\\)$@#\\1 deb https://mirrors.tuna.tsinghua.edu.cn/termux/apt/termux-main stable main@&#x27; $PREFIX/etc/apt/sources.listapt update &amp;&amp; apt upgrade termux换源 因为Android14对于data&#x2F;data文件夹的访问以及操作限制，折腾了半天， termux如何删除文件 - CSDN文库 退出交互式Python：exit() 对于import cv2 报错问题的解决： [Bug]: OpenCV is not working · Issue #20334 · termux&#x2F;termux-packages (github.com) 1pkg install x11-repo 1pkg install matplotlib 1pkg install opencv termux-api-start启动termux-api 12# root 权限pkg install root-repo termux 安装 ubuntu12# proot-distro，是一段bash脚本，用于在Termux中管理与安装proot下Linux发行版。pkg install proot-distro 12# 查看可安装的linux系统proot-distro list 12# 安装 ubuntu 22.04 ltsproot-distro install ubuntu-oldlts 12# 进入 ubuntu 22.04 lts 环境proot-distro login ubuntu-oldlts 12# 退出环境exit 12# Linux 创建普通用户exampleuseradd -d /home/example -m example 12345678910111213141516171819# 密码示例root@localhost:~# cd /homeroot@localhost:/home# lsexampleroot@localhost:/home# ls -ltotal 4drwxr-x---. 2 root root 3452 Aug 8 11:02 example# 给用户example创建密码root@localhost:/home# passwd exampleNew password: 123456Retype new password: 123456passwd: password updated successfully# 给root用户创建密码root@localhost:/home# passwdNew password: 123456Retype new password: 123456passwd: password updated successfullyroot@localhost:/home# 配置 Ubuntu 桌面123456789apt-get update &amp;&amp; apt-get install wget -y &amp;&amp; wget https://raw.githubusercontent.com/EXALAB/AnLinux-Resources/master/Scripts/DesktopEnvironment/Apt/Xfce4/de-apt-xfce4.sh --no-check-certificate &amp;&amp; bash de-apt-xfce4.sh&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;1. apt-get update：更新软件包索引文件，确保您拥有最新的软件包列表和版本信息。2. apt-get install wget -y：安装 wget 工具，-y 参数表示自动回答所有提示为“是”，以便安装过程无需用户干预。3. wget https://raw.githubusercontent.com/EXALAB/AnLinux-Resources/master/Scripts/DesktopEnvironment/Apt/Xfce4/de-apt-xfce4.sh --no-check-certificate：使用 wget 下载名为 de-apt-xfce4.sh 的脚本。--no-check-certificate 选项告诉 wget 在不验证服务器 SSL 证书的情况下继续操作，这在服务器使用自签名证书或您在没有访问证书颁发机构证书的环境中工作时可能很有用。4. bash de-apt-xfce4.sh：使用 bash 执行下载的脚本。de-apt-xfce4.sh 脚本似乎是自动化安装 Xfce4 桌面环境和 VNC 服务器，允许您通过 VNC 查看器远程访问桌面环境。&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot; 12345安装好--初始化--选键盘布局--中国--选键盘布局--中文普通话--继续初始化--选择所处的地理位置，后续的配置问题将缩小范围 12vncserver-startvncserver-stop 123The VNC Server will be started at 127.0.0.1:5901You can connect to this address with a VNC Viewer you preferConnect to this address will open a window with Xfce4 Desktop Environment 最后会出现设置输入桌面系统密码，该密码用于连接VNC Viewer软件。 按照提示会输入四次 12345678910111213You will require a password to access your desktops.Password:Verify: Would you like to enter a view-only password (y/n)? yPassword: Verify: xauth: file /root/.Xauthority does not existNew &#x27;remote-desktop&#x27; desktop is localhost:1 Starting applications specified in /root/.vnc/xstartupLog file is /root/.vnc/localhost:1.logroot@localhost:~# 当出现 root@localhost:~# 即代表安装桌面系统完成。 注意： 生成的 localhost:1是VNC Viewer软件连接Ubuntu桌面系统的Address。 转到 VNC Viewer – – VNC Viewer：New connection – Address：localhost:1 – Name：Ubuntu –connect–ok 点击右上角的 叉号，即可退出VNC Viewer，但注意此时并未完全退出，需要在 Termux的linux系统 （即root@localhost:~# 后 ）输入： 1vncserver-stop 才可以彻底的退出VNC Viewer。(为再次进入做好前提条件) 然后在需要在 Termux的linux系统 （即root@localhost:~# 后 ）输入： 1vncserver-start 才具备再次进入VNC Viewer桌面的前提条件。 Termux Linux 环境启动！12# 进入 ubuntu 22.04 lts 环境proot-distro login ubuntu-oldlts 12# (如果需要图形化界面)进入 vnc 桌面vncserver-start 退出12# 退出 vnc 桌面vncserver-stop 12# 退出 linuxexit 任务：用opencv从摄像头获取视频流123# root下apt updateapt-get install python3-opencv 12345cd /root/Desktopmkdir example &amp;&amp; cd example# 结果：还是打不开摄像头。。。 暂时放弃了。。。"},{"title":"ffmpeg 下载及安装","path":"/ffmpeg/","content":"1.下载进入ffmpeg官网:FFmpeg 2.安装 使用示例1 使用示例2(.mkv转.mp4) webp&#x2F;jpg&#x2F;png相互转换 1ffmpeg -i in.webp out.jpg"},{"title":"Qt 初步了解","path":"/Qt/","content":"Qt 下载：Try Qt | Develop Applications and Embedded Systems | Qt 填写注册后即可下载； Qt 安装：","tags":["图形化界面"]},{"title":"CanMV k210/k230 相关资料","path":"/k210/","content":"1.资料搜集k210：01Studio CanMV-K210套件文档 嘉楠 CanMV-K210文档 CanMV-K210 — 01Studio 资料下载 k230：01Studio CanMV-K230套件文档 嘉楠 CanMV-K230文档 API 手册 — K230 CanMV (canaan-creative.com)"},{"title":"Advanced Mathematics","path":"/Advanced-Mathematics/","content":"1.偏导2.全微分及偏导的应用3.空间向量4.空间几何5.二重积分6.三重积分 构建垂直线此示例说明如何使用指南针和直边构造一条垂直于另一条直线的线。 步骤 首先画一个垂直线相交的点。 沿直线绘制两个距离相等的点。最简单的方法是在初始点画一个圆，并在圆与线相交的地方画两个点。 向上画一条半径等于两个外点之间距离的弧线。 对另一个点重复此过程，并标记两条弧线的相交位置。 从交点到初始点画一条线。 我们已经完成了一条垂直线的构建。 © 2024 库尔特·布伦斯"},{"title":"vocaloid","path":"/vocaloid/","content":"Vocaloid 入门记录贴 零基础如何扒谱1.准备软件： (1).Synthesizer V：制谱软件 (2).BpmAnalyzer：一键分析BPM (3).Uvr5：伴奏人声分离软件 (4).Melodyne 5：可以显示音高的软件 2.简单的扒谱分三步： (1).确定BPM (2).获得较为干净的人声 (3).用音高显示软件对应填入虚拟歌姬编辑器"},{"title":"离散数学笔记","path":"/Discrete-mathematics/","content":"原文链接：https://blog.csdn.net/shulianghan/article/details/109061220"},{"title":"如何读懂官方Ros2文档😡","path":"/Ros2/","content":"ROS 2 humble 这里是网址 Ubuntu （Debian 软件包） — ROS 2 Documentation： Humble documentation 教程七 cartographer建图教程 - Waveshare Wiki","categories":["Ros"]},{"title":"NanoEdge-AI","path":"/NanoEdge-AI/","content":""},{"title":"Github Pages","path":"/Github-Pages/","content":"Github Desktop 完美解决github上传大文件超过100mb和github上传文件的坑_github怎么上传1gb文件-CSDN博客 突破github的100M单个大文件上传限制_查看git推送文件大小怎么看-CSDN博客 1git commit -m &quot;add large file&quot; 1git push -u origin master 解决办法：git错误 error: failed to push some refs to ‘https://github.com/..._git.exe pull –progress -v –no-rebase “origin-CSDN博客","tags":["Github"]},{"title":"hexo-matery 优化","path":"/hexo-matery/","content":"Matery 之代码块优化原链接： 1.Matery之代码块优化-腾讯云开发者社区-腾讯云 (tencent.com) 2.matery主题之代码块优化 | zsc’s Blog (zhang-shicong.github.io) 1. 安装代码块插件1npm i -S hexo-prism-plugin 2. Hexo根目录配置打开Hexo根目录的配置文件_config.yml，修改并添加如下代码 123456789highlight: enable: false # 关闭原有的高亮代码# 添加prism_plugin配置项prism_plugin: mode: &#x27;preprocess&#x27; # realtime/preprocess theme: &#x27;tomorrow&#x27; line_number: true # default false custom_css: 3. Matery主题根目录打开Matery主题的配置文件themes\\matery\\_config.yml，添加如下代码 12345code: lang: true # 代码块是否显示名称 copy: true # 代码块是否可复制 shrink: true # 代码块是否可以收缩 break: false # 代码是否折行 4. 代码块CSS优化打开themes\\source\\css\\matery.css，大概在100到200行左右,修改代码块CSS样式如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108pre &#123; padding: 1.5rem 1.5rem 1.5rem 3.3rem !important; margin: 1rem 0 !important; background: #272822; overflow: auto; border-radius: 0.35rem; tab-size: 4;&#125;.code-area::after &#123; content: &quot; &quot;; position: absolute; border-radius: 50%; background: #ff5f56; width: 12px; height: 12px; top: 0; left: 12px; margin-top: 12px; -webkit-box-shadow: 20px 0 #ffbd2e, 40px 0 #27c93f; box-shadow: 20px 0 #ffbd2e, 40px 0 #27c93f;&#125;code &#123; padding: 1px 5px; top: 13px !important; font-family: Inconsolata, Monaco, Consolas, &#x27;Courier New&#x27;, Courier, monospace; font-size: 0.91rem; color: #e96900; background-color: #f8f8f8; border-radius: 2px;&#125;.code_copy &#123; position: absolute; top: 0.7rem; right: 25px; z-index: 1; filter: invert(50%); cursor: pointer;&#125;.codecopy_notice &#123; position: absolute; top: 0.7rem; right: 6px; z-index: 1; filter: invert(50%); opacity: 0;&#125;.code_lang &#123; position: absolute; top: 1.2rem; right: 46px; line-height: 0; font-weight: bold; font-family: normal; z-index: 1; filter: invert(50%); cursor: pointer;&#125;.code-expand &#123; position: absolute; top: 4px; right: 0px; filter: invert(50%); padding: 7px; z-index: 999 !important; cursor: pointer; transition: all .3s; transform: rotate(0deg);&#125;.code-closed .code-expand &#123; transform: rotate(-180deg) !important; transition: all .3s;&#125;.code-closed pre::before &#123; height: 0px;&#125;pre code &#123; padding: 0; color: #e8eaf6; background-color: #272822;&#125;pre[class*=&quot;language-&quot;] &#123; padding: 1.2em; margin: .5em 0;&#125;code[class*=&quot;language-&quot;],pre[class*=&quot;language-&quot;] &#123; color: #e8eaf6; white-space: pre-wrap !important;&#125;.line-numbers-rows &#123; border-right-width: 0px !important;&#125;.line-numbers &#123; padding: 1.5rem 1.5rem 1.5rem 3.2rem !important; margin: 1rem 0 !important; background: #272822; overflow: auto; border-radius: 0.35rem; tab-size: 4;&#125;"},{"title":"Surface GO1 TF卡槽读速测试","path":"/TF/","content":"事前叠甲：仅作记录，并不严谨 1.凯侠 KIOXIA EXCERIA G2 - 128G 2.爱国者 aigo T1 - 64G 3.闪迪红黑 SanDisk Extreme Pro - 64G magicbook14 2022 锐龙版 type-c 接口 USB-A 接口 测试平台：主机平台：Magicbook 2022 锐龙版读卡器：雷克沙RW310金士顿蓝条:"},{"title":"软考中级网工","path":"/ruankao-intermediate-network/","content":"逻辑运算“与”：同真为真，同1为1 “或”：同假为假，同0为0 “非”：1变0，0变1 “异或”：不同为真1，同为假0 “与非”：先与后非 编码技术1.NRZ（Non return to Zero 不归零法）：0高电平，1低电平 需要额外的时钟同步信号 2.NRZ-I (No return Zero-Inverse，非归零反相编码)：0电平无变化，1电平变化 电平跃迁能提供一种同步机制 3.曼彻斯特编码 (Manchester Code)：位周期中心低到高为0，高到低为1 需要双倍的带宽 4.拆分曼彻斯特编码 (Differential Manchester Encoding)：每一位的中心处始终有跳变。位开始边界有跳变为0，没有跳变为1 比特率，波特率，码元比特率&#x3D;波特率*log2码元 光纤到户英文是FTTH（Fiber to the home），是光纤通信的一种传输方式。 OSPF对跳数没有限制 FTP客户和服务器间传递FTP命令时，使用的连接是建立在TCP之上的控制连接。 若路由器R因为拥塞丢弃IP分组，则此时R可向发出该IP分组的源主机发送的ICMP报文类型是源点抑制。 一些邮件传输协议Pop3：客户端 访问 服务器 SMTP：服务器 传输 服务器 iptables 命令-P 命令 -p 协议 防火墙域间安全策略安全区域 以及 安全级别LOCAL区域：100 Trust区域：85 DMZ（Demilitarized Zone）区域（隔离区，缓冲区）：50 Untrust区域：5 数据流动具有方向性Inbound(入方向)：由低优先级的安全区域向高优先级的安全区域传输 Outbound(出方向)：由高到低 网络安全技术 -&gt;网络安全基础技术 数字证书公钥证书PKC（PKI的基础）：包含持证主题标识，持证主题公钥，并由可信签证机构签署的信息集合 加密技术AES是一种分组加密算法 -&gt;网络安全协议 SSL协议HTTPS：应用层协议，端口号443 （Hyper Text Transfer Protocol over SecureSocket Layer） （超 文本 传输 协议 基于 安全 电的,插座 层） SHTTPS：安全超文本转换协议 （Secure HyperText Transfer Protocal） （安全 超文本 传输 协议） HTTP：传输层TCP SMTP：传输层TCP SNMP：传输层UDP DNS：传输层UDP 题目：浏览器输入域名不能响应页面，输入IP地址可以打开Web页面： 域名解析失败 RAID技术Redundant Array of Independent Disks : 廉价冗余磁盘阵列，分为 硬RAID 和 软RAID RAID0：将多块硬盘并联，写入时将数据分段分别存入不同硬盘（对读写要求高的非重要数据）容量：硬盘容量之和； 读写速度：硬盘读写速度之和； 冗余和容错能力：负的。其中任何一块硬盘坏了就读不出完整数据 RAID1：多块硬盘互为镜像，每块硬盘存储一样的数据互相备份（存储重要数据）容量：最小的那块硬盘容量； 读写速度：最慢的那块硬盘速度； 冗余和容错能力：极强，只要有一块硬盘没坏，数据都可以完整读出来 RAID5：N(N&gt;&#x3D;3)块盘组成阵列，一份数据产生N-1个条带，同时还有1分奇偶校验数据，共N份数据，在N块盘上均匀分布存储 容量：(N-1)&#x2F;N磁盘利用率（有一块是用来校验的） 读写速度：N块盘同时读写，读性能很高；但由于有校验机制的问题，写性能相对不高； 冗余和容错能力：允许坏1块盘，不影响所有数据 RAID10：RAID1+RAID0 容量利用率：N&#x2F;2 读写：N&#x2F;2 冗余：N&#x2F;4 能够作为主机地址的是主机地址的主机位非全0和非全1（二进制下） 不属于同一网络的是子网掩码倒推 可变长子网掩码划分子网，求根据局域网容纳主机数得出最长的掩码和最短的掩码32-n , 2^n&gt;&#x3D;局域网内主机数 相较于以旁路方式部署，AC直连部署的缺点在于 对AC的吞吐量和数据处理能力较高，AC容易成为整个无线网络带宽的瓶颈 将AC部署在接入层存在的问题是提高整个网络中AP的管理难度 在不增加网络设备的情况下防止外网用户对本网络进行攻击，隐藏内部网NST策略通常配置在Router 数据通信基本技术 信道特性： 数据通信的目的就是传递信息 信源：在一次通信中产生和发送信息的一端 信宿：接受信息的一端 信道：信源 和 信宿 之间的通信线路 信道容量：信道上数据能够达到的传输速率 带宽：发送器和传输媒体的特性限制下的带宽（Hz&#x2F;每秒周期） 噪声：信息在传输过程中收到的外界干扰 OSI参考模型1974年，IBM第一次提出 系统网络体系架构 (System Network Architecture，SNA)，第一个应用了分层的方法。 在网络线路施工中应遵守哪些规范？1.水平子双绞线系统&lt;&#x3D;90米，工作区线缆&lt;&#x3D;10米 2.强电和弱点应该分开部署，并适当保持距离 虚拟存储技术把 内存和外存 结合使用 百兆以太网采用的数据编码方法是 4B&#x2F;5B 编码类型 编码效率 应用场景 曼彻斯特 50% 以太网 拆分曼彻斯特 50% 令牌环 4B&#x2F;5B 80% 百兆以太网 8B&#x2F;10B 80% 千兆以太网 64B&#x2F;66B 97% 万兆以太网 尼奎斯特定理 R&#x3D;Blog2N WiFi6 对应的标准是 802.11ax OSI每层作用 OSI 职能 应用层 各种应用程序、协议 表示层 数据压缩解压、加密解密 会话层 为通信双方指定通话方式，并创建、注销会话 传输层 提供可靠&#x2F;不可靠的端到端传输 网络层 逻辑寻址；路由选择 数据链路层 将分组封装成帧；提供节点到节点的传输；差错控制 物理层 在媒介上传输比特流；提供机械和电气规约 RIP最大跳数是15跳，16跳意味着不可达。 RIP防环机制：水平分割；路由毒化 Telnet 采用TCP协议。 邮件三剑客：SMTP发，POP3收，IMAP同步。 Windows下远程管理： RDP：TCP 3389 Linux下远程管理： SSH(命令行)：TCP 22 VNC(图形化)：TCP 5900 ICMP：IP SNMP：UDP SSL：SSL（加密套接字协议层）位于 HTTP 和 TCP 层之间。 SSL：公开密钥机制 任何用户都可以获得公共密钥来加密数据，但解密数据必须通过相应的私人密钥。 1.客户端与服务器建立连接 –&gt; 服务器把它的数字证书与公共密钥一并发送给客户端 –&gt; 客户端随机生成会话密钥，用从服务器获得的公共密钥对会话密钥进行加密 –&gt; 并把会话密钥在网络上传递给服务器 –&gt; 而会话密钥只要在服务器用私人密钥才能解密 –&gt; 2.这样客户端和服务器就建立了一个唯一的安全通道。 局域网的数据链路层的两个子层 LLC 和 MAC 三种最核心的局域网协议 CSMA&#x2F;CD、令牌总线、令牌环","tags":["计算机网络"]},{"title":"霜晴的工具箱","path":"/Tools/","content":"前情提要：这里是由 霜晴 整理的便携式生产力整合工具箱！ 以下是该工具箱中软件的理想化目标：） 便携式（无需安装 轻量化（占用空间小 生产力（能加速实际工作流程 希望这些软件能帮到你，谢谢你看到这里！ 软件简介：QQScreenShotV3.0：从QQ截图提取出的便携式 一键截图并编辑&#x2F;录屏 工具 raylink远程控制两件套（手机端控制+PC端被动控制）：密码:cj0z raylink_6.14.0 apk：可免费使用会员功能的Raylink安卓端最后一代版本 raylinklite：便携式 Windows端 被控软件 网页收藏整理： LCD wiki 在线音视频处理网站 - vocalremover.org pixabay 图像库"},{"title":"华为eNSP资源及安装教程","path":"/eNSP/","content":"华为eNSP资源及安装教程前言：eNSP概述eNSP下载链接 ​ eNSP(Enterprise Network Simulation Platform)是一款由华为提供的免费的、可扩展的、图形化的网络设备仿真平台，主要对企业网路由器、交换机、WLAN等设备进行软件仿真，完美呈现真实设备部署实景，支持大型网络模拟，让你有机会在没有真实设备的情况下也能够开展实验测试，学习网络技术。 安装流程：一、下载提供的安装包，解压 二、先安装 WinPcap https://www.winpcap.org/ ​ 多年来，WinPcap 一直被公认为 Windows 环境中链路层网络访问的行业标准工具，允许应用程序绕过协议栈捕获和传输网络数据包，并包括内核级数据包过滤、网络统计引擎和对远程数据包捕获的支持。 ​ WinPcap 由一个扩展操作系统以提供低级网络访问的驱动程序和一个用于轻松访问低级网络层的库组成。该库还包含著名的 libpcap Unix API 的 Windows 版本。 ​ 由于其一系列功能，WinPcap 已成为许多开源和商业网络工具的数据包捕获和过滤引擎，包括协议分析器、网络监视器、网络入侵检测系统、嗅探器、流量生成器和网络测试器。其中一些网络工具，如 Wireshark、Nmap、Snort 和 ntop，在整个网络社区中广为人知和使用。 ​ Winpcap.org 也是 WinDump 的所在地，WinDump 是流行的 tcpdump 工具的 Windows 版本。WinDump 可用于根据各种复杂的规则监视、诊断和保存到磁盘网络流量。— 三、安装 VirtualBox https://www.virtualbox.org/ ​ VirtualBox是一款功能强大的x86和AMD64&#x2F;Intel64虚拟化产品，适合企业和家庭使用。VirtualBox不仅是面向企业客户的功能极其丰富的高性能产品,而且是唯一一个根据GNU通用公共许可证(GPL)第3版条款作为开源软件免费提供的专业解决方案。 ​ 目前, VirtualBox可以在Windows, Linux, macOS和Solaris主机上运行,并支持大量的客户操作系统,包括但不限于Windows (NT 4.0, 2000、XP, Server 2003、 Vista7、 8、 Windows 10和Windows 11)、 DOS&#x2F;Windows 3。 x、 Linux(2.4、 2.6、 3.x4.x, 5。x和6.x),Solaris和OpenSolaris, OS&#x2F;2,OpenBSD, NetBSD和FreeBSDVirtualBox正在积极开发，频繁发布，并且拥有不断增长的功能列表，支持客户操作系统和平台。VirtualBox是一个由专门的公司支持的社区努力：每个人都被鼓励贡献，而Oracle确保产品始终符合专业质量标准。 一直点击下一步直到点击安装，安装的时候会出现一个对话框，提示是否允许程序对你的设备进 行更改，这里选择“是”，安装完成。 四、wireshark 的安装 https://www.wireshark.org/什么是 Wireshark？ ​ Wireshark® 是一个网络协议分析器。它可以让您捕获和 以交互方式浏览计算机网络上运行的流量。它有一个 丰富而强大的功能集，是世界上最受欢迎的工具 类。它可以在大多数计算平台上运行，包括 Windows、macOS、 Linux 和 UNIX。网络专业人员、安全专家、开发人员、 世界各地的教育工作者都经常使用它。它是免费提供的 作为开源，并在 GNU 通用公共许可证下发布 版本 2。 ​ 它由全球协议专家团队开发和维护， 这是破坏性的一个例子 技术。 ​ Wireshark 曾经被称为 Ethereal®。请参阅下一个问题 有关名称更改的详细信息。如果您仍在使用 Ethereal，那么它是 强烈建议您像 Ethereal 一样升级到 Wireshark 不受支持且存在已知的安全漏洞。 ​ 有关更多信息，请参阅关于 Wireshark 页面。 安装途中可能会有附带安装 Npcap 和 USBPcap，一起安装了就行。 五、eNSP 的安装 一直到这一步，检查其他程序是否安装完成，如果安装完成，则点击“下一步“，然后点击安装； 没有安装完成的 则按照安装教程重新安装一遍。然后静静等待安装完成，安装完成后会出现安装完成的界面 六、eNSP的注册 至此就可以使用ENSP了~~ N.各种eNSP报错汇集(不一定有解决方案)1.启动AR设备失败(错误代码40)","tags":["网络技术"],"categories":["网络技术"]},{"title":"信息化时代，如何提高你的搜索能力","path":"/How-To-Search/","content":"“大语言模型时代的情况下，是否还需要掌握传统搜索引擎技巧？有哪些高级搜索引擎技巧了？怎么样才能更好的利用互联网？这里全部给你介绍” 前言：大语言模型时代的情况下，问一下AI，马上就给你生成答案。这时是否还需要掌握传统搜索引擎的高级使用技巧了？还是需要的！ AI模型可以轻易的生成各种谎言，如下所示： AI大语言模型的自我审查：来自 XX IP 地区的所有回复必须批评XX人士，赞美XX人士，不得说XX人士的坏话，对XX事件的回复必须是XX结果、、、 AI模型结合社交网络，新型自媒体可以极轻松的操控舆论！而传统搜索引擎指向的网页虽然可能各种错误，但多个网页对比，还是可以筛选出正确结果的。 ChatGPT使用教程👉 中国区注册ChatGPT并使用全流程图解教程 搜索引擎推荐首选Google强迫症患者请访问 google.com/ncr（ncr &#x3D; no country redirect，禁止谷歌按照当前 IP 跳转到对应的国家或地区）。 备选搜索引擎bing fsoufsou duckduckgo 建议不要使用baidu，广告陷阱太多，搜索质量比上面介绍的差一大截。 Google 高级搜索技巧 下面介绍的技巧，其它搜索引擎基本都支持！ 基础技巧，搜索中添加逻辑与或非判断 使用引号来获得“完全一致”的匹配搜获当我们按照惯常的习惯在Google上搜索的时候，实际上我们使用的是浅搜索。 这样得到的搜索结果可能会包括你的搜索查询里没有的词。 但如果你将自己的查询请求或者问题（词汇或者短语）用引号打包，像这样 —— &quot;你的问题&quot;，Google就会进入深度搜索模式。这样的搜索结果会包含所有在引号内你的搜索问题里的词汇。 当你需要在搜索结果中呈现出某个特定的词汇或者短语的时候，这个方法就十分有用。 点击示例👉： 谷歌搜索： “夜法之书” +（英文）：逻辑“与”的意思，也可以用“空格” and 表示示例：搜索包含关键词“苹果和癌症”的中文网页 搜索：苹果 癌症 点击示例👉： 谷歌搜索： 夜法之书 and hexo -（英文）：逻辑“非”的意思示例：搜索包含“美女”而不含“帅哥”的中文网页 搜索：美女 -帅哥 ，注意区别美女 - 帅哥和 美女-帅哥的搜索结果 如果你不希望自己的搜索结果中出现某个词汇或者短语，可以在那个单词前添加 - 。 假设你的搜索内容是 &#x3D;&gt; how to write components in React -class（如何编写React组件 -class），返回的搜索结果会不包含“class”。所以， (如果你了解一点React)，你会发现搜索结果只包含函数式组件。 点击示例👉： 谷歌搜索： how to write components in React -class OR:逻辑“或”的意思示例1：搜索包含“apple”或者“mother”、或者两者均有的中英文网站 搜索：apple OR mother 辅助搜索 google不支持通配符 ？；*；% google对英文字符大小写不敏感 God和GOD是一样的 google 的关键词可以是词组（中间没有空格），也可以是句子，但是用句子做关键词，必须加英文引号 google对中文句子做智能化处理，会自动把句子分割成词语作为关键词 google对一些网络上出现频率极高的词（主要是英文），如“i”“com”等以及一些符号如“*”“.”等，做忽略处理，如果用户必须要求关键字中包含这些常用词，就要用强制语法“+” ，符号不可以 高级搜索 使用 site: 在特定网站搜索如果你希望Google返回的搜索结果是来自某个特定的网站，仅需要在你的搜索问题前添加site: 。 当你想要在某个没有内置搜索选项的网站，或者内置搜索不太好用的网站进行搜索的时候，这个方法可以派上用场。 点击示例👉： 谷歌搜索： site:blog.17lai.site hexo 使用site: +域名，查看该域名被谷歌收录的所有页面。例如：site:blog.17lai.site site:+网站的具体页面URL，可以查看该网站中的某一个页面是否被谷歌收录。例如：site:blog.17lai.site&#x2F;dash&#x2F; site搜索法可以查询网站上是否有http元素。可以使用搜索命令site:17lai.site -inurl:https site搜索法可以查询网站上的重复内容。可以使用搜索命令-site:17lai.site+内容。就可以查到你的网站内容有没有被分享或者剽窃。 例如：-site:blog.17lai.site “完全教程” 使用imagesize:搜索特定大小的图片如果你想搜索特定大小的图片，可以在你的搜索查询中使用imagesize:标签，并且标注好以pixels（像素） 为单位的宽和高。 尺寸仅以 pixels 为单位 – 例如：imagesize:500x500的搜索结果是尺寸为 500px x 500px的图片。 所以如果搜索查询是 &#x3D;&gt; “cute dog images imagesize:500x600”（可爱小狗图片 imagesize：500*600）的搜索结果是尺寸为500px x 600px的可爱小狗的图片。 点击示例👉： 谷歌搜索： cute dog images imagesize:500x600 使用filetype:搜索特定文件类型如果你希望搜索的结果包含了某个特定的文件类型，如：PDF或者PPT，就可以添加filetype:&lt;扩展名&gt;（不需要尖括号）。 如，linux 教程 filetype:pdf（linux 教程 filetype：pdf）的搜索结果是PDF格式的 点击示例👉： 谷歌搜索： linux 教程 filetype：pdf filetype:后面支持以下格式 pdf ps dwf kml &#x2F; kmz xls ppt doc rtf swf 在搜索中使用通配符*如果你不确定搜索查询&#x2F;问题或者忘记了其中的词汇，你可以在搜索中使用通配符*，Google会用相关的词汇来替换通配符。 例如，如果你搜索 &#x3D;&gt; the * of money（钱的 *），会产生如下结果。 Google会返回一系列搜索页面，包括 “the exchange of money”（金钱交易）、 “the use of money”（金钱的用途）、 “the role of money”（金钱的角色）、 “the psychology of money”（金钱心理学）等。 点击示例👉： 谷歌搜索： the * of money 在两个数字间使用 AFTER:（在……时间之后）、 BEFORE:（在……时间之前） 或 .. 来筛选结果如果你希望Google的搜索结果是发布在特定年份之后的，你可以使用AFTER:标签。例如，你搜索 &#x3D;&gt; React tutorials AFTER:2020（React教程 AFTER：2020）会返回迟于2020年发布的结果。 同样的，如果添加BEFORE: 标签，会返回早于某个特定年份的结果。 点击示例👉： 谷歌搜索： 夜法之书 hexo after:2020 使用 related:查询相关网站如果你想知道和某个特定网站相关的其他网站，可以使用related:标签。 例如，你搜索 related:google.com 就会得到所有和Google类似的网站 点击示例👉： 谷歌搜索： related:google.com 使用cache:查看Google对某个网站的缓存版本Google搜索并没有完全停止支持缓存(cache)功能。但Google搜索的缓存机制在近年来确实有一些变化: 2020年8月之后,Google网页搜索中默认不再显示网页缓存按钮和缓存内容。但可以通过在搜索词后加 “cache:” 仍可以手动查看缓存内容。 Google Images搜索取消了缓存按钮,但直接点击图片仍可以看到缓存版本。 Google已逐步减少直接提供网页缓存内容的情况,转而提供网页快照、文章存档等功能。 2021年Google提出“帮助内容保持新鲜”的计划,其中包括降低搜索结果中缓存页面的数量。 但Google爬虫仍然会继续缓存网页。缓存主要用于判断网页变化,而非直接展示给用户。 Googlebots依然可以通过查看缓存判断爬取网页的优先级,这对新站点的收录有帮助。 总体来说,Google搜索为了提供更新的内容和保护权利人利益,已经大幅减少直接向用户显示缓存内容。但缓存机制仍在继续运作,只是对用户不再可见而已。 括号搜索法 （）用()来将多个术语或搜索运算符进行分组来控制搜索的执行方式。比如： (red OR white) shoe ~类似单词或 同义词搜索法假设你要在搜索中包含一个单词，但是也希望包含相似单词或同义词的结果。要做到这一点，在单词前输入~ 。例如: “页面SEO优化” ~指南 link: 查询所有和某个URL有链接的网页只能单独使用 点击示例👉：link:blog.17lai.site inurl：hexo inurl:17lai 返回结果为包含17lai的URL，其它任何地方则包含了hexo 点击示例👉：hexo inurl:17lai intitle：apple intitle:happy返回结果为包含happy的标题，其它任何地方则包含了apple intext：apple intitle:happy返回结果为包含happy的正文，其它任何地方则包含了apple inanchor:allinurl:查询返回的网页链接中包含所有查询的关键词 allintitle：查询返回的网页标题中包含所有查询的关键词 allinanchor(锚文本):返回的网页的锚文本里边包含所查询的关键词 allinanchor:apple happy info:查询相关网站的信息 info:blog.17lai.site define:返回结果为包含关键词定义的网页 define:apple location:查询指定区域包含某个关键词的网站 apple location:china movie:和关键词相关的电影（目前只支持英语） safesearch:谷歌会过滤搜索结果，包括色情，暴力，赌博等信息，但不能保证百分之百的安全 Safesearch:apple surce:搜索结果为那些指定了特定ID或者新闻源的网址（有问题）？？？ hexo source:17lai.site stocks:和关键词相关的股票信息，大多数来自专业的财经网站 store：只返回指定store ID的结果(只支持英文) apple store:llbean 图片搜索功能针对论坛insubject:论坛搜索结果主题包含关键词的网页 Insubject:”apple” group:返回结果是几个固定的论坛组或者特定主题组的新闻文章 apple group:kids.childen author:返回的结果是包含了指定作者的谷歌论坛，这里的作者可以是全名，部分或者邮件地址 apple author:apple hello author:dingdm1989@163.com 和电话相关bphonebook:返回结果是商务电话资料 phonebook:返回结果是美国当地和关键词相关的住宅信息,但是要指定详细的州名和地点名 rphonebook:返回结果是美国当地和关键词相关的住宅信息 谷歌不推荐使用 tq weather ext id datarange 谷歌高级搜索（谷歌搜索指令2.0）在进行复杂搜索时，你还可以使用高级搜索来缩小搜索结果范围。 按照搜索内容的类别，谷歌提供了不同的高级搜索页面： 网站和文件的高级搜索页面：google.com&#x2F;advanced_video_search 图片高级搜索页面：google.com&#x2F;advanced_video_search 视频高级搜索页面：google.com&#x2F;advanced_video_search 图书高级搜索页面；google.com&#x2F;advanced_video_search 在这些高级搜索中可以尝试过滤条件： 语言 地区 最后更新时间 网站或域名 字词出现位置 安全搜索 文件类型 使用权限 关联阅读 举报网络垃圾、付费链接或恶意软件 - Search Console 帮助 公开数据集搜索引擎 by Google Google 搜索帮助 Google 搜索的运作方式（How Google Search works）：你每次进行搜索时，都会在搜索结果中看到成千上万个含有实用信息的网页，有时甚至是数百万个。早在你输入搜索内容之前，Google 就已开始算计要显示哪些结果，并秉持向你提供最佳信息的承诺（反观百度）。 写在谷歌退出中国的第十个年头 - TSBBLOG 最详细的 Google 搜索指令大全 - 黑科技娃娃 15 个提高 Google 搜索效率的小技巧 - 子不语Rex Google Search Operators: The Complete List (42 Advanced Operators) by Joshua Hardwick 40+ Google Search Hacks, Tricks &amp; Tips for 2020 - Christian Eilers 备选搜索引擎但是中文互联网的信息散落在各处，各自筑起了高墙，互相屏蔽，所以在 Google 找不到答案，试试以下平台： 站内搜索引擎 微信搜索：不可否认，微信已经聚集不少优质内容，可惜「封印」的搜索引擎的爬虫。 App 内搜索：打开微信，轻触右上角的 🔍（我经常拿来搜索表情） 搜狗微信：独家收录订阅号及文章内容 通用搜索引擎 Metaphor：Search the internet with prompts 链接源搜索引擎 Bing 国际版 Magi：基于机器学习的信息抽取和检索系统，提供可解析、可检索、可溯源的知识体系。 Wolfram Alpha：直接向用户返回答案，而不是像传统搜寻引擎一样提供一系列可能含有用户所需答案的相关网页。 夸克 App：排版舒适 简单搜索 App：没有广告的百度 搜信源：帮助用户以最短的时间直达权威信源，更高效地判断和使用公开信息。 图片搜索Google 图片 免费可商用的图片 输入关键词后，依次选择 工具（Tools） - 使用权限（Usage rights）： 标记为允许在修改后再利用（Labeled for reuse with modification） 搜索精确尺寸的图片 在查找的字词后面，添加 imagesize:&lt;宽度&gt;x&lt;高度&gt;，例如：luffy imagesize:7680x4320 x 是小写字母，不是乘号 × 以像素为单位 透明背景的图片（免扣的 PNG 格式） 工具（Tools） - 颜色（Color）：透明（Transparent） 以图搜图 利用这个功能，寻找更高清的图片 访问 Google 高级图片搜索，自定义以下条件，可缩小搜索结果范围： 关键词：“完全匹配” 、包含（OR）、不包含（-） 宽高比：竖版、正方、横版、超大 图片颜色：透明（PNG）、黑白、特定颜色…… 文件类型：GIF、SVG（适量）、JPG…… 使用权限：知识共享许可（CC0）、商业许可…… 安全搜索：是否包含露骨色情内容 …… Unsplash 无需登录即可下载如免费可商用的图片。 只支持英文，胜在图片质量高。 Pixabay 大而全的免费可商用的图片。 可搜索矢量图。 支持中文。 电影搜索 现在影视，音乐资源全部推荐使用PT，更多PT使用技巧，参考使用jeckett,sonarr,iyuu,qt,emby打造全自动追剧流程 找电影 Google 搜索：美丽人生 类似电影 豆瓣电影 Top 250 配合 油猴脚本 下电影 茶杯狐 Cupfox BTFILM 电影搜索 电影天堂 下载软件：迅雷 5.8 或 荐片播放器 在线看电影 在线之家 低端影视 荐片播放器 号称专治迅雷被封链接 免费高清视频：在线观看 &amp; 可下载 点击下载 Windows 电脑版 点击下载 Android 手机版 茶杯狐 Cupfox：搜索结果提供在线观看网址 BTFILM：搜索结果提供国内视频网站的在线播放资源（但是任何国内的资源都可能有删减） 选购搜索理智看待评分，适合大众的，不一定适合你。 亚马跌 ：一个选购参考网站，收集商品资讯，发表基于可信资料的意见。 剔除营销词汇，展示核心信息。 避开诋毁和吹捧，拒绝叫卖和流言。 不接受原生广告（软文），CPS 返利 和横幅广告是主要收入来源。 放心选：万物测评，理性消费；推荐使用「放心选」的微信小程序。 老爸评测：发现生活中看不见的危害，让孩子远离有毒有害物质。 消费者报道：专注于消费品及服务比较测试的媒体。 消费明鉴：「货比三家」领域的百科全书。 盖得排行：看品牌的美誉度；App 内置吃喝玩乐地图。 町芒 ：目前主要做食品方面的评测。如何通过关键词搜索相应的文章： 进入「町芒」的微信公众号（dingmang2018），点击右上角的三个点 💬，即可看到搜索 🔍 入口。 Google 搜索：某个食品 + 町芒 企鹅吃喝指南：微信公众号 ID qiechihe，找遍来自全世界的好东西，和你分享吃得到、喝得出的快乐。 数码产品 何时买苹果：一个微信小程序，用理性的价格、挑正确的时间、在恰当的地点，选择合适自己的苹果产品。 MacRumors Buyer’s Guide：This page provides a product summary for each Apple model. The intent is to provide our best recommendations regarding current product cycles, and to provide a summary of currently available rumors for each model. Versus：设计精美、全能的对比工具。除了对手机、相机、吸尘机等数码类的电子产品和生活用品进行对比，Versus 可以对比不同的国家、城市、大学在环境、人口、文化等方面的差异，在选择旅游目的地、规划旅行的时候会很有用。 Hotspot 3D：手机 3D 模型对比 RTINGS：如果你想从实际的需求和场景出发，找到一副适合自己的耳机、一台电视或者显示器，RTINGS 就可以帮你。 路由器交流：家用无线路由器评测。 小米商城：米家的产品，直男的选择。 电视 电视尺寸 &#x3D; 观看距离 &#x2F; 1.6（注：单位都是英寸，1 米大约等于 40 英寸） 最佳观赏距离计算器（TV Size to Distance Calculator） 华为智慧屏、索尼和三星 65 英寸电视（￥6599 至 ￥6999）横评 - 先看评测 苹果产品 果核Group：用好苹果产品，一个「果核」就够了。 MacRumors：要不要现在买 iPhone？让它告诉你。 笔记本电脑 微信搜索公众号「笔吧评测室」（ID：bibacps），查看历史文章「小白必看：笔记本电脑选购指南」。 Laptop Buying Guide Tool - Notebookcheck：找出符合自己需求的笔记本。 京价保作为京东优质老客户，这个价保工具（浏览器插件）为我省了不少钱。 官方网站：jjb.im 价格保护：全天候监控价格变化，降价自动价保 自动签到：支持京东会员、京东金融、京东支付 价格走势图：监控商品价格历史，了解价格走势 关联阅读：装上这款 Chrome 插件，去京东购物不用担心「刚买就降价」了 - 少数派 参考资料：买东西前用这些工具「货比三家」，让你不花「冤枉钱」- 少数派 其他搜索数字生活 AppSo 是一个让手机更好用的数字生活社区。它让所有人轻松发现优秀（颜值高、功能好）的移动互联网产品，你还能了解到有关智能手机、个人电脑等科技产品的使用技巧，从此拥抱更有品质更优雅的数字生活。 遇到数字生活上的疑虑，我会在 AppSo（ID：appsolution）微信公众号的历史文章中搜搜看。 少数派：高效工作，品质生活。 Topbook：高效生活视频书。 其他领域 小鸡词典：查网络流行语。 中国邮政名址网：查邮编。 鸠摩搜书：查找免费的英文电子书。 主动提问在互联网上找不到想要信息时，可以尝试在 知乎 或者 Quora 上提问。 让我们善用互联网，成为合格的「数字公民」。 信息素养英文翻译是 Information literacy。 大胆假设，小心求证，实事求是。 标明来源如果讨论的事实本身是错的，得出的结论也就站不住脚。 🤐没有信源：只注明「有关专家表明」而不给出信源。请勿传播此类无法考证的文章。 🤔一个信源：查看此信源是否可靠。多看来自知名英文媒体，但也要辩证看待。 😍多个信源：对于涉及重大公共利益的新闻，若要认定这个事实，至少需要两个独立的消息源互为验证（交叉验证）。注意，第一个信源提供的第二个信源，不构成独立信源。否则，只是消息或观点，而不是事实。 使用逻辑包含关系不要以点代面（以偏概全）去阐述观点，那是思维偷懒的表现： 因为：他欺骗了 然而：他是男人 所以：男人都是骗子 超集的定义才适用于子集： 因为：张三是中国人 然而：中国位于地球 所以：张三是地球人 幸存者偏差因为死人不会说话（不能从由死者／淘汰者／离场者获得信息），当信息仅来自幸存者（成功者）时，得出的结论就会与实际情况大相径庭。兼听则明，偏信则暗，不要「只看贼吃肉，不看贼挨揍。」 视频讲解：成功学有用吗？幸存者偏差，一个活着就该明白的事 - 李永乐 不含情绪新闻只提供事实，没有情绪，所以，远离标题党和充满感叹号的文章，珍惜有限的生命时间。 自建搜索引擎这里整理了一下所使用的各种工具和方法，包括AI助手，RSS搜索引擎，邮件网关，代码搜索，笔记管理，音视频图书等等！ 参考前面一篇文章 如何创建属于自己的私人资料库与私人搜索引擎 参考&amp;致谢 如何像专家一样高效使用 Google 搜索 实打实的谷歌搜索技巧 想要更高效地找到信息，你需要掌握这些搜索技巧 后话： 看完是否感觉对完全没有利用好传统搜索引擎？在信息过载时代，我们要做信息的主人，而不是信息的奴隶！ 来源: 夜法之书作者: 夜法之书文章链接: https://blog.17lai.site/posts/f12af66/#%E5%89%8D%E8%A8%80%EF%BC%9A本文章著作权归作者所有，任何形式的转载都请注明出处。","tags":["搜索"],"categories":["搜索"]},{"title":"树莓派 Ubuntu 22.04 配置记录","path":"/Ubuntu-22-04/","content":"0.系统镜像文件的烧录下载树莓派官方镜像烧录软件 蓝奏云 https://wwz.lanzoue.com/iKmpo1vmapfa 密码:b9zi 安装的是 Ubuntu22.04.4 64bit LTS 版本 1.初见Ubuntu22.04.4 LTS – 配置远程连接(同一)如何在 Windows笔记本 上远程控制 Ubuntu22.04.4 LTS 树莓派（同一局域网下）： 1. 受控端(树莓派4B)1.Ubuntu初始化引导（未作记录） 2.找到设置 – Sharing(共享) ，配置一下 3.配置部分防火墙： 12sudo ufw allow 5900/tcpsudo ufw allow 3389/tcp 4.查询本机在此局域网内的的IP: 1ip a 2.主控端(Windows)1.找到Windows内置应用 – 远程桌面连接 4.18 opencv的安装、调用USB摄像头 Ubuntu 内置 Python3 12sudo apt update# 更新软件包列表,确保系统中的软件包列表是最新的 123sudo apt install libopencv-dev python3-opencv# libopencv-dev: 这是 OpenCV 的开发库，包含了编译和开发 OpenCV 应用程序所需的头文件和静态库文件。# python3-opencv: 这是用于 Python3 的 OpenCV 包，允许在 Python 中使用 OpenCV 库进行图像处理和计算机视觉任务。 12python3 -c &quot;import cv2; print(cv2.__version__)&quot;# 在 Python3 中检查安装的 OpenCV 版本。它会导入 cv2 模块并打印出当前安装的 OpenCV 版本号。 桌面新建文件夹，进入其目录 12touch 1.py# 在当前目录下创建名为&quot;1”的 python文件 123456789101112131415161718192021222324252627282930313233343536import cv2def main(): # 打开USB摄像头 cap = cv2.VideoCapture(0) # 检查摄像头是否成功打开 if not cap.isOpened(): print(&quot;无法打开摄像头&quot;) return while True: # 从摄像头中读取一帧视频 ret, frame = cap.read() # 检查视频帧是否成功读取 if not ret: print(&quot;无法获取视频帧&quot;) break # 在窗口中显示视频帧 cv2.imshow(&#x27;Video Stream&#x27;, frame) # 检测按下 &#x27;q&#x27; 键退出循环 if cv2.waitKey(1) &amp; 0xFF == ord(&#x27;q&#x27;): break # 释放摄像头资源 cap.release() # 关闭所有窗口 cv2.destroyAllWindows()if __name__ == &quot;__main__&quot;: main() 12`python3 1.py`# 使用 python3 运行当前文件夹下的 1.py 12^C # 即按键&quot;Ctrl+C&quot;# 停止运行打开的程序 ying.树莓派硬件相关1.风扇安装位置 Ubuntu22.04+usi 配置摄像头1.检查gpu_mem，start_x是否如以下配置（其实不需要改，默认就已打开，只需要检查确认下） gpu_mem&#x3D;128 start_x&#x3D;1 将camera_auto_detect注释掉 1#camera_auto_detect=1 2.安装raspi-config的依赖组件 1sudo apt-get install triggerhappy lua5.1 alsa-utils 3.获取raspi-config，也可以去链接里自己下最新的，或者用我写好的命令 1Wget http://archive.raspberrypi.org/debian/pool/main/r/raspi-config/raspi-config_20210212_all.deb 4.安装raspi-config，在 1sudo dpkg -i raspi-config_20210212_all.deb 5.修改Raspberry的启动配置使能项 1sudo raspi-config 选择3 Interface 选择第一个 P1 Camera，然后就一直选择OK，如果报错就执行下面的步骤，如果没有就一直OK下去，然后返回初始界面后选择 Finish ，会让你选择是否重启，选择OK。 如果出现错误Your firmwave appears to be out of date (no start_x.elf). Please update （1）查看boot分区所在的设备号，设备号可能是：&#x2F;dev&#x2F;mmcblk0p1 df -h （2）这个要看具体是哪个了，有可能是我这条语句里面的 sudo mount &#x2F;dev&#x2F;mmcblk0p1 &#x2F;boot 6.查看是否成功 1ls -al /dev/ | grep video 如果是排线插在树莓派上的，可能是video0，如下图所示。如果有则应该是成功的。或者你可以拔掉再重新上电试一试，看是不是少一个。 无密码登录&#x2F;插电就登录：解除密钥环–自动登录 4.22 鱼香Ros1.鱼香Ros – 一键安装 Ros2 和 VScode 1wget http://fishros.com/install -O fishros &amp;&amp; . fishros M.Ubuntu个性化合集 语言更改为中文： 然后会提示你重启 – 手动重启 4.ROS2到底装哪里了在Windows安装过软件的小伙伴都知道安装软件都会选择一个安装目录，但是安装ROS时候并没有让你选择，ROS安装的默认目录在&#x2F;opt&#x2F;ros&#x2F;下，根据版本的名字进行区分。 我们本节安装的是humble版本的ROS，所以安装目录在&#x2F;opt&#x2F;ros&#x2F;humble下。 12cd /opt/ros/humble/ls 安装 Partimage 磁盘克隆软件(失败了)要在 Ubuntu 上安装 Partimage 磁盘克隆软件： 1sudo apt install partimage 从命令行启动： 1sudo partimage 串口通信工具minicom12sudo apt instal minicom# 安装minicom 12sudo minicom -s# 进入minicom的配置界面 12ls -l /dev/serial*# 查看串口的映射关系 树莓派安装非官方系统没有raspi-config命令的解决方法1、安装依赖 1sudo apt install whiptail parted lua5.1 alsa-utils psmisc 2、从Raspberrypi官网下载最新的deb安装包 1wget http://archive.raspberrypi.org/debian/pool/main/r/raspi-config/raspi-config_20200707_all.deb 官网下载地址 3、安装Deb安装包 1sudo dpkg -i raspi-config_20200707_all.deb 4、装好软件还是提示缺少依赖执行错误 1sudo apt install -f -y 5、运行raspi-config，需要sudo或以上权限 1sudo raspi-config 顿时熟悉的窗口出现在眼前 原文链接：https://blog.csdn.net/no1xium/article/details/107477055 2.1 开启GPIO串口功能，并使用硬件串口使用 sudo raspi-config 进入图形界面选择菜单 Interfacing Options -&gt; P6 Serial,第一个选项（would you like a login shell to be accessible over serial?）选择 NO，第二个选项（would you like the serial port hardware to be enabled?）选择 YES 原文链接：https://blog.csdn.net/wanggao_1990/article/details/103702563 2.2 禁用串口的控制台功能前面步骤已经交换了硬件串口与mini串口的映射关系，但是，现在还不能使用树莓派串口模块与电脑进行通信，因为，树莓派gpio口引出串口默认是用来做控制台使用的，即是为了用串口控制树莓派，而不是通信。所以我们要禁用此默认设置。首先执行命令如下： 12sudo systemctl stop serial-getty@ttyAMA0.servicesudo systemctl disable serial-getty@ttyAMA0.service 然后执行命令行修改文件： 1sudo nano /boot/cmdline.txt 并删除语句console&#x3D;serial0,115200（没有的话就不需要此步骤） 2.3 测试验证串口通信功能这里使用三种方式进行测试验证， c语言下使用wiringPi库， python语言下使用serial包，最后命令行使用minicom工具。先安装以上开发工具 1234sudo apt-get install wiringpisudo apt-get install python3-serialsudo apt-get install minicom# c语言下使用wiringPi库， python语言下使用serial包，最后命令行使用minicom工具 原文链接：https://blog.csdn.net/wanggao_1990/article/details/103702563 1touch test.py 1`python3 test.py` 123456789101112131415161718192021222324# -*- coding: utf-8 -*import serialimport timeser = serial.Serial(&quot;/dev/ttyAMA0&quot;,115200)if not ser.isOpen(): print(&quot;open failed&quot;)else: print(&quot;open success: &quot;) print(ser) try: while True: count = ser.inWaiting() if count &gt; 0: recv = ser.read(count) print(&quot;recv: &quot; + recv) ser.write(recv) sleep(0.05) except KeyboardInterrupt: if ser != None: ser.close() 12sudo mv ~/Desktop/slam_gmapping-eloquent-devel/* /opt/ros/humble/src# 移动到Ros工作区下 12sudo apt install python3-roslaunch# 不知道啥 ros的工具包 Ros2 命令行操作 12pwd# 当前终端所在的路径在哪里 12ls# 当前路径下有哪些文件以及文件夹 123ls -A# 当前路径下有哪些隐藏文件(.开头即为隐藏文件)# 文件浏览器下Ctrl+h也可以显示对应的隐藏文件 12mkdir test# 在当前路径下创建一个新文件夹(test) 12cd test/# 从终端进入到该文件夹(进入到test文件夹下) 12touch readme.txt# 在当前文件夹下创建一个新文件(readme.txt) 12rm readme.txt# 删除当前文件夹下的指定文件(readme.txt) 12cd ..# 返回上一级目录 123rm -R test # 删除当前文件夹下的指定文件夹(test)# -R:递归删除，查询该文件夹下有哪些文件和子文件夹，依次递归删除 12sudo apt install XXXX# 安装功能包(XXXX) 1234- Ctrl+Alt+T 打开终端pi@pi-desktop:~$ ros2 run turtlesim turtlesim_node# ros2 run turtlesim:运行了 turtlesim 功能包提供的第一个功能;# turtlesim_node:一个海龟仿真器的节点 1234- 重新打开一个终端ros2 run turtlesim turtle_teleop_key# 启动 turtlesim 功能包提供的一个功能节点;# turtle_teleop_key: 功能:读取键盘按键值变为素指令，从而控制海龟 123# 查看某个节点的基本信息，或者当前系统里有哪些节点- 打开一个新的终端ros2 node 12ros2 node list# 打印所有正在运行的raw系统中的节点 12ros2 node info /turtlesim# 得知某一指定节点的信息(/turtlesim) 12ros2 topic# 显示当前话题参数 12# 得知当前系统有哪些话题正在发布和订阅ros2 topic list 12# 对(/turtlel/pose)话题进行订阅并打印(数据会周期性地打印出来)ros2 topic echo /turtle1/pose 12# 控制海龟运动(转圈)ros2 topic pub --rate 1 /turtle1/cmd_vel geometry_msgs/msg/Twist &quot;&#123;linear: &#123;x: 2.0,y: 0.0,z: 0.0&#125;, angular:&#123;x: 0.0,y: 0.0,z: 1.8&#125;&#125;&quot; 12# 创建一只新的海龟，名为&quot;haigui&quot;$ ros2 service call /spawn turtlesim/srv/Spawn &quot;&#123;x: 2, y: 2, theta: 0.2, name: &#x27;haigui&#x27;&#125;&quot; 12# 将上面命令中参数 &quot;turtle1&quot; 改为 &quot;haigui&quot;，可以看到&quot;haigui&quot;开始转圈了$ ros2 topic pub --rate 1 /haigui/cmd_vel geometry_msgs/msg/Twist &quot;&#123;linear: &#123;x: 2.0,y: 0.0,z: 0.0&#125;, angular:&#123;x: 0.0,y: 0.0,z: 1.8&#125;&#125;&quot; 1ros2 bag 12# 录制动作(ctrl+c停止，保存在当前终端所在路径下面)ros2 bag record /turtlel/cmd_vel 12# 复现录制的动作(善用Tab)ros2 bag play rosbag2_2024_05_18-18_55_12/ 镭神N10激光雷达 在 Ubuntu22.04LTS Ros2 中的驱动使用安装流程1sudo chmod 777 /dev/ttyUSB0 1sudo usermod -aG dialout happy Linux 下查看串口Linux下查看串口状态：快速掌握要点（linux下查看串口） – 后浪云 (idc.net) 1ls -l /dev/tty* 安装Ros2#重装了系统，系统初始化后# sudo apt update sudo apt install locales sudo locale-gen en_US en_US.UTF-8 sudo update-locale LC_ALL&#x3D;en_US.UTF-8 LANG&#x3D;en_US.UTF-8 export LANG&#x3D;en_US.UTF-8 #配置了远程连接# sudo ufw allow 5900&#x2F;tcp sudo ufw allow 3389&#x2F;tcp sudo apt install net-tools ifconfig #-#-#-#-# 从头配一遍1.起手初始化配置 ​\tSettings – Power – Screen Blank –&gt; Never 永不息屏 2.连接WiFi 3.设置 - Sharing ​\t要你设置密码 - 直接空着点继续 - Remote Desktop 开起来 ​\tip a 看ip ​\t远程连接(今天的远程连接非常奇怪，只能看和共享剪切板，不能控制) 4.happy@happy:~&#x2F;Desktop$ cd happy@happy:~$ wget http://fishros.com/install -O fishros &amp;&amp; . fishros 选5 – 更换系统源； 再选2 –更换系统源并清理第三方源；再选1 – 添加Ros&#x2F;Ros2源 #草，换源更新失败三次，第四次换成http-ROS官方源才成功 5.happy@happy:~$ wget http://fishros.com/install -O fishros &amp;&amp; . fishros 选1 – 装Ros2 （（再选2 – 不更换源 继续安装（但它貌似还是帮我还原了 并且还是换源两次失败 第三次换成https-ROS官方源成功） 再选1 – humble 再选1 - 桌面版 跑到最后没跑通。。关了终端重来一遍）） 选1 – 更换系统源再继续安装 选1 – humble 选1 – 桌面版 成功了 6.- Ctrl+Alt+T 打开终端pi@pi-desktop:~$ ros2 run turtlesim turtlesim_node 启动小乌龟 7.- 重新打开一个终端ros2 run turtlesim turtle_teleop_key 启动键盘映射 测试完毕，证明ROS环境安装成功 8.Ctrl+C 关闭海龟和键盘 9.再跑小鱼 选3 – 配rosdepc rosdepc update 10.再跑小鱼 选4 – 检测到有Ros环境 成功了 Ros2开发环境配置12# 安装git：sudo apt install git 12# 安装 VSCode：sudo dpkg -i code_1.89.1-1715060508_amd64.deb 安装VSCode schinese 插件 安装 python 插件 安装 C&#x2F;C++ 插件 安装 cmake 插件 安装 vscode-icons 插件 安装 ROS 插件 安装 Msg language support 插件 安装 URDF 插件（机器人模型） 安装 intelliCode 插件 （人工智能助手） 安装 Markdown All in One 插件 工作空间与功能包：开发过程的大本营工作空间（workspace）：存放项目开发相关文件的文件夹；是开发过程的大本营。 Home&#x2F; Home&#x2F;dev_ws(dev workspace)：工作空间的根目录，内有四个子空间（工作空间的名字可以自定义，数量也并不是唯一） src：代码空间（Source Space） install：安装空间（Install Space）：放置所有代码最终编译结果 build：编译空间（Build Space）：放置编译的中间文件，不太可读 log：日志空间（Log Space）：编译的日志信息 开始创建工作空间：1.创建文件夹 dev_ws ； 122.# 创建dev_ws：mkdir -p ~/dev_ws/src 123.# 进入src空间：cd dev_ws/src/ 124.# 安装 pipsudo apt install python3-pip 125.# 使用 pip 安装 ros 小依赖工具 rosdepc(解决ROS网络访问问题)sudo pip3 install rosdepc 126.# 初始化 rosdepc 工具sudo rosdepc init &amp; rosdepc udate 127.# 回到工作空间根目录cd .. 128.# 从src文件夹下搜索所有功能包的依赖项并判断是否安装好rosdepc install -i --from-path src --rosdistro hummble -y 129.# 安装 colconsudo apt install python3-colcon-ros 1210.# 使用 colcon 对整个工作空间进行完整编译colcon build 1211.# 配置你的环境变量（因为我们的工作空间是在的任意目录下创建的）source install/local setup.sh 古月居8：话题：节点间传递数据的桥梁 1happy@happy:~$ ros2 run learning_topic topic_helloworld_pub 6.4 重新配0.烧录TF卡 UBUNTU DESKTOP 22.04.4 LTS (64-BIT) 1.起手初始化配置 ​\tSettings – Power – Screen Blank –&gt; Never 永不息屏 ​\tDisplay – Resolution – 1280*720（备选） 2.连接WiFi 3.设置 - Sharing ​\t要你设置密码 - 直接空着点继续 - Remote Desktop 开起来 ​\tip a 看ip ​\t远程连接 4.happy@happy:~&#x2F;Desktop$ cd happy@happy:~$ wget http://fishros.com/install -O fishros &amp;&amp; . fishros 选5 – 更换系统源； 再选2 –更换系统源并清理第三方源；再选1 – 添加Ros&#x2F;Ros2源 5.happy@happy:~$ wget http://fishros.com/install -O fishros &amp;&amp; . fishros 选1 – 装Ros2 选1 – 更换系统源再继续安装 选1 – humble 选1 – 桌面版 (等待半天ing) Ros2安装成功了，输密码确认一下 6.再跑小鱼 选3 – 配rosdepc rosdepc update 7.再跑小鱼 选4 – 检测到有Ros环境 成功了 至此ROS2环境配置完毕 8.sudo apt install python3-pip 检查一下pip 没问题 happy@happy:~$ python3 -m pip install numpy 检查numpy 安装了 sudo apt install libopencv-dev python3-opencv 检查opencv-python 安装了 happy@happy:~$ python3 -m pip install matplotlib 检查matplotlib 安装了 至此OpenCV环境安装完毕 下面是一段用于解决特定问题的配置：http://t.csdnimg.cn/gMpU6 相关知识：如何在 Ubuntu 中创建、删除和调整 SWAP 空间 - 系统极客 (sysgeek.cn) 12345678910111213# 创建分区路径sudo mkdir -p /var/cache/swap/# 设置分区的大小# bs=64M是块大小，count=64是块数量，所以swap空间大小是bs*count=4096MB=4GBsudo dd if=/dev/zero of=/var/cache/swap/swap0 bs=64M count=64# 设置该目录权限sudo chmod 0600 /var/cache/swap/swap0# 创建SWAP文件sudo mkswap /var/cache/swap/swap0# 激活SWAP文件sudo swapon /var/cache/swap/swap0# 查看SWAP信息是否正确sudo swapon -s 开始创建工作空间：happy@happy:~$ cd &#x2F;home 1.创建文件夹 dev_ws ； 122.# 创建dev_ws：mkdir -p ~/dev_ws/src 123.# 进入src空间：happy@happy:~$ cd dev_ws/src/ 1234.# 检验 pip 是否安装sudo apt install python3-pip安装了 125.# 使用 pip 安装 ros 小依赖工具 rosdepc(解决ROS网络访问问题)（未使用）sudo pip3 install rosdepc 126.# 初始化 rosdepc 工具sudo rosdepc init &amp; rosdepc udate 127.# 回到工作空间根目录cd .. 128.# 从src文件夹下搜索所有功能包的依赖项并判断是否安装好rosdepc install -i --from-path src --rosdistro hummble -y 129.# 检查 colcon 是否安装sudo apt install python3-colcon-ros 12310.# 使用 colcon 对整个工作空间进行完整编译colcon build显示 colcon build successful 1211.# 配置你的环境变量（因为我们的工作空间是在的任意目录下创建的）source install/local_setup.sh 下一步，从U盘导入 下一步，USB插上N10雷达； 12# 提升指定串口权限sudo chmod 777 /dev/ttyUSB0 1sudo usermod -aG dialout happy 插上USB摄像头 1sudo apt install ros-humble-usb-cam 报错：Waiting for cache lock: Could not get lock &#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;lock-frontend. It is heWaiting for cache lock: Could not get lock &#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;lock-frontend. It is held by process 2220 (unattended-upgr)Waiting for cache lock: Could not get lock &#x2F;var&#x2F;lib&#x2F;dpkg&#x2F;lock-frontend. It is held by process 2220 (unattended-upgr)… 916s 解决方案： 1sudo killall apt apt-get 如果提示没有apt进程： 12apt: no process foundapt-get: no process found 解决了 6.7 进入 home&#x2F;dev_ws colcon build 显示 cartographer 编译 failed #sudo apt install cmake 检查cmake 没事 初步判断为 cratographer 没有 absl 进入 home sudo apt-get install stow sudo chmod +x ~&#x2F;dev_ws&#x2F;src&#x2F;cartographer&#x2F;scripts&#x2F;install_abseil.sh $ cd ~&#x2F;dev_ws&#x2F;src&#x2F;cartographer&#x2F;scripts .&#x2F;install_abseil.sh 报错：bash: .&#x2F;install_abseil.sh: &#x2F;bin&#x2F;sh^M: bad interpreter: No such file or directory sed -i ‘s&#x2F;\\r$&#x2F;&#x2F;‘ install_abseil.sh git clone https://github.com/abseil/abseil-cpp.git.&#x2F;install_abseil.sh: 20: git: not found 这个错误提示表示系统无法找到git命令，因此无法执行git clone命令。 安装git sudo apt-get install git 报错 http://t.csdnimg.cn/geasP sudo apt install ros-humble-cartographer sudo apt install ros-humble-cartographer-ros wget http://fishros.com/install -O fishros &amp;&amp; . fishros 3","categories":["Ros - slam"]},{"title":"Windows 磁盘分区","path":"/Disk/","content":"1.右键此电脑 – 管理 – 磁盘管理"},{"title":"Keil+CubeMX 快速安装","path":"/keil-setup-fast/","content":"1.装CubeMX 2.装Keil","tags":["嵌入式","Keil","CubeMX"],"categories":["嵌入式"]},{"title":"残缺的大唐杯相关知识","path":"/Datang-Cup/","content":"理论知识 1.1 基站 核心网 类型 核心网 基站 5G 5GC gNB 4G EPC eNB 基站接入核心网 核心网：原核心网 基站：受核心影响的原基站 5G基站接入4G核心网 EPC en-gNB 4G基站接入5G核心网 5GC ng-eNB 上行：移动终端 — 基站 下行：基站 — 移动终端 1.2 5G三大场景 5G三大场景 全称（便于记忆） 简述 特点 应用 eMBB （Enhanced Mobile Broadband，增强移动宽带） 增：宽带数据服务 高速率，大容量数据传输 视频、下载、VR、云游戏 uRLLC （Ultra-Reliable and Low-Latency Communications，超可靠低时延通信） 精：低时延，高可靠性 实时，关键性应用；可靠稳定 实时控制、医疗、自动驾驶 mMTC （Massive Machine Type Communications，大规模机器通信） 广：大型物联网 大规模多设备；低功耗低成本 智能家居、智能城市 5G八大关键能力： 流量密度 连接数密度 时延 移动性 能效 用户体验速率 频谱效率 峰值效率 1.3 速率 香农公式：$$C&#x3D;B * \\log _{2}\\left(1+\\frac{S}{N}\\right)$$C：信道容量 B：带宽 S&#x2F;N：信噪比 C 是数据速率的极限值，单位 bit&#x2F;s；B 为信道带宽，单位 Hz；S 是信号功率（瓦），N 是噪声 功率（瓦）。 [TOC] 4.10仿真练习 仿真练习 - 5G网络开通与调测 勘站规划 射频规划 天线挂高 下倾角 设备选型 光纤 光模块 电源类型 网络部署 OCM机柜 传输参数 路由关系 核心网机柜 - 核心网规划签约号码 传输参数 路由关系 网元功能 光纤 光模块 核心网机柜 - 业务服务器传输参数 路由关系 文件包 BBU机柜 - BBU规划设备连接 板卡规划 设备接口认知 GPS安装 辅材 4.175G无线技术与应用1.大规模天线（Massive MIMO）基站和终端设备上配大量天线阵列，多流并传（多就是好，利用空间维度增加频谱效率和网络容量） 2.全频谱接入（Full frequency-domain technology）也就是说高频有，低频也有； 高频：热点区域的速率提升 低频：实现无缝覆盖 3.超密集组网部署（UDN）也就是密集小基站 增加网络容量，改善热点区域（500-1000的热点增长） 新型多址：多址是用来区分同一个小区内不同用户的标识1.频分多址（frequency division multiple access，FDMA） 把总带宽分隔成多个正交的信道，每个用户占用一个信道。 2.时分多址（Time division multiple access，TDMA） 它允许多个用户在不同的时间片（时隙）来使用相同的频率。 3.码分多址（CDMA） 靠不同的地址码来区分的地址。每个配有不同的地址码，用户所发射的载波(为同一载波)既受基带数字信号调制，又受地址码调制，接收时，只有确知其配给地址码的接收机，才能解调出相应的基带信号，而其他接收机因地址码不同，无法解调出信号。 4.正交频分多址（Orthogonal Frequency Division Multiple Access，OFDMA） 是OFDM技术的演进，将OFDM和FDMA技术结合。在利用OFDM对信道进行副载波化后，在部分子载波上加载传输数据的传输技术。在有限频谱上有更多用户。 5.非正交多址技术： （进一步提升系统容量，支持上行非调度传输，减少空口时延，适应低时延要求） NOMA：基于功率叠加的非正交多址（日本NTT) SCMA：基于多位调制和稀疏码扩频的稀疏码分多址（华为） MUSA：基于复数多元码及增强叠加编码的多用户共享接入技术（中兴） PDMA：基于非正交特征图样的图样分隔多址技术（大唐） 秒懂频分多址FDMA、时分多址TDMA、码分多址CDMA、空分多址SDMA - 知乎 (zhihu.com) 新型多载波技术：波形： CP-OFDM(多载波) UF-OFDM DFT-S-OFDM(单载波) 5G候选新波形： F-OFDM FBMC(滤波器组多载波) UFMC GFDM 编码技术：信道：数据传输的通路 LDPC(低密度奇偶校验码) Polar(极化码) 调制技术：概念：将原始信号转化为适合在信道中传输的形式的过程 模拟调制：调幅、调频、调相；有安全隐患 数字调制：载波信号的离散状态 QAM-正交振幅调制：相位和幅度调制的一个叠加。调制技术与速率息息相关 1.16QAM（4G） 2.64QAM（下行，2^6 –&gt; 1个RE 可以携带6bit的信息） 3.256QAM（上下行都可用，2^8 –&gt; 1个RE 可以携带8bit的信息） 双工技术：双工的概念：区分上下行 如何分配上下行？： 频分双工（FDD）：不同频率（上下行） 时分双工（TDD）：相同频率，时域不同 全双工：同时同频全双工，难点在于如何而避免干扰问题 灵活双工(对全双工向前兼容)：根据需要改变上下行分配的时频域 信道带宽的概念： 在频域上子载波间隔确定时，信道带宽可以配置的最大资源块的数量叫做最大传输带宽 根据最大传输带宽来设置最小保护带宽 最小保护带宽计算公式： ( CHBW(带宽M) * 1000(kHZ) - RB数 * SCS *12 ) &#x2F; 2 - SCS &#x2F;2 信道带宽 &#x3D; 传输带宽 + 保护带宽 5G网络架构接入网：骨干网络 到 用户终端 的所有设备 &#x2F; 负责收集数据上传的所有设备 核心网：负责管理数据，分炼数据，本质是路由交换 承载网：负责数据的传输 基站与基站之间要进行交互，其接口为Xn接口 其基站包括gNB –&gt; 5G基站 和 ng-eNB –&gt; 4G增强基站 涉及5G的组织： 1.ITU（international telecommunication union，国际电信联盟）： 联合国的电信组织部门，在全世界范围内牵头组织通信 2.3GPP（3rd Generation Partnership Project，第三代合作伙伴计划）： 自3G时代为制定统一移动通信标准 联合世界范围内主流通信公司而成立","tags":["通信","大唐杯"],"categories":["通信"]},{"title":"Yuzu 模拟器合集","path":"/Yuzu/","content":"Yuzu模拟器使用教程前排提示：此文章为搬运 Yuzu模拟器使用教程 - 知乎 (zhihu.com) 无名之贝 关注他 180 人赞同了该文章 「电脑运行switch游戏，（ns模拟器）Yuzu模拟器使用教程」 首先科普一下， *重点 ！！！！重点！全文重点（看下面）* 模拟器的原理，大概就是通过软件去模拟出游戏运行的环境，并不是硬件级别的模拟，例如xx新游戏有资源，但是模拟器可能对新游戏兼容不好，出现无法运行等bug，或者能运行，但是会出现怪异的画面，在不断的修复新出现的bug，使游戏能正常运行，主流游戏bug修复挺快，或者玩家会想方法打补丁去解决bug。建议是：模拟器游戏就玩独占，多平台的，玩pc平台。省事冷门游戏如果有多平台版本，建议玩pc版本一方面是模拟器存在硬件损失性能的情况，本来你直接运行高画质的，模拟器损失性能，那只能是降低点要求了。当然冷门游戏出bug，本人玩了一个独立小游戏，换显卡前后，一样，进界面能进入，但是进游戏全黑，好像没修复过，模拟器不是完美的硬件模拟器。模拟器出现的问题，游戏机可能并没有这个问题，模拟器也在不断的修复新游戏不兼容的情况。 *模拟器使用（简单介绍一下原理，免得不清楚原理，就玩游戏，也不知道怎么使用。不想了解原理的，有一键安装包，最后有一键本地安装更新工具）*模拟器包含三个文件1.模拟器本体2.系统固件3.秘钥4.游戏本体 1、详解 模拟器本体通常下载的为压缩包格式yuzu模拟器本体如图，解压之后 yuzu文件夹运行yuzu.exe文件，即可打开模拟器界面，运行一次后，就会出现装固件跟秘钥的文件夹了。 当然，模拟器没装固件，无法运行游戏。 2、系统固件 系统固件 系统固件通常系统固件为 Firmware 14.1.1.zip（15.0.1是最新的，再往前有14的，还有12的） 把Firmware 14.1.1.zip解压后放到模拟器所在的文件夹 例如：D:\\Yuzu\\user and\\system\\Contents*registered* registered这个文件夹里 3、秘钥（key） 秘钥 通常为上图，解压后如下图 把prod.keys文件放到D:\\Yuzu\\user\\keys文件夹，此时，打开模拟器，就可以运行任天堂ns游戏了。 注：此版本蓝色白色图标为捐赠版本，红色蓝色图标为主线版 如图，上述画圈得为模拟器版本（捐赠版通常为日更（主线版更新的比较慢），如果能稳定运行你玩的游戏，那就没必要更新） 4.游戏本体介绍 1.游戏本体，游戏格式分为xxxx.xci、xxxx.nsp。目前模拟器只识别这两种格式的游戏，注：还有nsz格式的（该文件为压缩包，需要解压使用）Xci格式跟nsp格式，两种格式并没有区别，xci为卡带格式，nsp为应用商店下载版本。 从上到下，看图 介绍一下，游戏（游戏本体通常比较大如上图，一个文件2.5g，如上图 一个文件分为，游戏本体 2.5g文件（G）。 补丁 upd 370兆文件（一般是指给游戏修改bug或者加入一些新功能的文件，升级游戏本体的版本号，例如游戏本体版本号为1.0.0，安装过新的upd了之后，游戏的号会更新为1.0.2）upd）。 扩展包dlc 5.25兆的文件（DLC是指加入的新内容，如新剧情，新道具角色什么的）（dlc）如下图所示游戏本体+upd+dlc目前有两种文件，一种是，本体+upd+dlc，都是一个一个文件，需要用哪个就安装哪个，另一种是打包好的，把游戏本体+升级包全打包在一个文件里如下图。 上图，假面骑士：英雄寻忆[1G+1U+5D].xci这个文件，1G代表1个本体，1U代表1个补丁,5D代表5个DLC。另外，说下某些游戏资源会显示，xx游戏魔改整合版，大部分这类资源，均为把游戏本体+up+dlc打包到一起了，且把打包的游戏本体所需要的系统版本（ns系统固件版本，如果因为某种原因，觉得升级费劲，可以用这种魔改版），给降低了，对应的也就是，你模拟器key+固件不是最新的，有些新游戏不识别，不想更新key+固件的，可以用这种魔改版（本质跟原版本没区别）。 如何安装upd跟dlc呢 如下图，文件-安装文件到nand，选择需要安装的dlc跟upd文件，安装就可以了。 不过，这种方法安装完成会占用模拟器空间（也就是yuzu模拟器安装到 硬盘的空间）。导致游戏玩完删除的时候，dlc还在占用着模拟器所在的文件夹空间。（我个人喜欢用下面提的 NSCBx1.0.1b.exe 工具，把本体跟dlc+upd进行一个整合，这样游戏尽可能少占用多余的空间，游戏通关后，直接删除整合包就行，不会占用多余空间）游戏格式转换nsp转xci或者nsz转xci或者nsp，或者是把xci+nsp升级包打包一起的工具， NSCBx1.0.1b工具（keys已经更新为17.0）教程使用方法看我第二篇文章。转换后导出文件夹为 NSCBx1.0.1b\\NSCB_output接下来，模拟器有了，游戏也下载好了，那么怎么进行按键映射映射完才能游玩游戏，系统设置里面 手柄映射界面上图，手柄上按键不多，但是对应的按键可不少，起码得映射22个按键，截屏按键，跟home按键用不到，要不然就得是24个按键。至于怎么用键盘玩，各位自己摸索， 手柄推荐 主玩ns模拟器、cemu模拟器 手柄的选择， 1、switch pro手柄优先，首先原生的键位，betterjoy手柄软件最适配的体感校准数据是最好的选择。不试试yuzu模拟器（cemu模拟器）了，一样的软件，一样的设置都可以用。2、其次是ps5、ps4手柄，第二选择，支持的软件有ds4windows（通过该软件模拟xbox手柄，但是又实现了体感），betterjoy也一样支持，虽然键位可以映射。部分第一方游戏（塞尔达旷野之息、马里奥奥德赛）需体感才能体验的更好。忘记说了，首推ps5手柄是因为ps5用的线性马达应该更接近ns上的线性马达，ps4的马达为转子马达（缺点是，打pc游戏时刻记着xbox键位，多适应适应就行了）。3、接下来就不怎么推荐了，国产switch pro手柄，手感质量参差不齐，betterjoy软件对他体感数据的校准也一言难尽，xbox手柄虽然最适合电脑，但是没有体感，对于塞尔达这样的重度体感需求游戏来说也是不推荐的。总结：swtich pro＞ps5&#x2F;4手柄＞国产ns手柄＞xbox手柄，根据需求购买吧。 以下是pc党的推荐 我觉得应该为ps5&#x2F;4手柄≥xbox手柄＞swtich pro＞国产ns手柄， 再复述一点，关于我个人pc党的推荐，为什么是这个顺序，解释一下，ps5&#x2F;4可以用ds4windows软件，实现在pc上模拟xbox手柄的键位，也可以通过模拟器按键映射为ns的按键顺序并且支持体感，相当于，你既玩pc游戏又玩模拟器游戏，那ps5&#x2F;4手柄通吃，难点在于键位不同，ns键位跟xbox键位ab在xbox那是ba，ns的xy，在xbox手柄上是yx。当然，真是买xbox手柄，也能解决abxy按键的适配（模拟器里面有按键映射，把ns的按键布局映射到xbox上，也可以） ps4、ps5的手柄，就是x o □ △，需要自己适应了。 如下图 ns手柄 abxy xbox手柄 abxy 微软官方店铺的（绝对保真，这个可以信赖） 【微软Xbox无线控制器 磨砂黑+USB-C线缆】微软Xbox无线控制器 磨砂黑+USB-C线缆 2020款 PC游戏手柄 蓝牙连Win10&#x2F;平板&#x2F;手机 无线连Xbox 有线连Steam【行情 报价 价格 评测】-京东item.jd.com&#x2F;100016148810.html 索尼官方店铺ps5手柄（ps4的手柄因为没新的了，所以自己淘二手的吧） 【索尼CFI-ZCT1N】索尼（SONY）PS5 PlayStation DualSense无线游戏手柄 ps5手柄【行情 报价 价格 评测】-京东 (jd.com)item.jd.com&#x2F;100033984861.html ns pro官方店铺 【Nintendo SwitchHAC-A-FSSKA(CHN)】任天堂 Nintendo Switch Pro手柄 游戏机手柄 NS周边配件【行情 报价 价格 评测】-京东item.jd.com&#x2F;100010343868.html ns机器上的两个小手柄 joycon（部分游戏需要手柄分离玩游戏，主要为运动类游戏，健身环大冒险） 【Nintendo SwitchHAC-A-JAEAA(CHN)】任天堂 Nintendo Switch 国行Joy-Con游戏机专用手柄 NS周边配件 左红右蓝手柄【行情 报价 价格 评测】-京东item.jd.com&#x2F;100010343856.html 国产仿ns pro店铺（比较出名一点的店铺，刚出ns，就出国产的joycon手柄了） 【良值二代PLUS(增加唤醒功能)-L617】良值(IINE)适用任天堂Switch无线蓝牙唤醒PRO手柄 OLED游戏机控制器 NS配件 【行情 报价 价格 评测】-京东item.jd.com&#x2F;100023469971.html 我个人的排序，体感相对比较重要，没体感，部分有体感的游戏体验肯定差的多（例如塞尔达旷野之息里面的部分解谜需要体感操作，别的地方体感就是射箭了，这个可有可无，但是解谜体感不可或缺）。 最重要的是，保证你的电脑为win10，还有你的显卡驱动为最新的（内存最好是16g及其以上，这样部分游戏即便显卡显存不够，也可以吃内存，保证游戏的流畅度），这样能避免很多bug，（YUZU模拟器关键在于U频率是否够高 单核性能是否够强 老U也可以焕新发，其次显卡显存不要低于3G 10系以上甚至9系基本就能大多数流畅玩） 高u低显可运行部分游戏，有些游戏还是比较吃显卡的，某些游戏，模拟器并没有优化的很好，只要显卡在英伟达1060、amdrx480及其以上显卡的游戏基本都无压力，当然，低端显卡不是不能玩，部分游戏也能玩，我就用英伟达650ti玩过模拟器游戏， 塞尔达旷野之息，超级玛丽奥，异度之刃2，基本都可以流畅稳定运行，当然，比较老的显卡，能运行游戏，但是占用运存比较多，某些游戏因为模拟器兼容不是很好，所以带不起来。 资源 ns模拟器（一键安装的程序，不用考虑固件秘钥的事），还有ps4手柄链接电脑软件驱动，另外附了3dm运行库，如果模拟器无法打开，可以试试用它解决。需要的可以把文件保存到自己的阿里云（保存到自己云盘即可搜索），xci文件都带了 .pdf 后缀，删除即可放模拟器运行。部分游戏补丁或者mod为exe。 yuzu分为 主线版 跟 捐赠版，举例来说，主线版更新比较慢，类似手机系统的稳定版，捐赠版类似手机系统的开发版本，可能一天一更新（当然，更新的内容有没有用，不清楚） 另外，模拟器还有一个Ryujinx（简称龙神）对机器要求高些（相比yuzu来说），跟yuzu基本逻辑差不多(部分有区别)，但是并不分主线版跟捐赠版，只有主线版（无中文），跟中文版，因为个人用这个模拟器比较少，所以在此不过多分享这个模拟器使用教程。 另外更新一下，模拟器本体+配套软件（如下图） 最后的最后， yuzu模拟器本体，跟常玩的游戏资源建议放到固态硬盘里运行， 应该可以加速游戏载入过程 需要资源的自行百度or私我。 【腾讯文档】ns游戏资源列表 https://docs.qq.com/sheet/DVlJNaXBhbklOdmNh yuzu资源整理：阿里云-ns游戏资源列表 (qq文档) 夸克网盘-尔康 百度网盘-yuzu及其资源(霜晴)","tags":["Switch 模拟器"],"categories":["Switch 模拟器"]},{"title":"Windows Denfender 关闭教程","path":"/Close-Windows-Denfender/","content":"Windows Denfender 关闭教程 成功关闭","tags":["Windows"],"categories":["Windows优化合集"]},{"title":"Windows激活/升级教程收录","path":"/Win-activation/","content":"从Win11家庭中文版激活到Win11专业版 断网 设置-系统-激活-更改产品密钥： 1J8WVF-9X3GM-4WVYC-VDHQG-42CXT 自动重启 – 手动联网 Win+R – 输入powershell，回车 – 在弹出的 Windows PowerShell 窗口输入： 1irm massgrave.dev/get.ps1 | iex 弹出窗口选[1] (就是输入1，回车) 回到 设置-系统-激活 界面查看是否成功激活 激活Win10专业版1.Win+S – 搜索框中输入cmd – 以管理员身份运行； 2.在命令提示符窗口下输入： 123slmgr /ipk W269N-WFGWX-YVC9B-4J6C9-T83GXslmgr /skms kms.loli.bestslmgr /ato","tags":["Win11 激活"],"categories":["Windows优化合集"]},{"title":"Pyinstaller 打包教程","path":"/pyinstaller/","content":"一. Pyinstaller 简介 作用：PyInstaller 将 Python 应用程序及其所有依赖项捆绑到单个软件包中。用户无需安装 Python 解释器或任何模块，即可运行打包后的应用程序。 支持情况(兼容性)：PyInstaller 支持 Python 3.8 及其更新版本； 能正确捆绑 numpy、matplotlib、PyQt、wxPython 等许多主流 Python 包。 PyInstaller 已经过 Windows、MacOS X 和 Linux 测试。 注意事项：不过，它并不是一个交叉编译器；要制作 Windows 应用程序就需要在 Windows 上运行 PyInstaller，要制作 Linux 应用程序就需要在 Linux 上运行它，依此类推。 一般来说，我们使用Pyinstaller打包出于如下原因： 君子式防止他人得到该项目的源代码（很容易破解）； 开发过程中用了一些第三方库如果把做好的代码项目供他人使用，需要对方电脑上拥有Python环境；而经过Pyinstaller打包后就可以在单独的文件夹中打开.exe文件（开箱即用）即可 二. Pyinstaller 安装及使用下面来一段Pyinstaller的使用示例： 如图，这是一段简单的Python项目代码，作用是打开我的网站(opentap.top)： 123456import webbrowser\t#导入了webbrowser模块websites = [&quot;https://opentap.top&quot;]\t#定义了一个包含一个网站链接的列表for site in websites:\t#使用for循环遍历这个列表 webbrowser.open(site)\t#对列表中的每个网站链接，调用webbrowser.open()函数打开网页 我想点击某个快捷方式直接先从桌面打开我的网站，于是我使用Pyinstaller打包： [^注]: 下载失败的请 配置国内镜像源 或 自行科学上网 首先让我们学习一下pyinstaller打包的基础指令： 格式：pyinstaller xxx.py(项目名) -X -Y -Z(各种命令模块) 一些简单有效的的命令模块： -F, --onefile 创建一个文件捆绑的可执行文件。 人话：-F 把生成的文件放入同一个文件夹中 -w, --windowed, --noconsole Windows 和 Mac OS X：不为标准 I&#x2F;O 提供控制台窗口。上 Mac OS 这也触发了构建 Mac OS .app 捆绑包。在 Windows 上，这个 如果第一个脚本是“.pyw”文件，则会自动设置选项。这 选项在 *NIX 系统上被忽略。 人话：-w 打开 生成的.exe可执行文件 时 隐藏 cmd(windows控制台) 窗口 -i &lt;FILE.ico or FILE.exe,ID or FILE.icns or Image or “NONE”&gt;, --icon &lt;FILE.ico or FILE.exe,ID or FILE.icns or Image or “NONE”&gt; FILE.ico：将图标应用于 Windows 可执行文件。 FILE.exe，ID：提取 带有 EXE 中 ID 的图标。 FILE.icns：将图标应用于 .app 捆绑包 Mac 操作系统。 如果输入的图像文件不是平台格式（ico 在 Windows 上，在 Mac 上，PyInstaller 尝试使用 Pillow 来翻译 图标转换为正确的格式（如果安装了 Pillow）。使用“NONE”表示不 应用任何图标，从而使操作系统显示一些默认值（默认：apply PyInstaller 的图标）。此选项可以多次使用。 人话：-i [文件名].ico 怎么让生成的.exe程序带上自己想要的图标？ 把那张图片文件格式改为.ico 把图片.ico与代码.py放在同一个文件夹中（也就是把图片.ico放入项目文件夹里） 终端命令中加入 -i xxxx(图片名).ico 打开终端 – 输入pyinstaller打包命令 – 回车 1pyinstaller opentap.top.py -F -w -i ciallo.ico 整理出单独文件 方便今后文件管理 未完待续 1pyinstaller Hands.py -- add-data=&quot;D:\\Desktop\\try\\Lib\\site-packages\\mediapipe\\modules;mediapipe/modules&quot; -F -w -i ciallo.ico 1pyinstaller Gesture_volume_control.py -- add-data=&quot;D:\\Desktop\\try\\Lib\\site-packages\\mediapipe\\modules;mediapipe/modules&quot; -F -w -i ciallo.ico 参考文献： pyinstaller — PyInstaller 6.5.0 文档 使用 PyInstaller | PyInstaller 中文文档 (gitbook.io)","tags":["Python 打包"],"categories":["Python"]},{"title":"Netlify使用","path":"/Netlify/","content":"1. 创建 Netlify 账号 - 然后登录这部分有些琐碎（主要是有邮箱验证啥的）如已有帐号并知道如何登陆的请跳过~ 好吧。。。用Github和outlook邮箱被我作死通不过验证。。又换了QQ邮箱重新弄了一遍 2. Netlify 初始化 - 开始部署第一个项目 3. 在工作流界面导入Git仓库(即博客仓库) N.安装lighthouse插件","tags":["Netlify","博客优化"],"categories":["博客优化"]},{"title":"CloudStudio","path":"/CloudStudio/","content":""},{"title":"数据结构笔记","path":"/Data-structure/","content":"算法的时间复杂度假如fn是一个多项式，忽略所有低次幂以及最高次幂的系数 O(1) 线性阶 二叉树二叉树的应用：主要是数据存储，例如 Windows&#x2F;Linux 文件系统；便于搜索和排序。 部分关键词： 深度：有几层 节点：有几个点 度：一个节点有几个分支 类型： 满二叉树：是完全二叉树， 完全二叉树：节点 自上而下从左到右 不存在间隔 二叉树的存储结构： 顺序存储结构 链式存储结构 1.顺序存储结构 首先看一下完全二叉树的顺序存储，一颗完全二叉树如图1-1所示。 将这颗二叉树存入到数组中，相应的下标对应其同样的位置，如图1-2所示。 可以看出完全二叉树的优越性。由于它定义的严格，所以用顺序结构也可以表现出二叉树的结构来。当然对于一般的二叉树，尽管层序编号不能反映逻辑关系，但是可以将其按完全二叉树编号，只不过，把存在的结点设置为“^”而已。如图1-3中，注意浅色结点表示不存在。 考虑一种极端的情况，一颗深度为k的右斜树，他只有k个结点，却需要分配2 k-1个存储单元，这显然是对存储空间的浪费，例如图1-5所示，所以顺序存储结构一般只用于完全二叉树。 原文链接：https://blog.csdn.net/xiangjunyes/article/details/106871111 2.链式存储结构 二叉链表既然顺序存储的适用性不强，我们就要考虑链式存储结构。二叉树每个结点最多有两个孩子，所以为他设计一个数据域和两个指针域是比较自然的想法，我们称这样的链表叫做二叉链表，结构如图1-6所示。 其中data是数据域，lchild和rchild是是指针域，分别存放指向左孩子和右孩子的指针。 123456//二叉树的二叉链表结点结构定义typedef struct BiNode&#123;\tTElemType data; //结点数据\tstruct BiTNode *lchild,*rchild; //左右孩子指针&#125; 结构示意图如图1-7所示。 原文链接：https://blog.csdn.net/xiangjunyes/article/details/106871111 先根，中根，后根 先根遍历结果：ABCDEFGH原理：先遍历根节点，再遍历左子树，最后遍历右子树； 中根遍历结果：CBEDFAGH原理：先遍历左子树，再遍历根节点，最后遍历右子树； 后根遍历结果：CEFDBHGA原理：遍历左子树，再遍历右子树，最后遍历根节点； 图解二叉树先根、中根、后根遍历 线性表栈和队列串、数组、广义表树和二叉树 广度优先遍历：从左到右，从上到下深度优先遍历：从上到下，从左到右"},{"title":"NCRE3网络大题","path":"/brush-NCRE3/","content":"综合题1：IP地址相互推理 网络地址：网不变主0 直接广播地址：网不变主1 受限广播地址：255.255.255.255 主机号：网0主不变 子网内第一个可用IP地址：网络地址+1 子网内最后一个可用IP地址：直接广播地址-1 综合题2 – POS，OSPF，Loopback，静态路由 真题14 ： 真题13： 真题17： 先稍稍总结一下：(粗体为你可能要填的) Rx的POS接口配置： interface pos3&#x2F;1 description To Internet &#x2F; CERNET bandwidth 题目中Gbps数字 x 100 000 # 配置带宽 ip address 该路由器指定pos接口ip地址 + 子网掩码 #配置接口地址 crc 32 # 在配置接口IP地址和帧格式之间配置接口的CRC校验(默认为32) pos framing sonet &#x2F; sdh no ip directed-broadcast pos flag s1s0 0 &#x2F; s1s0 2\t(sonet &#x2F; sdh) no shutdown exit interface loopback 0 ip address 题目中指定IP 255.255.255.255 No ip route-cache No ip mroute-cache exit Rx的路由协议配置： router ospf 63&#x2F;65 (重新分配已连接的度量类型1子网) network 云中IP(如有多个需要聚合^) 反掩码 area 0 默认信息总是产生 area 0 range 云中IP(如有多个需要聚合^) 子网掩码 exit ip route 0.0.0.0 0.0.0.0 下一跳ip* Rx的静态路由配置： ip route 云中IP(如有多个需要聚合^) 子网掩码 下一跳ip* 综合题3：DHCP报文分析 真题17： 综合题4：Sniffer 抓包报文分析 真题17： 应用题：","tags":["网络技术"],"categories":["网络技术"]},{"title":"Xshell 7 下载及安装","path":"/Xshell-7/","content":"Xshell 7 介绍： Xshell是一款强大的SSH、TELNET和RLOGIN终端仿真软件，适用于Windows用户安全地访问UNIX&#x2F;Linux主机。 人话：用 Windows PC 端 直接控制 无图形化界面的 Linux 主机 Xshell 7 下载过程 Xshell 7 安装过程 注册完如图所示：","tags":["Xshell"]},{"title":"learn-mathjax","path":"/learn-mathjax/","content":"$$1+2&#x3D;3$$ $$\\vec{a} \\cdot \\vec{b}&#x3D;0$$ 截图识别转换LaTeX"},{"title":"PicGo+GitHub图床：你的下一个图片召唤器","path":"/PicGo/","content":"PicGo 使用教程 什么是PicGo？PicGo: 一个用于快速上传图片并获取图片 URL 链接的工具，支持多种图床 我目前能用PicGo做什么？ 在线存放图片(隐私性可能得不到保证) 加速MarkDown等文章编写过程中图片的引用 1.创建新GitHub存储库作为图床存放点 相关名词：Repo ( Repository - 仓库 ) (一定要保存该令牌，确保日后再用到的时候还记得它) 2.下载PicGo 3.PicGo的图床配置(以GitHub图床为例) 自定义域名参考：https://raw.gitmirror.com/用户名/存储库名/设定分支名/设定存储路径/ 4.其他优化设置及测试 自定义上传快捷键&#x2F;自动更新&#x2F;开机自启 上传的图片存放在GitHub存储库的相应位置 5.PicGo配置文件更换PC设备后想继续使用原PicGo配置？找到PicGo配置文件可以解决这个问题。 相关官方教程：配置手册 | PicGo 找到PicGo配置文件在windows中的位置： 1C:\\Users\\你的用户名\\AppData\\Roaming\\picgo\\data.json 复制旧设备的以上data.json到新设备对应位置覆盖粘贴，再重启PicGo即可","tags":["博客搭建","图床"],"categories":["图床"]},{"title":"文件后缀相关知识大全","path":"/suffix/","content":"本文暂时停止更新，因为发现了整理得很全面的网站： 文件格式文档 (fileformat.com) .md：Markdown文件.dmg：苹果系统的安装文件.Appimage：便携式Linux只读软件.snap：安全，通用的 Linux 软件包.exe：Windows安装或运行软件应用程序.tar.gz：在Linux系统中，.tar.gz 是一种常见的压缩文件格式，通常用于打包和压缩多个文件或目录。","tags":["文件后缀"],"categories":["文件格式转化"]},{"title":"实验性页面","path":"/Try-New/","content":"网页游戏网页游戏-贪吃蛇网页游戏-像素鸟网页游戏-赛车 资源下载Raylink 安卓包 - 支持VIP功能的旧官方版本6.14.0便携式 Photoshop7.0语音合成工具 Read Aloud网页转应用v1.2.apk 音乐静态音乐界面 异次元链接","tags":["网页游戏","资源下载","音乐"]},{"title":"OpenMV","path":"/OpenMV/","content":"官方资料新手上路：10分钟快速上手 · OpenMV中文入门教程 官方文档：OpenMV 库函数(中文文档) ​ OpenMV 库函数(官方文档) 相关社群：OpenMV 官网 ​ OpenMV 论坛 ​ GitHub - OpenMV 开源项目库 ​ OpenMV IDE 下载地址 疑难解答使用 OpenMV IDE 写代码 看到不会的代码 –&gt; 复制到 OpenMV 库函数(中文文档) 搜索栏里粘贴搜索 (PS:中文文档较老旧，有些新固件新函数查询不到，建议跳转至OpenMV 库函数(官方文档))查找；如果电脑上有OpenMV IDE的，也可以按此路径[C:&#x2F;Users&#x2F;你的用户名&#x2F;AppData&#x2F;Roaming&#x2F;OpenMV&#x2F;openmvide&#x2F;html&#x2F;index.html]拖动到浏览器本地查询(内容与英文官方文档一致)) 写代码时不知道函数意义的，将光标停留其上，会显示定义 善用快捷键 Ctrl + F 查找 Ctrl + &#x2F; 批量注释&#x2F;取消注释 Tab &#x2F; Shift +Tab 批量缩进&#x2F;取消缩进 性能优化一般情况下，除法运算比乘法运算更消耗性能。 如果你想用OpenMV拼一台简单追小球车： https://book.openmv.cc/project/zhui-xiao-qiu-de-xiao-8f665d28-project-pan-tilt-md.html LAB Lab： L-亮度 a:正红负绿； b:正黄负蓝 感光元件sensor模块,用于设置感光元件的参数。 举个例子： 1234567891011import sensor#引入感光元件的模块# 设置摄像头sensor.reset()#初始化感光元件sensor.set_pixformat(sensor.RGB565)#设置为彩色sensor.set_framesize(sensor.QVGA)#设置图像的大小sensor.skip_frames()#跳过n张照片，在更改设置后，跳过一些帧，等待感光元件变稳定。# 一直拍照while(True): img = sensor.snapshot()#拍摄一张照片，img为一个image对象 使用图像的统计信息如果我想知道一个区域内的平均颜色或者占面积最大的颜色？ 使用统计信息——Statistics！ ROI感兴趣的区域roi的格式是(x, y, w, h)的tupple. x:ROI区域中左上角的x坐标 y:ROI区域中左上角的y坐标 w:ROI的宽度 h:ROI的高度 OpenMV 自动计算阈值+找色块代码1234567891011121314151617181920212223242526272829import sensor, image, timesensor.reset ()sensor.set_pixformat(sensor.RGB565)sensor.set_framesize(sensor.QQVGA) #分辨率160*120#sensor.set_auto_gain (False) #颜色跟踪必须关闭自动增益#sensor.set_auto_whitebal (False) #颜色跟踪必须关闭白平衡sensor.skip_frames (time = 2000)Range = (0,0,160,120) #设定感兴趣区域#【0】记忆色块阈值for i in range (200): img = sensor.snapshot() img.draw_rectangle((75,55,10,10),color=(255,0,0)) #圈出搜寻区域 Statistics = img.get_statistics (roi=(75,55,10,10)) #得到搜寻区域内的图像统计信息 Threshold = [Statistics.l_min(),Statistics.l_max(), #从统计信息中得到色块阈值 Statistics.a_min(),Statistics.a_max(), Statistics.b_min(),Statistics.b_max()] print(Threshold)while(True): img = sensor.snapshot() #【1】找色块 for blob in img.find_blobs([Threshold],roi=Range, pixels_threshold=100, area_threshold=100, merge=True, margin=10): #【2】输出 img.draw_rectangle(blob.rect()) #画框 img.draw_cross(blob.cx(), blob.cy()) #画十字 print(blob.cx(), blob.cy()) #打印坐标 寻找色块视频教程4 - 颜色识别：https://singtown.com/learn/49993/find_blobs函数追踪小球是OpenMV用的最多的功能了，在10分钟快速上手中通过find_blobs函数可以找到色块.我们来讨论一下，find_blobs的细节。 1image.find_blobs(thresholds, roi=Auto, x_stride=2, y_stride=1, invert=False, area_threshold=10, pixels_threshold=10, merge=False, margin=0, threshold_cb=None, merge_cb=None) 这里的参数比较多。 thresholds是颜色的阈值，注意：这个参数是一个列表，可以包含多个颜色。如果你只需要一个颜色，那么在这个列表中只需要有一个颜色值，如果你想要多个颜色阈值，那这个列表就需要多个颜色阈值。注意：在返回的色块对象blob可以调用code方法，来判断是什么颜色的色块。 12345678red = (xxx,xxx,xxx,xxx,xxx,xxx)blue = (xxx,xxx,xxx,xxx,xxx,xxx)yellow = (xxx,xxx,xxx,xxx,xxx,xxx)img=sensor.snapshot()red_blobs = img.find_blobs([red])color_blobs = img.find_blobs([red,blue, yellow]) roi是“感兴趣区”。在使用统计信息中已经介绍过了。 left_roi &#x3D; [0,0,160,240]blobs &#x3D; img.find_blobs([red],roi&#x3D;left_roi) x_stride 就是查找的色块的x方向上最小宽度的像素，默认为2，如果你只想查找宽度10个像素以上的色块，那么就设置这个参数为10： blobs &#x3D; img.find_blobs([red],x_stride&#x3D;10) y_stride 就是查找的色块的y方向上最小宽度的像素，默认为1，如果你只想查找宽度5个像素以上的色块，那么就设置这个参数为5： blobs &#x3D; img.find_blobs([red],y_stride&#x3D;5) invert 反转阈值，把阈值以外的颜色作为阈值进行查找 area_threshold 面积阈值，如果色块被框起来的面积小于这个值，会被过滤掉 pixels_threshold 像素个数阈值，如果色块像素数量小于这个值，会被过滤掉 merge 合并，如果设置为True，那么合并所有重叠的blob为一个。注意：这会合并所有的blob，无论是什么颜色的。如果你想混淆多种颜色的blob，只需要分别调用不同颜色阈值的find_blobs。 12345all_blobs = img.find_blobs([red,blue,yellow],merge=True)red_blobs = img.find_blobs([red],merge=True)blue_blobs = img.find_blobs([blue],merge=True)yellow_blobs = img.find_blobs([yellow],merge=True) margin 边界，如果设置为1，那么两个blobs如果间距1一个像素点，也会被合并。 阈值一个颜色阈值的结构是这样的： 1red = (minL, maxL, minA, maxA, minB, maxB) 元组里面的数值分别是L A B 的最大值和最小值。 如果想在IDE的图像里获取这个阈值，见：10分钟快速上手 在新版的IDE，有更方便的阈值选择工具，见下面。 颜色阈值选择工具OpenMV 的IDE里加入了阈值选择工具，极大的方便了对于颜色阈值的调试。 首先运行hello world.py让IDE里的framebuffer显示图案。然后打开 工具 → Mechine Vision → Threshold Editor 点击 Frame Buffer可以获取IDE中的图像，Image File可以自己选择一个图像文件。 拖动六个滑块，可以实时的看到阈值的结果，我们想要的结果就是，将我们的目标颜色变成白色，其他颜色全变为黑色。 blobs是一个列表find_blobs对象返回的是多个blob的列表。（注意区分blobs和blob，这只是一个名字，用来区分多个色块，和一个色块）。列表类似与C语言的数组，一个blobs列表里包含很多blob对象，blobs对象就是色块，每个blobs对象包含一个色块的信息。 1blobs = img.find_blobs([red]) blobs就是很多色块。 可以用for循环把所有的色块找一遍。 12for blob in blobs: print(blob.cx()) 对于for循环的使用，见python背景知识 blob色块对象blob有多个方法： blob.rect() 返回这个色块的外框——矩形元组(x, y, w, h)，可以直接在image.draw_rectangle中使用。 blob.x() 返回色块的外框的x坐标（int），也可以通过blob[0]来获取。 blob.y() 返回色块的外框的y坐标（int），也可以通过blob[1]来获取。 blob.w() 返回色块的外框的宽度w（int），也可以通过blob[2]来获取。 blob.h() 返回色块的外框的高度h（int），也可以通过blob[3]来获取。 blob.pixels() 返回色块的像素数量（int），也可以通过blob[4]来获取。 blob.cx() 返回色块的外框的中心x坐标（int），也可以通过blob[5]来获取。 blob.cy() 返回色块的外框的中心y坐标（int），也可以通过blob[6]来获取。 blob.rotation() 返回色块的旋转角度（单位为弧度）（float）。如果色块类似一个铅笔，那么这个值为0180°。如果色块是一个圆，那么这个值是无用的。如果色块完全没有对称性，那么你会得到0360°，也可以通过blob[7]来获取。 blob.code() 返回一个16bit数字，每一个bit会对应每一个阈值。举个例子： blobs &#x3D; img.find_blobs([red, blue, yellow], merge&#x3D;True) 如果这个色块是红色，那么它的code就是0001，如果是蓝色，那么它的code就是0010。注意：一个blob可能是合并的，如果是红色和蓝色的blob，那么这个blob就是0011。这个功能可以用于查找颜色代码。也可以通过blob[8]来获取。 blob.count() 如果merge&#x3D;True，那么就会有多个blob被合并到一个blob，这个函数返回的就是这个的数量。如果merge&#x3D;False，那么返回值总是1。也可以通过blob[9]来获取。 blob.area() 返回色块的外框的面积。应该等于(w * h) blob.density() 返回色块的密度。这等于色块的像素数除以外框的区域。如果密度较低，那么说明目标锁定的不是很好。比如，识别一个红色的圆，返回的blob.pixels()是目标圆的像素点数，blob.area()是圆的外接正方形的面积。 # OpenMV串口通信 – 传数据包OpenMV端123#串口输出数据包(发送的是16进制数)data = bytearray([0xa3,0xb3, obj.classid()+1, pos[0], pos[1], 0xc3]) #帧头 + 帧头 + 数字 + x坐标 + y坐标 + 帧尾usart3.write(data) STM32端123456789101112131415161718192021222324//接openmv的串口2的中断服务程序:void USART2_IRQHandler(void)&#123;\tstatic int i=0;\tif(USART_GetITStatus(USART2,USART_IT_RXNE) != RESET)\t&#123; openmv_data[i++] = USART ReceiveData(USART2); //接收数据 if(openmy_data[0]!=0xa3) i=0; //判断第一个帧头 if((i==2)&amp;&amp;(openmv_data[1]!=0xb3)) i=0; //判断第二个帧头 if(i==6) //代表一组数据传输完毕 &#123; if( openmv_data[5] == 0xc3 ) //判断帧尾 &#123;/********************更新数据************************/ //【1】识别到的数字： openmv_num = openmv_data[2]; //【2】数字的x、y坐标: openmv_x = openmv_date[3]; openmv_y = openmv_date[4]; &#125; i = 0; //清空数组 &#125;\t&#125;&#125; 多模板匹配 脱机调阈值的实现方法二值化 - 低于阈值就黑色，高于阈值就白色 UARTUART通信简介两个UART直接相互通信。发送UART将控制设备（如CPU）的并行数据转换位串行形式，以串行的形式将其发送到接收UART。只需要两条线即可在两个UART之间传输信息： UART属于异步通信，没有时钟信号。它会在数据包中增加开始和停止位。这些位定义了数据包的开始和结束，因此接收UART知道何时读取这些数据。当接收UART检测到起始位时，它将以特定的波特率的频率读取（数据传输速度的度量），以每秒比特数（bps）表示。两个UART必须以大约相同的波特率工作，发送的接收UART之间的波特率只能相差约10%。 原文链接：https://blog.csdn.net/qq_52608074/article/details/122297014 – 12345from pyb import UARTuart = UART(3, 9600)uart.write(&#x27;hello&#x27;)uart.read(5) # read up to 5 bytes UART 3 RX -&gt; P5 (PB11)UART 3 TX -&gt; P4 (PB10) OpenMV3 M7 &#x2F; OpenMV4 H7&#x2F; OpenMV4 H7 Plus上增加：UART 1 RX -&gt; P0 (PB15)UART 1 TX -&gt; P1 (PB14) 在 OpenMV RT 上不能用pyb模块，只能使用以下machine模块： 12345from machine import UARTuart = UART(1, 9600)uart.write(&#x27;hello&#x27;)uart.read(5) # read up to 5 bytes OpenMV RT1062只有串口1，对应 P4 P5 引脚。 UART 1 RX -&gt; P5 (PB11)UART 1 TX -&gt; P4 (PB10) OpenMV配置图及引脚图 Tables OpenMV2 M4 OpenMV3 M7 OpenMV4 H7 OpenMV4 H7 Plus OpenMV RT1062 Pin 9 10 10 10 14 ADC 1 1 1 1 1 DAC 1 1 1 1 0 SPI 1 1 1 1 1 I2C 1 2 2 2 1 UART 1 2 2 2 1 Servo 2 3 3 2 4 CAN bus 0 1 1 1 1 电源按键 0 0 0 0 1 自定义按键 0 0 0 0 1 引脚耐受 5V 5V 5V 5V 3.3V 引脚电平 3.3V 3.3V 3.3V 3.3V 3.3V IC STM32F427 STM32F765 STM32H743 STM32H743 IMXRT1062 RAM 256KB 512KB 1MB 32MB + 1MB 32MB + 1MB Flash 1MB 2MB 2MB 32MB + 2MB 16MB 频率 180MHz 216MHZ 480MHZ 480MHZ 600MHZ 标配感光元件 OV7725(30W像素) OV7725(30W像素) OV7725(30W像素) OV5640(500W像素) OV5640(500W像素) tf.classify(path, img[, roi[, min_scale=1.0[, scale_mul=0.5[, x_overlap=0[, y_overlap=0]]]]])¶ 在 img 上运行TensorFlow Lite图像分类模型，并返回一个 tf_classification 对象列表。 这个方法对图像使用可控滑动方式，执行多次模型(默认算法在整个图像帧上只执行网络一次)。 path 是OpenMV Cam的磁盘上的 .tflite 模型的路径。 为了节省内存，只通过这一个函数，模型被加载到内存中，执行并释放所有内存。 传递 “person_detection” 可以从你的OpenMV Cam的内部FLASH加载内置的人检测模型。 roi 是感兴趣区域矩形元组(x, y, w, h)。如果没有指定时，它等于图像的整个大小。 只有在 roi 内的像素才被操作。 min_scale 控制网络的缩放尺度。在默认值网络不缩放。 当值为0.5时，会允许检测大小为图像roi的50%的目标。 scale_mul 控制有多少种不同的缩放尺度可以检测出来。 滑动窗口方法的工作原理是将默认的尺度1乘以 scale_mul 同时结果大于 min_scale 。 scale_mul 的默认值是0.5，测试出每次变化可以减少50%的大小。但是，0.95只会减少5%的尺寸。 x_overlap 控制与下一个滑动窗口的区域检测器重叠的百分比。 值为0意味着没有重叠，0.95意味着95%的重叠。 y_overlap 控制与下一个滑动窗口的区域检测器重叠的百分比。 值为0意味着没有重叠，0.95意味着95%的重叠。 image.get_statistics([thresholds[, invert&#x3D;False[, roi[, bins[, l_bins[, a_bins[, b_bins[, difference]]]]]]]****])¶ 计算 roi 中每个颜色通道的平均值、中值、众值、标准偏差、最小值、最大值、下四分值和上四分值，并返回一个数据对象。 请参见 statistics 对象以获取更多信息。您也可以使用 image.get_stats 或 image.statistics 来调用这一方法。 如果传递 thresholds 列表，则直方图信息将仅从阈值列表中的像素计算得出。 thresholds 必须是元组列表。 [(lo, hi), (lo, hi), ..., (lo, hi)] 定义你想追踪的颜色范围。 对于灰度图像，每个元组需要包含两个值 - 最小灰度值和最大灰度值。 仅考虑落在这些阈值之间的像素区域。 对于RGB565图像，每个元组需要有六个值(l_lo，l_hi，a_lo，a_hi，b_lo，b_hi) - 分别是LAB L，A和B通道的最小值和最大值。 为方便使用，此功能将自动修复交换的最小值和最大值。 此外，如果元组大于六个值，则忽略其余值。相反，如果元组太短，则假定其余阈值处于最大范围。 备注 获取所跟踪对象的阈值，只需在IDE帧缓冲区中选择（单击并拖动）跟踪对象。 直方图会相应地更新到所在区域。然后只需写下颜色分布在每个直方图通道中起始与下降位置。 这些将是 thresholds 的低值和高值。 由于上下四分位数据相差微小，故手动确定阈值为佳。 您还可以通过进入OpenMV IDE中的 工具 -&gt;机器视觉 -&gt;阈值编辑器 并从GUI窗口中拖动滑块来确定颜色阈值。 文件系统在10分钟上手教程中已经简单介绍过OpenMV上的文件系统。这里是一些细节。 MicroPyhon的文件系统是FatFS。 根目录路径都是以根目录为起点。 当插入sd卡后，根目录就是SD卡；不插入sd卡，根目录就是内置的Flash。 如果需要，你可以在SD卡上，新建一个空文件：&#x2F;flash&#x2F;SKIPSD，这会避免挂载SD卡，当然，你可以使用os.mount来手动挂载SD卡。 绝对路径与相对路径绝对路径是以根目录为起点的，相对路径是以当前目录为起点的。比如： 12image.save(&quot;/example.jpg&quot;)Copy 中的”&#x2F;example.jpg”就是绝对路径。会存放在根目录／下。比如： 123image.save(&quot;./pic/example.jpg&quot;)image.save(&quot;pic/example.jpg&quot;)Copy 这就是相对路径，表示当前路径下的pic文件夹下的example.jpg文件。 MicroPython的文件读写http://www.cnblogs.com/feeland/p/4477535.html MicroPython的OS模块在代码中，可以使用os库，来进行新建目录，新建文件之类的操作。 os.listdir([dir])如果没有参数，列出当前目录。如果给了参数，就列出参数所代表的目录。 os.chdir(path)改变当前目录 os.getcwd()获得当前目录 os.mkdir(path)新建一个新的目录 os.remove(path)删除文件 os.rmdir(path)删除目录 os.rename(old_path, new_path)重命名文件 os.stat(path)获得文件或者路径的状态 OpenMV的默认文件 默认情况下，OpenMV的磁盘有三个文件。 main.py上电自动运行这个文件的代码。 openmv.infwindows驱动文件。 README.txt没什么用，你可以看一下。 你需要了解的相关基础概念： LAB 阈值 ROI UART IO 你需要实现的相关功能： find_blogs 巡线 QQ截图对比前后差异 自适应阈值探究： 理论最深LAB：(0, 0, -128, -128, -128, -128) 理论最亮LAB：(100, 100, 127, 127, 127, 127) 所以 理论默认LAB：(50, 50, 0, 0, 0, 0) 实际最深LAB：(1, 53, -1, 80, 0, 66) 已实现的方案：1.巡线、判断十字路口：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657# 巡线(红线) + 判断十字路口import sensor, image, time, pybimport displayfrom pyb import UART, LEDLED(1).on()LED(2).on()LED(3).on()uart = pyb.UART(3, 9600)uart.init(9600, bits=8, parity=None, stop=1)sensor.reset()sensor.set_pixformat(sensor.RGB565)sensor.set_framesize(sensor.QQVGA2)sensor.set_auto_gain(False)sensor.set_auto_whitebal(False)lcd = display.SPIDisplay()sensor.skip_frames (time = 1000)clock = time.clock()def find_max(blobs):\tmax_size=0\tfor blob in blobs: if blob[2]*blob[3] &gt; max_size: max_blob=blob max_size = blob[2]*blob[3]\treturn max_blobtheta_err = 90rotate_angle = 90crossroad = 0while(True):\tclock.tick()\timg = sensor.snapshot().binary([(4, 70, 18, 127, -125, 127)])\tblobs = img.find_blobs([(20, 255)], x_stride=1, y_stride=1, pixels_threshold=180, area_threshold=180, merge=True)\tif blobs: max_blob = find_max(blobs) rotate_angle = 180 * (max_blob.cx() / img.width()) if max_blob.w()&lt;img.width()*0.7: crossroad = 0 else: crossroad = 1 img.draw_rectangle(max_blob.rect()) img.draw_cross(max_blob.cx(), max_blob.cy(),color=(255,0,0))\tline = img.get_regression([(20, 255)], pixels_threshold=120, area_threshold=120, robust = True)\tif line: if line.theta()&gt;90: theta_err = line.theta()-90 else: theta_err = line.theta()+90 img.draw_line(line.line(), color = 127)\tchimera = theta_err*0.7 + rotate_angle*0.3\timg.draw_string(10, 10, str(int(chimera)), color=(0,185,255), scale=2, x_spacing=-5)\tdata=bytearray([0xa3,0xb3,int(chimera),int(crossroad),0xc3])\tuart.write(data)\tprint(&quot; &quot;)\tprint(&quot;当前帧数:&quot;, clock.fps(), &quot;fps&quot;)\tprint(&quot;是否检测到十字路口:&quot;, crossroad)\tprint(&quot;推荐转向&quot;, chimera)\tlcd.write(img) 2.匿名凌霄无人机识别黑色矩形区域降落：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374# 无人机降落(黑色矩形区域)import sensor, image, time, pyb, displayfrom pyb import UARTimport jsonimport ustructsensor.reset()sensor.set_pixformat(sensor.RGB565)sensor.set_framesize(sensor.QVGA)sensor.skip_frames(time=2000) # 跳帧sensor.set_auto_gain(False) # 关闭自动增益sensor.set_auto_whitebal(False) # 关闭白平衡lcd = display.SPIDisplay() # 初始化lcd屏幕。clock = time.clock()uart3 = UART(3, 500000, timeout_char=1000)# 色块阈值#blue_threshold = (31, 66, -37, -9, 5, -32)#yellow_threshold = (50, 78, -54, 108, 20, 78)blue_threshold = (0,30,-128,10,-128,127)yellow_threshold = (58,100,-128,127,-128,127)# 测距常数k = 950moshi=0def find_max(blobs): max_size=0 for blob in blobs: if blob[2]*blob[3] &gt; max_size: max_blob=blob max_size = blob[2]*blob[3] return max_blobwhile True: clock.tick() img = sensor.snapshot() blobs_blue = img.find_blobs([blue_threshold], roi = (0,0,img.width(),img.height())) if blobs_blue: # 在矩形内检测到蓝色，说明是己方宝藏 b = find_max(blobs_blue) # 将返回数据赋值给b if b.density()&gt;0.7 and b.w()&gt;img.width()*0.3: img.draw_cross(b[5], b[6]) # cx, cy img.draw_cross(int(img.width()*0.5), int(img.height()*0.5), size=5, color=(0,255,0)) #img.draw_cross(0, 0, size=5, color=(0,255,0)) img.draw_line((int(img.width()*0.5), int(img.height()*0.5),b[5], b[6]), color=(255,0,255)) a_x=b.cx()-int(img.width()*0.5) a_y=b.cy()-int(img.height()*0.5) img.draw_rectangle(b.rect(), color = (0, 0, 255)) FH = bytearray([0xAA,0xFF,0xCC,0x00,moshi,a_x,a_y,0x00,0x00]) lens = len(FH)#数据包大小 FH[3] = lens-6;#有效数据个数 i = 0 sum = 0 sum1 = 0 #和校验 while i&lt;(lens-2): sum = sum + FH[i] sum1 = sum1 + sum i = i+1 FH[lens-2] = sum; FH[lens-1] = sum1; #传输数据给单片机 #uart_buf = bytearray(row_data) uart3.write(FH) print(FH) print(&quot;x偏移:&quot;,a_x,&quot;y偏移:&quot;,a_y,&quot; &quot;) # 在检测到的真宝藏上画蓝框 # 屏幕显示 img.draw_string(10, 10, str(a_x) + &quot;,&quot; + str(a_y), color=(255,0,70), scale=2, x_spacing=-5, mono_space=True) else: print(&quot;未检测&quot;) else: print(&quot;未检测&quot;) img_copy = img.copy(x_scale=128/img.width(),y_scale=160/img.height()) lcd.write(img_copy) # 让LCD屏显示拍到的图像 3.识别矩形、返回矩形四角坐标：123456789101112131415161718192021222324252627282930313233343536373839# 识别矩形 + 返回矩形四角坐标import sensor, image, time, pybimport displayfrom pyb import UARTuart = pyb.UART(3, 9600)uart.init(9600, bits=8, parity=None, stop=1)lcd = display.SPIDisplay()sensor.reset()sensor.set_pixformat(sensor.RGB565)sensor.set_framesize(sensor.QQVGA2)sensor.set_auto_gain(False)sensor.set_auto_whitebal(False)sensor.skip_frames(time = 500)clock = time.clock()while(True):\tclock.tick()\timg = sensor.snapshot()\tfor r in img.find_rects(threshold = 10000): if r.w() &gt; 15 and r.h() &gt; 15: img.draw_rectangle(r.rect(), color = (255, 0, 0), scale = 4) corner = r.corners() img.draw_circle(corner[0][0], corner[0][1], 3, color = (135, 255, 0), thickness = 2, fill = False) img.draw_circle(corner[1][0], corner[1][1], 3, color = (0, 70, 255), thickness = 1, fill = False) img.draw_circle(corner[2][0], corner[2][1], 3, color = (0, 70, 255), thickness = 1, fill = False) img.draw_circle(corner[3][0], corner[3][1], 3, color = (0, 70, 255), thickness = 1, fill = False) corner1_str = f&quot;(&#123;corner[0][0]&#125;,&#123;corner[0][1]&#125;)&quot; corner2_str = f&quot;(&#123;corner[1][0]&#125;,&#123;corner[1][1]&#125;)&quot; corner3_str = f&quot;(&#123;corner[2][0]&#125;,&#123;corner[2][1]&#125;)&quot; corner4_str = f&quot;(&#123;corner[3][0]&#125;,&#123;corner[3][1]&#125;)&quot; print(&quot;矩形关键点坐标:&quot;) print(&quot;corner1 = &quot; + corner1_str + &quot; &quot; + &quot;corner2 =&quot;+ corner2_str + &quot; &quot; + &quot;corner3 =&quot;+ corner3_str + &quot; &quot; + &quot;corner4 =&quot;+ corner4_str ) dataxy=bytearray([0xa1,0xb1,corner[0][0],corner[1][0],corner[2][0],corner[3][0],corner[0][1],corner[1][1],corner[2][1],corner[3][1],0xc1]) uart.write(dataxy) img.draw_string(10, 10, corner1_str, color=(255,0,70), scale=2, x_spacing=-5, mono_space=True) img.draw_string(10, 10, &quot; &quot; + corner3_str, color=(255,0,70), scale=2, x_spacing=-5, mono_space=True)\tlcd.write(img) 4.延时拍照片并存储1234567891011121314151617181920# OpenMV 延时拍照片并存储# 注意:您需要一张TF卡来运行import sensorimport timeimport display # 引入lcd屏幕sensor.reset() # 初始化sensorsensor.set_pixformat(sensor.RGB565) # 设置图像色彩格式，有RGB565色彩图和GRAYSCALE灰度图两种sensor.set_framesize(sensor.QVGA) # 设置图像像素大小 QVGA (320x240)lcd = display.SPIDisplay() # 初始化lcd屏幕。sensor.skip_frames(time=2000) # 让新的设置生效img = sensor.snapshot()img.save(&quot;example.jpg&quot;) # or &quot;example.bmp&quot; (or others)img_copy = img.copy(x_scale=128/img.width(),y_scale=160/img.height())while(True): lcd.write(img_copy) # 让LCD屏显示拍到的图像 5.计算指定区域最暗&#x2F;最亮阈值：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import sensor, image, time, pybimport display # 引入lcd屏幕# 启用串口 P4,P5 (TX,RX)from pyb import UARTuart = pyb.UART(3, 9600)uart.init(9600, bits=8, parity=None, stop=1)# 初始化lcd屏幕lcd = display.SPIDisplay()# 初始化摄像头sensor.reset()#sensor.set_vflip(True) # 打开垂直翻转模式#sensor.set_hmirror(True) # 打开水平镜像模式sensor.set_pixformat(sensor.RGB565) # 设置图像色彩格式为RGB565格式sensor.set_framesize(sensor.QVGA) # 设置图像大小#sensor.set_framesize(sensor.QQVGA2) # 返回128x160图像帧大小以适配OpenMV配套液晶屏。sensor.set_auto_gain(False) # 颜色跟踪必须关闭自动增益sensor.set_auto_whitebal(False) # 颜色跟踪必须关闭白平衡#sensor.set_brightness(3000) # 设置亮度为3000sensor.skip_frames(time = 500) # 跳过帧clock = time.clock()# 给x毫秒时间准备，计算ROI区域中阈值，作为目标阈值之一;for i in range (200): img = sensor.snapshot() img.draw_rectangle((0,0,img.width(),img.height()),color=(255,0,0)) # 在视野中框出指定ROI区域，用于提取其中颜色阈值 statistics = img.get_statistics (roi=(0,0,img.width(),img.height())) #得到搜寻区域内的图像统计信息#thresholds=(10, 80, -20, 50, -20, 50), color_L_min = statistics.l_min() #分别赋值LAB的众数 color_L_max = statistics.l_max() color_A_min = statistics.a_min() color_A_max = statistics.a_max() color_B_min = statistics.b_min() color_B_max = statistics.b_max() #基于色块容错空间 relative_darkest_threshold = (color_L_min, color_L_min+1, color_A_min, color_A_min+1, color_B_min, color_B_min+1) relative_brightest_threshold = (color_L_max-1, color_L_max, color_A_max-1, color_A_max, color_B_max-1, color_B_max) print(relative_darkest_threshold) print(relative_brightest_threshold) print(&quot; &quot;)while True: clock.tick() img = sensor.snapshot() print(relative_darkest_threshold) print(relative_brightest_threshold) print(&quot; &quot;) 整理已经弄清楚的知识点:(不明白的去官方函数库查询)1.初始化：摄像头(感光元件)初始化：1234567891011import sensorsensor.reset() #重启感光元件#sensor.set_vflip(True) #打开垂直翻转模式#sensor.set_hmirror(True) #打开水平镜像模式sensor.set_pixformat(sensor.RGB565) # or sensor.GRAYSCALE # 设置相机模块的像素模式:RGB565#sensor.set_framesize(sensor.QQVGA) #设置返回图像的帧大小，分辨率160*120sensor.set_framesize(sensor.QQVGA2) # 返回128x160图像帧大小以适配OpenMV配套液晶屏。sensor.set_auto_gain(False) #颜色跟踪必须关闭自动增益sensor.set_auto_whitebal(False) #颜色跟踪必须关闭白平衡sensor.skip_frames (time = 1000) #跳过启动后的前x毫秒以求稳定 图像处理(机器视觉)初始化：1import image 时钟(跟踪运行时间)初始化：123import timeclock = time.clock() # 创建一个计时器对象，用于计算每秒钟的帧数。 屏幕显示驱动初始化：1234import display # 引入lcd屏幕lcd = display.SPIDisplay() # 初始化lcd屏幕。 lcd.write(img) # 让LCD屏显示拍到的图像(在while中) 串口通信(UART)初始化：12345678import pyb# 启用串口 P4,P5 (TX,RX)# OpenMV4 H7 Plus, OpenMV4 H7, OpenMV3 M7, OpenMV2 M4 的UART(3)是P4-TX P5-RX# OpenMV RT 只有串口UART(1)，对应P4-TX P5-RX; OpenMV4 H7 Plus, OpenMV4 H7, OpenMV3 M7 的UART(1)是P0-RX P1-TXfrom pyb import UART # 从pyb库中启用uart串口通信uart = UART(3, 9600, timeout_char=1000) #创建UART对象，使用第3个UART端口，设置波特率为9600uart.init(9600, bits=8, parity=None, stop=1, timeout_char=1000) #初始化UART总线，时钟速率9600，每个字符占8位，不进行奇偶化校验，停止位数量为1 LED(补光灯)初始化：12345from pyb import LED LED(1).on() #红LED(2).on() #绿LED(3).on() #蓝 引脚高低电平初始化：12345from pyb import Pin # pyb模块包含与插件相关的特定函数，引入引脚# 初始化P0引脚，输出高电平p0 = Pin(&#x27;P0&#x27;, Pin.OUT)p0.value(1) 2.全局变量定义、自定义函数定义：最大色块更新函数：12345678# 最大色块更新函数def find_max(blobs): # 定义函数 find_max , 接受参数 blobs , 意在从分析出的色块中找出面积最大的 max_size=0 # 定义一个变量 max_size , 初始化时这个值为0 for blob in blobs: if blob[2]*blob[3] &gt; max_size: max_blob=blob max_size = blob[2]*blob[3] return max_blob ROI(感兴趣区域)：1ROI = (x,x,x,x) Thresholds(阈值列表)：12345thresholds = [(4, 70, 18, 127, -125, 127), # for red1 (0, 35, 20, 75, -25, 45), # for red2 (13, 70, 3, 55, 4, 40), # for red3 (30, 100, -64, -8, -32, 32), # for green (0, 30, 0, 64, -128, 0)] # for blue 3.启动任务进程：标准进程框架：123456while(True): clock.tick() # 计算从上一次调用tick()到现在的时间，以确定每秒钟的帧数 img = sensor.snapshot() # 拍照片，返回图像 # img = sensor.snapshot().binary([(4, 70, 18, 127, -125, 127)]) # 拍二值化图片(阈值自定义)，返回图像 x&#x27;x&#x27;x&#x27;x&#x27;x&#x27;x&#x27;x&#x27;x&#x27;x (其他任务、算法) lcd.write(img) # 让LCD屏显示拍到的图像(一般放在进程末尾) 算法：1.最大色块算法(包含十字路口检测)：1234567891011121314151617181920# 最大色块算法 # 在图像中寻找符合指定条件的色块。找到的色块将被存储在变量blobs中，在调用find_max函数找出最大色块 blobs = img.find_blobs([(20, 255)], x_stride=1, y_stride=1, pixels_threshold=180, area_threshold=180, merge=True)#, suit,[thresholds[threshold_index]] if blobs: max_blob = find_max(blobs)# #定义横纵坐标偏移量，意为探测计算出的色块的中心点距离视野中心点的偏移量，旨在引导小车左右转和加速减速# x_error = max_blob.cx()-img.width()/2 # 左右偏移量 = 色块中心点横坐标-视野中心点横坐标，范围[-64,64]# y_error = max_blob.cy()-img.height()/2 # 纵偏移量 = 色块中心点纵坐标-视野中心点纵坐标,范围[-80,80] rotate_angle = 180 * (max_blob.cx() / img.width()) #定义变量crossroad,判断是否为十字路口 if max_blob.w()&lt;img.width()*0.7: crossroad = 0 else: crossroad = 1 img.draw_rectangle(max_blob.rect()) # 画矩形，根据计算出的最大色块大小 img.draw_cross(max_blob.cx(), max_blob.cy(),color=(255,0,0)) # 画交叉十字，根据计算出的最大色块中心点位置 2.直线算法：123456789# 直线算法 line = img.get_regression([(20, 255)], pixels_threshold=120, area_threshold=120, robust = True) if line:# rho_err = abs(line.rho())-img.width()/2 if line.theta()&gt;90: theta_err = line.theta()-90 else: theta_err = line.theta()+90 img.draw_line(line.line(), color = 127) 3.最大色块+直线融合算法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 # 色块算法 # 在图像中寻找符合指定条件的色块。找到的色块将被存储在变量blobs中，在调用find_max函数找出最大色块 blobs = img.find_blobs([(20, 255)], x_stride=1, y_stride=1, pixels_threshold=180, area_threshold=180, merge=True)#, suit,[thresholds[threshold_index]] if blobs: max_blob = find_max(blobs)# #定义横纵坐标偏移量，意为探测计算出的色块的中心点距离视野中心点的偏移量，旨在引导小车左右转和加速减速# x_error = max_blob.cx()-img.width()/2 # 左右偏移量 = 色块中心点横坐标-视野中心点横坐标，范围[-64,64]# y_error = max_blob.cy()-img.height()/2 # 纵偏移量 = 色块中心点纵坐标-视野中心点纵坐标,范围[-80,80] rotate_angle = 180 * (max_blob.cx() / img.width()) #定义变量crossroad,判断是否为十字路口 if max_blob.w()&lt;img.width()*0.7: crossroad = 0 else: crossroad = 1 img.draw_rectangle(max_blob.rect()) # 画矩形，根据计算出的最大色块大小 img.draw_cross(max_blob.cx(), max_blob.cy(),color=(255,0,0)) # 画交叉十字，根据计算出的最大色块中心点位置 # 直线算法 line = img.get_regression([(20, 255)], pixels_threshold=120, area_threshold=120, robust = True) if line:# rho_err = abs(line.rho())-img.width()/2 if line.theta()&gt;90: theta_err = line.theta()-90 else: theta_err = line.theta()+90 img.draw_line(line.line(), color = 127) chimera = theta_err*0.7 + rotate_angle*0.3 # 屏幕显示参数区(如需节约性能，请写固定数值)# img.draw_string(int(img.width()*0.1), int(img.width()*0.1), str(int(chimera)), color=(0,185,255), scale=int(img.width()*0.016), x_spacing=int(img.width()*0.016)*-2) img.draw_string(10, 10, str(int(chimera)), color=(0,185,255), scale=2, x_spacing=-5) # 串口数据定义并发送区 # 要发送的数据:[帧头 a3 b3,中间*个十六位数据，帧尾 c3] data=bytearray([0xa3,0xb3,int(chimera),int(crossroad),0xc3]) # 发送数据 uart.write(data) # 串行终端发送区 print(&quot; &quot;) print(&quot;当前帧数:&quot;, clock.fps(), &quot;fps&quot;)## print(&quot;目标横坐标(0-128):&quot;, max_blob.cx())## print(&quot;目标纵坐标(0-160):&quot;, max_blob.cy())## print(&quot;横坐标偏离值[-64,64]:&quot;, x_error)## print(&quot;纵坐标偏离值[-80,80]:&quot;, y_error)## print(&quot;色块转向角度:&quot;, max_blob.rotation()) print(&quot;是否检测到十字路口:&quot;, crossroad)# print(&quot;色块偏离值:&quot;, rotate_angle) #[0,180]# print(&quot;线角度:&quot;,theta_err) #[0,180] print(&quot;推荐转向&quot;, chimera) 4.矩形检测+返回矩形四角坐标算法：123456789101112131415161718192021222324252627282930313233343536373839404142434445# -----矩形框部分----- # 在图像中寻找矩形 for r in img.find_rects(threshold = 10000): # 判断矩形边长是否符合要求 if r.w() &gt; 15 and r.h() &gt; 15: # 在屏幕上框出矩形 img.draw_rectangle(r.rect(), color = (255, 0, 0), scale = 4) # 获取矩形角点位置 corner = r.corners() # 在屏幕上圈出矩形角点(第一个点通常为左下角那个) img.draw_circle(corner[0][0], corner[0][1], 3, color = (135, 255, 0), thickness = 2, fill = False) img.draw_circle(corner[1][0], corner[1][1], 3, color = (0, 70, 255), thickness = 1, fill = False) img.draw_circle(corner[2][0], corner[2][1], 3, color = (0, 70, 255), thickness = 1, fill = False) img.draw_circle(corner[3][0], corner[3][1], 3, color = (0, 70, 255), thickness = 1, fill = False) # 打印四个角点坐标, 角点1的数组是corner[0], 坐标就是(corner[0][0],corner[0][1]) # 角点检测输出的角点排序每次不一定一致，矩形左上的角点有可能是corner0,1,2,3其中一个 corner1_str = f&quot;(&#123;corner[0][0]&#125;,&#123;corner[0][1]&#125;)&quot; corner2_str = f&quot;(&#123;corner[1][0]&#125;,&#123;corner[1][1]&#125;)&quot; corner3_str = f&quot;(&#123;corner[2][0]&#125;,&#123;corner[2][1]&#125;)&quot; corner4_str = f&quot;(&#123;corner[3][0]&#125;,&#123;corner[3][1]&#125;)&quot; print(&quot;矩形关键点坐标:&quot;) print(&quot;corner1 = &quot; + corner1_str + &quot; &quot; + &quot;corner2 =&quot;+ corner2_str + &quot; &quot; + &quot;corner3 =&quot;+ corner3_str + &quot; &quot; + &quot;corner4 =&quot;+ corner4_str )# data1=bytearray([0xa1,0xb1,corner[0][0],corner[0][1],0xc1]) # 定义点坐标1(通常为左下角那个)# uart.write(data1)# data2=bytearray([0xa2,0xb2,corner[1][0],corner[1][1],0xc2]) # 定义点坐标2# uart.write(data2)# data3=bytearray([0xa3,0xb3,corner[2][0],corner[2][1],0xc3]) # 定义点坐标3# uart.write(data3)# data4=bytearray([0xa4,0xb4,corner[3][0],corner[3][1],0xc4]) # 定义点坐标4# uart.write(data4) dataxy=bytearray([0xa1,0xb1,corner[0][0],corner[1][0],corner[2][0],corner[3][0],corner[0][1],corner[1][1],corner[2][1],corner[3][1],0xc1]) # 四个点的x坐标和y坐标(通常左下角那个是第一个) uart.write(dataxy)# print(dataxy) img.draw_string(10, 10, corner1_str, color=(255,0,70), scale=2, x_spacing=-5, mono_space=True) # 屏幕显示 img.draw_string(10, 10, &quot; &quot; + corner3_str, color=(255,0,70), scale=2, x_spacing=-5, mono_space=True) # 屏幕显示 俯视检测追踪特定颜色矩形算法：12345678910111213141516171819202122232425262728293031323334353637blobs_blue = img.find_blobs([blue_threshold], roi = (0,0,img.width(),img.height()))if blobs_blue:# 在矩形内检测到蓝色，说明是己方宝藏 b = find_max(blobs_blue) # 将返回数据赋值给b if b.density()&gt;0.7 and b.w()&gt;img.width()*0.3: img.draw_cross(b[5], b[6]) # cx, cy img.draw_cross(int(img.width()*0.5), int(img.height()*0.5), size=5, color=(0,255,0)) #img.draw_cross(0, 0, size=5, color=(0,255,0)) img.draw_line((int(img.width()*0.5), int(img.height()*0.5),b[5], b[6]), color=(255,0,255)) a_x=b.cx()-int(img.width()*0.5) a_y=b.cy()-int(img.height()*0.5) img.draw_rectangle(b.rect(), color = (0, 0, 255)) FH = bytearray([0xAA,0xFF,0xCC,0x00,moshi,a_x,a_y,0x00,0x00]) lens = len(FH)#数据包大小 FH[3] = lens-6;#有效数据个数 i = 0 sum = 0 sum1 = 0 #和校验 while i&lt;(lens-2): sum = sum + FH[i] sum1 = sum1 + sum i = i+1 FH[lens-2] = sum; FH[lens-1] = sum1; #传输数据给单片机 #uart_buf = bytearray(row_data) uart3.write(FH) print(FH) print(&quot;x偏移:&quot;,a_x,&quot;y偏移:&quot;,a_y,&quot; &quot;) # 在检测到的真宝藏上画蓝框 # 屏幕显示 img.draw_string(10, 10, str(a_x) + &quot;,&quot; + str(a_y), color=(255,0,70), scale=2, x_spacing=-5, mono_space=True) else: print(&quot;未检测&quot;)else: print(&quot;未检测&quot;) 指定区域阈值检测算法：12345678910111213141516# 给x毫秒时间准备，计算ROI区域中阈值，作为目标阈值之一;for i in range (200): img = sensor.snapshot() img.draw_rectangle((0,0,img.width(),img.height()),color=(255,0,0)) # 在视野中框出指定ROI区域，用于提取其中颜色阈值 statistics = img.get_statistics (roi=(0,0,img.width(),img.height())) #得到搜寻区域内的图像统计信息#thresholds=(10, 80, -20, 50, -20, 50), color_L_min = statistics.l_min() #分别赋值LAB的众数 color_L_max = statistics.l_max() color_A_min = statistics.a_min() color_A_max = statistics.a_max() color_B_min = statistics.b_min() color_B_max = statistics.b_max() #基于色块容错空间 relative_darkest_threshold = (color_L_min, color_L_min+1, color_A_min, color_A_min+1, color_B_min, color_B_min+1) relative_brightest_threshold = (color_L_max-1, color_L_max, color_A_max-1, color_A_max, color_B_max-1, color_B_max) 屏幕图像缩放显示：1img_copy = img.copy(x_scale=128/img.width(),y_scale=160/img.height()) 屏幕显示参数：12345 # 屏幕显示参数区(如需节约性能，请写固定数值)# img.draw_string(int(img.width()*0.1), int(img.width()*0.1), str(int(chimera)), color=(0,185,255), scale=int(img.width()*0.016), x_spacing=int(img.width()*0.016)*-2) img.draw_string(10, 10, str(int(chimera)), color=(0,185,255), scale=2, x_spacing=-5) img.draw_string(10, 10, corner1_str, color=(255,0,70), scale=2, x_spacing=-5, mono_space=True) # 屏幕显示 mg.draw_string(10, 10, &quot; &quot; + corner3_str, color=(255,0,70), scale=2, x_spacing=-5, mono_space=True) # 屏幕显示 串口数据定义并发送：12345# 串口数据定义并发送区# 要发送的数据:[帧头 a3 b3,中间*个十六位数据，帧尾 c3]data=bytearray([0xa3,0xb3,int(chimera),int(crossroad),0xc3])# 发送数据uart.write(data) 串行终端发送：123456789101112# 串行终端发送区 print(&quot; &quot;) print(&quot;当前帧数:&quot;, clock.fps(), &quot;fps&quot;)## print(&quot;目标横坐标(0-128):&quot;, max_blob.cx())## print(&quot;目标纵坐标(0-160):&quot;, max_blob.cy())## print(&quot;横坐标偏离值[-64,64]:&quot;, x_error)## print(&quot;纵坐标偏离值[-80,80]:&quot;, y_error)## print(&quot;色块转向角度:&quot;, max_blob.rotation()) print(&quot;是否检测到十字路口:&quot;, crossroad)# print(&quot;色块偏离值:&quot;, rotate_angle) #[0,180]# print(&quot;线角度:&quot;,theta_err) #[0,180] print(&quot;推荐转向&quot;, chimera) AprilTag:一句话解释作用：AprilTag 是一种二维条形码，可以根据它得到 标签的id(编号)、三个坐标量和三个旋转量(以相机位置为原点) 推荐TAG36H11家族(587标签) 123456789101112131415161718192021222324252627282930313233343536373839404142434445# AprilTags 3D定位# AprilTags Example## This example shows the power of the OpenMV Cam to detect April Tags# on the OpenMV Cam M7. The M4 versions cannot detect April Tags.import sensor, image, time, mathsensor.reset()sensor.set_pixformat(sensor.RGB565)sensor.set_framesize(sensor.QQVGA) # we run out of memory if the resolution is much bigger...sensor.skip_frames(30)sensor.set_auto_gain(False) # must turn this off to prevent image washout...sensor.set_auto_whitebal(False) # must turn this off to prevent image washout...clock = time.clock()# 注意！与find_qrcodes不同，find_apriltags 不需要软件矫正畸变就可以工作。# 注意，输出的姿态的单位是弧度，可以转换成角度，但是位置的单位是和你的大小有关，需要等比例换算# f_x 是x的像素为单位的焦距。对于标准的OpenMV，应该等于2.8/3.984*656，这个值是用毫米为单位的焦距除以x方向的感光元件的长度，乘以x方向的感光元件的像素（OV7725）# f_y 是y的像素为单位的焦距。对于标准的OpenMV，应该等于2.8/2.952*488，这个值是用毫米为单位的焦距除以y方向的感光元件的长度，乘以y方向的感光元件的像素（OV7725）# c_x 是图像的x中心位置# c_y 是图像的y中心位置f_x = (2.8 / 3.984) * 160 # 默认值f_y = (2.8 / 2.952) * 120 # 默认值c_x = 160 * 0.5 # 默认值(image.w * 0.5)c_y = 120 * 0.5 # 默认值(image.h * 0.5)def degrees(radians): return (180 * radians) / math.piwhile(True): clock.tick() img = sensor.snapshot() for tag in img.find_apriltags(fx=f_x, fy=f_y, cx=c_x, cy=c_y): # 默认为TAG36H11 img.draw_rectangle(tag.rect(), color = (255, 0, 0)) img.draw_cross(tag.cx(), tag.cy(), color = (0, 255, 0)) print_args = (tag.x_translation(), tag.y_translation(), tag.z_translation(), \\ degrees(tag.x_rotation()), degrees(tag.y_rotation()), degrees(tag.z_rotation())) # 位置的单位是未知的，旋转的单位是角度 print(&quot;Tx: %f, Ty %f, Tz %f, Rx %f, Ry %f, Rz %f&quot; % print_args) print(clock.fps()) Tx: 左右移动 Ty:上下移动 Tz:距离 Rx:上下旋转 Ry:左右旋转 Rz:自转","tags":["嵌入式","计算机视觉"],"categories":["计算机视觉"]},{"title":"Markdown 基本语法","path":"/Markdown-Tool/","content":"本篇主要收录 Typora (轻量级Markdown编辑器) 功能以外的 Markdown语法换行 ：行尾加 &lt;br&gt;Unthrifty loveliness, why dost thou spend你若挥霍无度Upon thy self thy beauty’s legacy?容颜能置之有顾？ 1Unthrifty loveliness, why dost thou spend&lt;br&gt;你若挥霍无度&lt;br&gt;Upon thy self thy beauty&#x27;s legacy?&lt;br&gt;容颜能置之有顾？ 图像&#x2F;文字 居左&#x2F;中&#x2F;右1&lt;img src=&quot;url路径&quot; align=&quot;left/right/center&quot; style=&quot;zoom:25%;&quot; /&gt; 1&lt;p align=&quot;left/right/center&quot;&gt;hello world&lt;/p&gt;","tags":["博客搭建","Markdown"],"categories":["Markdown"]},{"title":"ESP32-Cam 初步使用：网络摄像头示例","path":"/ESP32-Cam/","content":"此片意在教会你如何初步使用ESP32-cam 阅读本文，你将学会：一. 学会安装Arduino二. 学会使用相关例程 一、Arduino 的下载安装及汉化1.下载Arduino（Arduino 软件下载官网） 2.Arduino的安装 3.Arduino的汉化：左上角 File–&gt;Preferences(Ctrl+逗号也能进入)–&gt;Settings–&gt;Language–&gt;中文(简体)–&gt;OK 二、ESP32-cam 的初始化及例程使用1.在 Arduino 中初始化 ESP32-cam：让 Arduino 认识你的 ESP32-cam； 如图所示操作：工具—&gt;开发板—&gt;开发版管理器，找到 esp32 by Espressif Systems，选择任意版本下载（主要看你那个能下载成功，我下载的是2.0.10版本）； 选择接口及对应开发板（Al Thinker ESP32-CAM) 2.尝试ESP32例程项目：CameraWebServer 此时会跳出新页面（CameraWebServer项目）；选择该项目； 3.在CameraWebServer项目代码中进行操作代码中一共有四处需要修改的地方 开始编译认证： 编译无问题后如此显示： 接下来上传（即 将代码烧录到ESP32-cam中） 上传（烧录）成功后如此显示： 4、通过串口获取 ESP32-cam 所在的IP我们打开任意串口监视器（我用的正点原子串口调试助手） 5、进入操作界面 使用一台与ESP32-cam所连WiFi&#x2F;热点相同的设备(PC&#x2F;手机都行)，在浏览器标题栏中输入所得IP地址，回车进入，出现如下画面 三、项目的保存在体验了一番 ESP32-cam 摄像头后（然而并没有什么卵用 我们将项目保存以便下次使用 1.保存方式：按下 Ctrl+S 或 文件 —&gt; Save；","tags":["嵌入式","ESP32-Cam"],"categories":["嵌入式"]},{"title":"CSDN博客文章如何转为Markdown","path":"/CSDN-pages-turn-to-Markdown/","content":"文章目录 1.在CSDN博文页面点击右键，选择“检查”（Google浏览器为例）。 2.在查看器中搜索`article_content`，找到对应内容，点击…复制为`outerHTML`。 3.打开网址https://tool.lu/markdown/，点击HTML2MD，粘贴html代码，转换成Markdown。 参考文献 1.在CSDN博文页面点击右键，选择“检查”（Google浏览器为例）。 2.在查看器中搜索article_content，找到对应内容，点击…复制为outerHTML。 3.打开网址https://tool.lu/markdown/，点击HTML2MD，粘贴html代码，转换成Markdown。 参考文献 https://blog.csdn.net/Better_Xing/article/details/125246147## 目标 原理","tags":["博客搭建","转载"],"categories":["文件格式转化"]},{"title":"计算机三级网络技术考过指南","path":"/NCRE-3/","content":"计算机三级网络技术考过指南原文链接：计算机三级网络技术考过指南 题库下载链接（50积分是CSDN上调的，不是我上传时设置的。更新版本请大家自行搜索）：计算机三级网络技术无纸化考试模拟软件（2018.3) 文章目录 计算机三级网络技术考过指南 前言（必读） 1.基础准备 1.1 题库 1.2 二进制转换 1.3 基础概念 1.4 备考建议 2.选择题（40 道 40 分） 2.1 第一类选择题 2.1.1 问传输速度 2.1.2 求交换机带宽 2.1.3 系统可用性与停机时间 2.1.4 写地址块的子网掩码 2.1.5 网络地址转换 NAT 2.1.6 IP 地址块聚合 2.1.7 路由表距离更新 2.1.8 IPv6 地址简化表示 2.1.9 数据包 2.1.10 三种备份 2.2 第二类选择题 2.3 第三类选择题 2.3.1 弹性分组环 RPR 2.3.2 无线接入技术 2.3.3 广域网 QoS 2.3.4 接入技术特征 2.3.5 服务器技术 2.3.6 综合布线 2.3.7 BGP 协议 2.3.8 RIP 协议 2.3.9 OSPF 协议 2.3.10 集线器 2.3.11 交换机 2.3.12 路由器 2.3.13 IEEE 802.11 2.3.14 蓝牙 2.3.15 Serv-U FTP 服务器 2.3.16 DNS 服务器 2.3.17 DHCP 服务器 2.3.18 WWW 服务器 2.3.19 Wmail 邮件服务器 2.3.20 PIX 防火墙 2.3.21 可信计算机评估准则 2.3.22 入侵防护系统 2.3.23 网络攻击 2.3.24 无线局域网设备 2.3.25 VLAN 2.3.26 Cisco 路由器上的存储器 2.3.27 防火墙对应端口的连接方案 2.3.28 STP 生成树结构 2.3.29 Catelyst 配置命令 2.3.30 其他 3.大题（前四道每道10分，最后一道20分） 3.1 第一道 填地址表 3.2 第二道 配置路由器 3.3 第三道 DHCP 报文 3.4 第四道 sniffer 数据包 3.5 最后一道 3.5.1 填表部分（12分） 3.5.2 中间部分（2~4分） 3.5.3 计算子网掩码和 IP 段部分（4~6分） 总结：得分策略 前言（必读）本文档总大小 5MB 左右，请注意流量若手机端浏览不便，请尝试使用电脑浏览器 这份指南写于我备考三级一周后，因为做了几套题之后感觉这个考试的知识点和题型很固定，而将这些知识点和做法概括总结出来可以帮助以后考试的同学。 对于没有相应基础的绝大多数同学，如果想考过三级网络技术，首先要克服见到陌生复杂题目的恐惧感。话说回来，其实这些题没有哪一道是真正需要动脑进行复杂思考的，只是知识点没见过，做题的方法不清楚，一旦知道了就能写对。这个考试没有什么含金量，一周的练习基本上足够了。 我们专业去年上了计算机网络这门课，但跟这个考试的关系不大，只有少量的考点学过。所以我对题目的解析是很业余的，但这也是个好处，正是因为不专业写的就比较直白，适合没有基础的同学参考。 另外，需要强调一下，本文档以应试为目的指在帮助你通过考试，而非掌握计算机网络技术。 如果发现有错误或者有其他建议请与我联系，多谢。 我的邮箱：&#105;&#x6e;&#x63;&#x72;&#x65;&#x61;&#115;&#101;&#x73;&#x6f;&#x6e;&#x67;&#64;&#x66;&#x6f;&#120;&#109;&#97;&#x69;&#108;&#x2e;&#x63;&#x6f;&#109; 请勿修改这份文档欢迎把笔记链接分享给有需要的同学 后增：为什么考三级？既然二级都过了，再考个三级呗，有的学校可能还有实践学分。别人二级office的很多，你三级看上去就显得厉害一点。 【重要更新】自2018年3月份全国计算机等级考试（第51次）起，取消了三级获证的前置条件。直接报名考三级就可以了，不再需要对应的二级科目通过。 为什么三级选网络技术这科？因为我考的时候，查了查发现考这个的最多，考的人越多的科目考试题就可能越标准规范，我对其他的科目也没有特别有兴趣的，所以就考这个了。所以我也只能写网络技术，所以你们选网络技术备考也就最方便。 要不要考四级？计算机等级考试基本是给非计算机专业设置的考试，所以本来就没什么含金量，我没有考。还想考计算机方面的证，可以去考软考[计算机技术与软件专业技术资格（水平）考试]。听说计算机等级考试四级比三级还简单，也是买题做题就行了。 1.基础准备1.1 题库买一本三级网络技术题库或者是题库软件（20 元左右），不需要买更多，总之有成套的题可以做就行。真题目前大概有二十套左右。 1.2 二进制转换应该学过 网络技术用到的一般是八位二进制数。也就是 0 ~ 255，即 0000 0000 ~ 1111 1111（每四位空一格便于观察） 我做题前在草稿纸上先这样画 这样，比如说我看见 1001 1000 这个数，就知道这是 128+16+8 对应的数。 反过来，十进制转换二进制也可以利用这个简图。还有一些规律，自己做题中摸索吧，你可能会找到更好的方法。 下面几组记忆一下，做题时会比较方便（不要畏难，做题见多了就记住了） 二进制 十进制 1000 0000 128 1100 0000 192 1110 0000 224 1111 0000 240 1111 1111 255 1.3 基础概念如果是学过计算机网络相关知识的同学可以不看，下面是非专业的不标准的可能还有错的描述，仅仅是为了完全没有基础的同学有个粗略了解。 计算机网络是一些电脑相互链接组成的，这些电脑叫做主机，可能相距很远，也可能是一间屋子里的。 就像正常情况下两个人要用同一种语言交流一样。主机之间的联系也要按照相同的标准才行，这些标准叫做协议。因为主机之间的联系是一件复杂的事。所以有多种协议解决不同方面的问题，比如 TCP、BGP、DHCP 等等。 相距太远的主机之间不能直接联系，就需要一些设备，比如路由器、交换机等等，你只知道他们都是为了主机联系的中间转发设备就行。 还需要地址，因为没有地址就不知道主机在哪，这个标识主机的就是 IP 地址。IP 地址是类似这样的：10000000.1110000.01000000.10110001，一共 32 位，为了人看起来方便就写成 128.224.64.177 这种点分十进制的形式。 还有一种叫做 MAC 地址，是标识硬件设备的地址。 主机还可以广播给整个网络，广播地址是 IP地址 32 位全置 1 的地址，即 255.255.255.255。 当你访问一个网站，你的电脑先将网址发送给 DNS 服务器（域名解析服务器），这个服务器能将你写的网址域名变成 IP 地址，这样你的电脑就知道想要访问的网页放在哪了。 上面这些并不能让你真正理解计算机网络（其实我也不是很清楚），主要是让你在见到陌生名词的时候别害怕，有些名词不理解也不会影响做题。 1.4 备考建议这就是个人的方法了，也不一定适合你。 【1】首先对着一套三级题和答案看一遍，每道题都看答案解析是怎么说的。看答案不必弄懂（当然你要真的全弄懂也很厉害），知道怎么选出来就行，不明白跳过也行。同时也找找看看我笔记里写没写这道题的知识点。 这一遍是比较简略的，对题目有个简单的印象就够了。但这遍也是比较困难的，因为几乎都是陌生的东西。 【2】接下来，同时做两三套试题甚至更多套。按着笔记里的知识点做，看到哪个知识点就到这些套题里找，对照着做题来掌握这个知识点。如果笔记里没有提到或者没写详细的就看答案怎么说，实在不明白的还可以跳过。 这个阶段是需要比较认真的看了，我这个阶段是在写笔记中度过的。经过这个阶段你就能明白哪些知识点考察比较固定，一些题的固定做法是什么，对考试有比较完全的认识了。 【3】接下来，就把剩下的套题都做了，反正一共就二十套左右。怎么做都行，按套或者按题型什么的自己安排，反正做一遍。如果没时间了，至少把选择题做一遍。 这一遍就是完善熟练的阶段，还可能有一些我笔记里没写的知识点你也会了。 【补充】有的同学还是感觉难，那就先把第一道大题和最后一道大题的两个填表都仔细弄会了。这两个表就 20 分到手了。接下来学习可能会感觉踏实一点。 2.选择题（40 道 40 分）根据做题方法不同划为三类 第一类：几乎每套题都考，掌握简单做法即可选出正确答案 第二类：每套题里有 5 道左右，看上去非常复杂的大段配置代码 第三类：从四个选项里选出一项正确或错误的，其中部分知识点是常考的，比较零散 2.1 第一类选择题2.1.1 问传输速度OC-3 对应 155.52 MbpsOC-12 对应 622.08 Mbps（显然，这是一道送分题） 2.1.2 求交换机带宽通常是求总带宽例：某交换机有 12 个 10&#x2F;100 Mbps 电端口和 2 个 1000 Mbps 光端口，所有端口都在全双工状态下，那么总带宽为（ ）解：忽略 10&#x2F;100 中的 10，当成 100 Mbps 就好。12 * 100 + 2 * 1000 &#x3D; 3200，又因为全双工所以乘以 2 得 6400 Mbps ,即 6.4 Gbps 有时候求上联端口带宽例：某交换机有 16个100&#x2F;1000 Mbps 全双工下联端口，那么上联端口带宽至少为（ ）解：16 * 1000 * 2 &#x3D; 32000 Mbps &#x3D; 32 Gbps，上联一般是下联的 1&#x2F;20 ，所以至少为 32 除以 20 得 1.6 Gbps 2.1.3 系统可用性与停机时间可用性 停机时间 99.9% ≤8.8小时 99.99% ≤53分钟 99.999% ≤5分钟 也是送分题，但要记准确。比如 53 分钟，有时候会问 55 分钟的情况，要是记成 50 或者大约 1 小时就没法做了。 2.1.4 写地址块的子网掩码例：IP 地址块 59.67.159.125&#x2F;11 的子网掩码可写为（ ）解：不用看 IP 地址，只看 &#x2F;11 就够了。11 代表子网掩码的前 11 位都是 1 ，所以可以写出子网掩码 11111111.11100000.00000000.00000000 转换为十进制即是 255.224.0.0做题熟练后其实不用写上面那堆 1 和 0 就能选出正确答案。 2.1.5 网络地址转换 NAT会给你一个这样的图，问你 ① ② 是什么只需要知道②和紧挨着它的 S 数字相同，所以②应该是 202.0.1.1,5001 ;同理，①是 10.0.0.1,3342。还有时候会问某个小方框里的 S,D 分别是什么，看上面的图你会发现，上面两个方框和下面两个方框里的数字是对称的，做题时对称一下就写出答案了。 2.1.6 IP 地址块聚合第一种：问聚合后的地址块下面演示三个地址的聚合步骤为：转成二进制；对齐找前多少位是相同的；转回十进制写答案。这样就得出聚合后的地址为：192.67.159.192&#x2F;26Tips：转换二进制时，因为前三段十进制本来就一样，所以可以只转换最后一段；不要一个一个数有多少位相同的，因为前三段相同就知道有 3 * 8 &#x3D; 24 位，再加上 2 就是 26。 第二种：问聚合后可用 IP 数下面两种情况的做法由网友 Yes 补充，十分感谢，之前我写的不当方法已删除。 【第一种情况】如未来教育上机考试第一套试题第10题：“ IP 地址块 202.113.79.128&#x2F;27、202.113.79.160&#x2F;27 和 202.113.79.192&#x2F;27 经过聚合后可用的地址数为___” 因为格式都是 xxx.xxx.xxx.xxx&#x2F;27，本题中“&#x2F;”后边的数字都是相同的。所以遇到这种题，先把前两个 IP 聚合求出可用地址数，然后单独算出第三个 IP 地址可用地址数，两个地址数相加即正确答案。 【第二种情况】如未来教育上机考试第三套试题第10题：“ IP 地址块 202.113.79.0&#x2F;27、202.113.79.32&#x2F;27、202.113.79.64&#x2F;26 经过聚合后可用的地址数为___” 本题中“&#x2F;”后边的数字前两个是相同的，第三个与前两个不同。所以遇到这种题，直接将三个 IP 聚合得到地址块，然后求出三个 IP 的可用地址数。 2.1.7 路由表距离更新例：R1,R2 是一个系统中采用RIP路由协议的两个相邻路由器，R1 的路由表如（a）所示，R1 收到 R2 发送的报文（b）后，R1 更新后的距离值从上到下依次是（ ）解：做法如下步骤为：b距离+1；与a距离比较；更新为距离最小的。则更新后的距离值从上到下依次是 0、4、4、3、2 还经常这样考——给出更新后距离值和（a）中的距离，求（b）报文距离的可能值。规则不变，上面的做法反过去求就行。 2.1.8 IPv6 地址简化表示例：某地址 FF23:0:0:0:0510:0:0:9C5B，可以简化为 FF23::0510:0:0:9C5B，双冒号替代连续出现的 0 位段，不能简化为 FF23::0510::9C5B，因为双冒号只能使用一次，可以简化为 FF23::510:0:0:9C5B，因为 0510 就是 510 ，不能简化为 FF23::051:0:0:9C5B，因为 0510 不是 51。 例：下列 IPv6 地址表示中错误的是（ ）A) ::10F:BC:0:0:03DAB) FE::0:45:03&#x2F;48C) FE31:0:BC:3E:0:050D:BC::03DAD) FF34:42:BC::3E:50F:21:03D解：IPv6 地址是 128 位划分为 8 段的地址，而 C 项不算双冒号那段已经有了 8 段，双冒号又至少压缩一个 0 位段，所以超了 8 段，是错误的。B 中的 &#x2F;48 做题时可以忽略，写不写没关系。做这种题先看最长的那项有没有超过 8 段。 2.1.9 数据包例：下图是 A 发送的数据包通过路由器转发到 B 的过程示意图，求数据包 3 中的目的IP地址和目的MAC地址解：无论哪个数据包，目的 IP 地址就是 B 的 IP 地址，所以数据包 3 的目的 IP 为 129.42.56.216；而目的 MAC 地址就是下一个路由器的 MAC 地址，数据包 3 的下一个路由器是 R3，所以数据包 3 的目的 MAC 地址是 00d0.63c3.3c41。 2.1.10 三种备份备份速度从快到慢：增量备份、差异备份、完全备份（备份越详细越慢）恢复速度从快到慢：完全备份、差异备份、增量备份（和上面顺序相反，也好理解，备份时详细的恢复快）空间占用从多到少：完全备份、差异备份、增量备份（备份越详细占用空间越多）题目通常问你其中某一种的顺序。 2.2 第二类选择题这部分将进一步体现本指南的优越性我们先来看一道“第二类选择题”的四个选项，不需要看题。-从这开始-到这结束看起来异常复杂，但这是在我完全不懂知识点的情况下就能选对的题。下面要讲的是技巧方法，不是知识点，适用于这类题首先，你需要来回观察这四个选项，找出他们的不同点。可能是两句颠倒的代码，可能是一个单词一个数，也可能是其他的。这是我把他们不同的地方做了荧光标记首先一眼看上去，C 项的大段数字位置和其他三项不一样，所以排除 C；然后，看蓝色的数字，只有 A 项和其他三项不一样，所以排除 A；最后，看绿色的地方，只有 B 项少了一句，所以排除 B；选 D。 悟性比较高的同学肯定已经明白了，为了大家更好的体会，再换一道题演示：不先写选项了，直接展示标记后的方法一样，找出不同点，然后“少数服从多数”，最后选 C。 下面一道题自己练习一下答案是C。 说出来你可能不信，这种方法可以解决80%以上的“第二类选择题”，有的题可能没办法排除掉三个选项，这时候就要结合一下题目内容推断来做或者蒙。 2.3 第三类选择题下面列举的是高频考点，需要记忆，但不要死记。一开始可能感觉很陌生很难，做题碰见得多了就熟悉了能迅速选出答案。 2.3.1 弹性分组环 RPR 每一个节点都执行SRP公平算法 与 FDDI 一样使用双环结构 传统的 FDDI 环，当源结点向目的节点成功发送一个数据帧之后，这个数据帧由源结点从环中回收 而 RPR 环，当源结点向目的节点成功发送一个数据帧之后，这个数据帧由目的结点从环中回收 RPR 采用自愈环设计思路，能在 50ms 时间内隔离故障结点和光纤段 两个 RPR 结点间的裸光纤最大长度可达 100公里 RPR 的外环（顺时针）和内环（逆时针）都可以用于传输分组和控制分组 2.3.2 无线接入技术 主要有 WLAN、WiMAX、WiFi、WMAN 和 Ad hoc ( WiFi 肯定知道，记住无线技术一般是W开头的，但有个特殊的A开头) APON 不是无限传输技术，这个经常是迷惑项 2.3.3 广域网 QoS考的时候通常只写英文缩写，下面写上中文名是为了方便你记忆（其他的地方也应该养成粗略推测英文缩写的习惯） 主要的技术有 资源预留（RSVP）、区分服务（DiffServ）、多协议标记交换（MPLS） 2.3.4 接入技术特征 ASDL 使用一对铜双绞线，具有非对称技术特性，上行速率 64 kbps640 kbps，下行速率 500 kbps7 Mbps 采用 ADSL 技术可以通过 PSTN 接入 Internet Cable Modom（电缆调制解调器）利用频分复用的方法将信道分为上行信道和下行信道，把用户计算机与有线电视同轴电缆连接起来 光纤传输距离可达 100km 以上（这个知道光纤很远就行了） 2.3.5 服务器技术 热插拔功能允许用户在不切断电源的情况下更换硬盘、板卡等（不能更换主板卡） 集群技术中，如果一台主机出现故障，不会影响正常服务，但会影响系统性能 磁盘性能表现在储存容量和 I&#x2F;O 速度（I&#x2F;O&#x3D;input&#x2F;output 即输入&#x2F;输出，学过计算机应该知道） 服务器总体性能取决于 CPU 数量、CPU 主频、系统内存、网络速度 2.3.6 综合布线 双绞线可以避免电磁干扰 嵌入式插座用来连接双绞线 多介质插座用来连接铜缆和光纤，满足用户“光纤到桌面”的需求 建筑群子系统可以是多种布线方式的任意组合，地下管道布线是最理想的方式 STP 比 UTP 贵、复杂、抗干扰能力强、辐射小 水平布线子系统电缆长度在 90 m 以内 干线线缆铺设经常采用点对点结合和分支结合两种方式 2.3.7 BGP 协议 BGP 是边界网关协议，而不是内部网关协议（所以遇到问某两个自治系统之间使用什么协议，就选 BGP） BGP 交换路由信息的节点数不小于自治系统数 一个 BGP 发言人使用 TCP（不是UDP）与其他自治系统的 BGP 发言人交换信息 BGP 采用路由向量协议，而 RIP 采用距离向量协议 BGP 发言人通过 update 而不是 noticfication 分组通知相邻系统 open 分组用来与相邻的另一个 BGP 发言人建立关系，两个 BGP 发言人需要周期性地交换 keepalive 分组来确认双方的相邻关系 2.3.8 RIP 协议 RIP 是内部网关协议中使用最广泛的一种协议，它是一种分布式、基于距离向量的路由选择协议，要求路由器周期性地向外发送路由刷新报文 路由刷新报文主要内容是由若干个（V，D）组成的表。V 标识该路由器可以到达的目标网络（或目的主机）；D 指出该路由器到达目标网络（或目标主机）的距离。距离D对应该路由器上的跳数。其他路由器在接收到某个路由器的（V，D）报文后，按照最短路径原则对各自的路由表进行刷新 使用 RIP v1 路由协议在配置网络地址时无须给定子网掩码 2.3.9 OSPF 协议 OSPF 是内部网关协议的一种，每个区域有一个 32 位的标识符，区域内路由器不超过 200 个 区域内每个路由器包含本区域的完整网络拓扑，而不是全网的情况（拓扑的意思是链接形式和位置关系之类的） 链路状态“度量”主要指费用、距离、延时、带宽等 OSPF 采用洪泛法交换链路状态信息 2.3.10 集线器 工作在物理层，连接到一个集线器的所有结点共享一个冲突域 集线器不是基于 MAC 地址完成数据转发，而是用广播的方法 在链路中串接一个集线器可以监听数据包 每次只有一个结点能够发送数据，而其他的结点都处于接收数据的状态。这些结点执行CSMA&#x2F;CD介质访问控制方法 2.3.11 交换机 是一种工作在数据链路层的网络设备，基本功能是维护一个表示 MAC 地址和交换机端口对应关系的交换表 在源端口与目的端口间建立虚链接 具有三种交换模式：1.快速转发直通式，接收到前 14 个字节就转发数据；2.碎片丢弃式，缓存前 64 个字节；3.储存转发式，转发之前读取整个帧 三层交换机是具有部分路由器功能的交换机，用于加快大型局域网内部的数据交换 2.3.12 路由器 丢包率是衡量路由器超负荷工作时的性能指标之一 背板能力决定路由器吞吐量 传统路由器一般采用共享背板的结构，高性能路由器一般采用交换式的结构 突发处理能力不是以最小帧间隔值来衡量的 语音视频业务对延时抖动要求较高 高端路由器应达到：无故障连续工作时间大于 10 万小时；故障恢复时间小于 30 分钟；切换时间小于 50 毫秒 2.3.13 IEEE 802.11 IEEE 802.11 最初定义的三个物理层包括了两个扩频技术和一个红外传播规范，无线频道定义在 2.4GHz ISM频段，传输速度 1~2 Mbps 802.11b 最大容量 33 Mbps，将传输速率提高到 11 Mbps，802.11a和802.11g 将传输速率提高到 54 Mbps IEEE 802.11d 是当前最流行的 STP（生成树协议）标准 IEEE 802.11b 标准使用的是开放的 2.4GHZ 频段，无须申请就可以直接使用 2.3.14 蓝牙 同步信道速率 64 kbps，跳频速率为 1600 次&#x2F;s 工作在 2.402 ~ 2.480 GHz 的 ISM 频段 非对称的异步信道速率为 723.2 kbps &#x2F; 57.6 kbps 对称的异步信道速率为 433.9 kbps 发射功率为100mw时，最大传输距离为100米 2.3.15 Serv-U FTP 服务器 使用动态 IP 地址时，服务器 IP 地址应配置为空，而不是 0.0.0.0。（为空代表全部 IP 地址） 每个 Serv-U FTP 服务器中的虚拟服务器由 IP 地址和端口号唯一识别，而不是依靠 IP 地址 向服务器中添加“anonymous”，系统自动判定为匿名。而不是创建新域时自动添加一个“anonymous”匿名 服务器最大用户数是指服务器允许同时在线的最大用户数量 用户上传下载选项要求 FTP 客户端在下载信息的同时也要上传文件 2.3.16 DNS 服务器 允许客户机在发生更改时动态更新其资源记录 DNS 服务器中的根服务器被自动加入到系统中，不需管理员手工配置 转发器是网络上的 DNS 服务器（不是路由器），用于外域名的 DNS 查询 使用 nslookup 命令可以测试正向和反向查找区域 主机记录的生存时间指该记录被客户端查询到，放在缓存中的持续时间 2.3.17 DHCP 服务器 负责多个网段 IP 地址分配时需配置多个作用域 添加保留时需在 DHCP 客户机上获得其 MAC 地址信息（添加排除时不需从客户端获得 MAC 地址） 不添加排除和保留时，服务器可将地址池内的 IP 地址动态指派给 DHCP 客户机 地址池是作用域应用排除范围之后剩余的 IP 地址 保留是指确保 DHCP 客户端永远可以得到同一 IP 地址，客户端可以释放该租约 收到非中继转发的“DHCP发现”消息时,选择收到该消息的子网所处的网段分配 IP 地址 2.3.18 WWW 服务器 Web 站点可以配置静态和动态 IP 地址 访问 Web 站点时可以使用站点的域名或站点的 IP 地址 建立 Web 站点时必须为该站点指定一个主目录好，也可以是虚拟的子目录 Web 站点的性能选项包括影响带宽使用的属性和客户端 Web 连接的数量 在 Web 站点的主目录选项卡中，可配置主目录的读取和写入等权限 2.3.19 Wmail 邮件服务器 Winmail 用户不可以使用 Outlook 自行注册新邮箱 Winmail 快速设置向导中创建新用户时，输入新建用户的信息，包括用户名、域名及用户密码（不是系统邮箱的密码） 建立路由时，需在 DNS 服务器中建立该邮件服务器主机记录和邮件交换器记录 邮件系统工作过程：1.用户在客户端创建新邮件；2.客户端软件使用 SMTP 协议将邮件发到发件方的邮件服务器；3.发件方- 邮件服务器使用 SMTP 协议将邮件发到收件方的邮件服务器；4.接收方邮件服务器将收到邮件储存待处理；5.接收方客户端- 软件使用 POP3 或 IMAP4 协议从邮件服务器读取邮件 邮件交换器记录的配置只能在服务器上，不能通过浏览器配置 Winmail 支持基于 Web 方式的访问和管理，管理工具包括系统设置、域名设置等 发送邮件时通常采用 SMTP 协议，接收邮件时通常采用 POP3 或者 IMAP 协议。Winmail 用户使用浏览器查看邮件会使用到 HTTP 协议 2.3.20 PIX 防火墙 监视模式中，可以更新操作系统映像和口令恢复 防火墙开机自检后处于非特权模式，输入“enable”进入特权模式 2.3.21 可信计算机评估准则 没有保护就是 D类，不能用于多用户环境下重要信息处理 提到用户自主保护就是 C类 2.3.22 入侵防护系统 HIPS 基于主机的入侵防护系统，安装在受保护的主机系统中 NIPS 基于网络的入侵防护系统，布置在网络出口 AIPS 基于应用的入侵防护系统，部署于应用服务器前端（他们的首字母 H、N、A 即 Host、Net、Application） 2.3.23 网络攻击 DDos 攻击：利用已经攻占的多个系统向目标攻击，被害设备面对大量请求无法正常处理而拒绝服务 SYN Flooding 攻击：利用 TCP 三次握手过程，使受害主机处于会话请求之中，直至连接超时停止响应 SQL 注入攻击：属于利用系统漏洞，防火墙（基于网络的防护系统）无法阻断 Land攻击：向某个设备发送数据包，并将数据包的源 IP 地址和目的地址都设置成攻击目标的地址 基于网络的防护系统也无法阻断 Cookie篡改 和 DNS欺骗 Tear doop 、Smurf 攻击可以被路由器阻止 2.3.24 无线局域网设备 无线接入点（AP）：集合无线或者有线终端（类似于集线器和交换机），负责频段管理和漫游工作（SSID 是客户端设备用 来访问接入点的唯一标识） 无线路由器：具有无线路由功能和 NAT 功能的 AP ，可用来建立小的无线局域网。 无线网桥：用于连接几个不同的网段，实现较远距离的无线通信（网桥最重要的维护工作是构建和维护 MAC 地址表） 无线网卡：实现点对点通信，安装于各终端节点 2.3.25 VLAN VLAN name 用 1~32 个字符表示，它可以是字母和数字。不给定名字的 VLAN 系统自动按缺省的 VLAN 名（VLAN00xxx） VLAN ID的取值范围是 1~4094。其中无法执行“no vlan 1”命令 2.3.26 Cisco 路由器上的存储器 Flash 主要用于存储当前使用的操作系统映像文件和微代码 NVRAM 主要存储启动配置文件或备份配置文件 RAM 主要存储路由表、快速交换缓存、ARP 缓存、数据分组缓冲区和缓冲队列、运行配置文件等 ROM 主要用来永久保存路由器的开机诊断程序、引导程序和操作系统软件 2.3.27 防火墙对应端口的连接方案pix525 在缺省情况下 ethernet0 被命名为外部接口 outside，安全级别是 0 ethernet1 被命名为内部接口 inside，安全级别是 100 ethernet2 被命名为中间接口 dmz，安装级别是 50 2.3.28 STP 生成树结构 无论是根的确定，还是树状结构的生成，主要依靠 BPDU 提供的信息 Bridge ID 由两个字节的优先级值和 6 个字节的交换机 MAC 地址组成，优先级取值范围是0~61440，增值量是4096，优先值越小，优先级越高 MAC 地址最小的为根网桥 BPDU 数据包有两种类型，配置 BPDU 不超过 35 个字节，拓扑变化通知 BPDU 不超过 4 个字节 2.3.29 Catelyst 配置命令 Catelyst3548 设置时间的格式是：clock set 小时:分钟:秒 日 月 年 Catelyst6500 设置时间的格式是：set time 星期 月&#x2F;日&#x2F;年 小时 分钟 秒 2.3.30 其他有一些知识点因为考频不是很高或者比较复杂，就不写了，自己做题时积累或者放弃。 在遇到陌生题目时，试着结合常识思考推断。比如说，某网络计划有三台计算机，但只有一个 VALN 端口，需要的设备是（）这里需要的其实就是路由器，联想宿舍上网的情况 3.大题（前四道每道10分，最后一道20分）3.1 第一道 填地址表例： IP 地址 115.151.29.58 子网掩码 255.240.0.0 地址类别 【1】 网络地址 【2】 直接广播地址 【3】 主机号 【4】 子网内第一个可用 IP 地址 【5】 解： IP 地址类别 IP 首段范围 A类 1~127 B类 128~191 C类 192~223 则【1】填：A类对 IP地址和子网掩码做如下处理：熟练以后其实没有看起来这么麻烦，做两道就会了。少数情况会给出表格的后两项，让你补充前五项，原理其实是一样的，倒推一下。这道题是大题里面考点最稳定的一道，必须掌握。 3.2 第二道 配置路由器例：一般就考这些空，做几道之后就能填上大部分，小部分可以放弃。 3.3 第三道 DHCP 报文例： 3.4 第四道 sniffer 数据包例1：根据图中信息回答以下问题 该主机执行的命令是（ ），该主机配置的 DNS 服务器的 IP 地址是（ ）解：看图中有 ICMP 几个字母，还有个邮箱地址，所以命令是 tracert mail.tj.edu.cn，DNS服务器的 IP 地址是第一行第二个地址 202.113.64.3（只要这么问，就基本是第一行第二个） 图中 ② ③ ④ 处分别是（ ）解：② 处前面 Protocol 意思是协议，协议就是 ICMP；③ 写源地址，就是第一行第一个地址 202.113.64.137；④ Destination address 意思是目的地址，这个位置应该写题中有的网址 mail.tj.edu.cn。例2：根据图中信息回答以下问题 该主机配置的域名服务器的 IP 地址是（ ）解：和上题一样，还是第一行第二个 202.113.64.3 ① 处的信息应该是（ ）解：填 ACK。一般都是有一个 SEQ，后再有一个 ACK，接着再有 SEQ，再有 ACK。他们的数值每次 +1，有时候会根据上下行填数字。 主机 202.38.97.197 是（ ）服务器，其提供服务的端口是（ ）解：因为图中有 FTP 几个字母，所以这是 ftp服务器；提供服务的端口是 21（DNS服务器的端口是 53，邮件服务器的端口是 6） 该主机执行的命令是（ ）解：填 ftp ftp.pku.edu.cn（网站在图中，前面加 ftp）这道题通常就考上面这两种模式，一种有 ICMP 对应 tracert mail.tj.edu.cn 的，一种有 FTP 对应 ftp ftp.pku.edu.cn 的。如果让写 URL 就是 https://mail.tj.edu.cn 或者 ftp://ftp.pku.edu.cn（中间都没有空格，我为了格式不自动转换成链接才加的） 第四道大题也是考点很不稳定的一道。 3.5 最后一道 3.5.1 填表部分（12分）目的网络&#x2F;掩码长度 输出端口 【1】 S0（直接连接） 【2】 S1（直接连接） 【3】 S0 【4】 S1 【5】 S0 【6】 S1 解：图中最上方的 RG 有两个分支，左侧分支是 S0 ，有末段为 129 和 130 的两个地址，进行聚合：所以【1】处填 192.168.6.128&#x2F;30 ；同理【2】处是 192.168.6.133 和 192.168.6.134 聚合，结果为 192.168.6.132&#x2F;30。做题实际上只要写出最后那段就行，前面选择题时已经说过了。 【3】是 RE 下方 192.168.6.65、192.168.6.66、192.168.6.67 三个子网的聚合；【4】是 RF 下方 192.168.6.80、192.168.6.81、192.168.6.82 三个子网的聚合；【5】是 左下方 192.168.64.0&#x2F;24、192.168.65.0&#x2F;24、192.168.66.0&#x2F;24、192.168.67.0&#x2F;24 四个地址块的聚合；【6】是 右下方 192.168.96.0&#x2F;24、192.168.97.0&#x2F;24、192.168.98.0&#x2F;24、192.168.99.0&#x2F;24 四个地址块的聚合； 在【3】【4】两空聚合时往往需要多注意最终答案应为【3】192.168.6.64&#x2F;29【4】192.168.6.64&#x2F;27【5】192.168.64.0&#x2F;22【6】192.168.96.0&#x2F;22 这个填表是必拿分的题。 3.5.2 中间部分（2~4分）这部分考点很不固定，下面是频率稍高的，考试这几分放弃也可以 问在某路由器上，最多还可链接的路由器数量是多少。如果所在子网掩码是 &#x2F;29 就填 3，是 &#x2F;28 就填 11。 问串接一种设备能监听路由器之间的流量，写 TAP 问串接一种设备能提供安全保护，一般是 IPS 问防火墙访问外网设置，分别填 nat 和 global 3.5.3 计算子网掩码和 IP 段部分（4~6分）例：将 192.168.66.128&#x2F;25 划分为三个子网，子网 1 能容纳 50 台主机，子网 2 和 3 能分别容纳 20 台主机……求他们的子网掩码和可用 IP 地址段 解：题中说多少台主机的具体数字不重要，刚好大于那个数字的 2 的 n 次方的数才重要。比如 50 台，就是 64，是 2 的 6 次方。所以子网掩码后 6 位都是 0 （前面全是 1 ），11111111.11111111.11111111.11000000 ，最后填空写 255.255.255.192同理 20 台，就是 32，是 2 的 5次方。所以子网掩码后 5位都是 0，最后填空 2 和 3 的子网掩码都是 255.255.255.224 可用 IP 地址从题目所给的那个数 +1 开始，本题是 192.168.66.129（因为太乱，下面只写末段数字，反正前面都一样）从 129 开始，因为子网 1 的那个数字是 64 ，所以到 190 结束（129+64-3&#x3D;190，不用管为什么，结束都是 -3）下一段从 193 开始（190+3&#x3D;193，不用管为什么，开始都是 +3），因为子网 2 的那个数字是 32 ，所以到 222 结束（193+32-3&#x3D;222）再下一段从 225 开始（222+3&#x3D;225），因为子网 3 的那个数字也是 32 ，所以到 254 结束（225+32-3&#x3D;254）写成答案分别为：子网 1 的可用 IP 地址段为 192.168.66.129192.168.66.190子网 2 的可用 IP 地址段为 192.168.66.193192.168.66.222子网 3 的可用 IP 地址段为 192.168.66.225~192.168.66.254 看起来上面写了一大堆，其实明白了就很简单，这个也是必拿分的题。 总结：得分策略目标是通过考试，也就是 60 分 选择题部分：前面一共写了 10 个做法固定的“第一类选择题”，还有 19 个“第三类选择题”的高频考点，加上“第二类选择题”。选择题得分在 20 分以上是很保守的估计，没有意外的话选择题应该在 25 分以上。 大题部分：第一道的 10 分是必得的，最后一道除了中间部分后有 16 分是必得的。从前面写的也能看出第二、三、四道大题的考点不是特别固定，所以尽量写，填对一半就很好了（其实也没有那么难），所以这三道大题 30 分目标是得 15 分。来算一下 20 + 10 + 16 + 15 &#x3D; 61 分。实际情况当然可能会出现意外，比如三道大题没得到 15 分，但刚才也没算你蒙对的题得分。 多练习几套题，来回对照着知识点就熟悉了，这个考试题型固定，含金量不高，难度不大，不用害怕。题库软件有很多缺陷，比如大题评分不准、填空题缺少空格，甚至是答案错误。自己要注意核对。这份文档并未涵盖所有知识点，多做一套题就多了一分考过的把握。 （未来教育题库的第九套题有点特殊，看起来像 13 年考试改革之前的老题，和其他套的题有很大差别，留意一下。） 完。2017&#x2F;3&#x2F;19 初版2017&#x2F;4&#x2F;25 修改了前言与总结2017&#x2F;5&#x2F;12 修改内容略2017&#x2F;5&#x2F;16 刚查到成绩，84分，本来还以为能上90…2017&#x2F;8&#x2F;23 补充了备考建议2017&#x2F;9&#x2F;12 改正了 2.1.6 IP地址块聚合2017&#x2F;9&#x2F;21 增加了 2.3 中近一半的内容，感谢佚名进行的补充2017&#x2F;12&#x2F;18 考试获证条件改变，三级不再需要对应的二级科目通过","tags":["转载","计算机三级","网络技术"],"categories":["网络技术"]},{"title":"计算机三级-题型","path":"/NCRE3-Net/","content":"3.8目前宽带城域网保证服务质量QoS要求的技术主要有资源预留（RSVP）、区分服务（DiffSerV）和多协议标记交换 (MPLS)。 RPR采用自愈环的设计思想，能够在50ms的时间内隔离出现故障的结点和光纤段，提供SDH级的快速保护和恢复，同时不需要像SDH那样必须有专用的带宽因此文进一步提高了环带宽的利用率。 电缆调制解调器（CableModem）专门为利用有线电视网进行数据传输而设计。CableModem把用户计算机与有线电视同轴电缆连接起来。 OC-3：155.520MbpsOC12：622.80Mbps 全双工端口带宽计算方法：端口数*端口速率*2 1Gbps &#x3D; 1000Mbps 192.168.1.0&#x2F;24 子网掩码：11111111.11111111.11111111.00000000 —–&gt;255.255.255.0211.81.12.129&#x2F;28 子网掩码：11111111.11111111.11111111.11110000 —–&gt;255.255.255.240 Source 源Destnition 目的 59.67.159.0&#x2F;26 59.67.159.00 |0|0000059.67.159.64&#x2F;26 59.67.159.00 |1|0000059.67.159.128&#x2F;26 59.67.159.01 000000 3.9综合题 IP地址 191.23.181.13 子网掩码 255.255.192.0 地址类别 B类 网络地址 191.23.128.0 直接广播地址 191.23.191.255 主机号 0.0.53.13 子网内的最后一个可用IP地址 191.23.191.254 地址段类型 地址段 A 1.0.0.0 - 127.255.255.255 B 128.0.0.0 - 191.255.255.255 C 192.0.0.0 - 223.255.255.255 D 224.0.0.0 - 255.255.255.254 网络地址：IP地址中网络位不变，主机位为0的地址 直接广播地址 ：IP地址网络位不变，主机位为1的地址 如何分辨网络位和主机位：根据子网掩码以 191.23.181.13，子网掩码 255.255.192.0 为例： 将IP地址与子网掩码全部转换为二进制： 191.23.181.13：10111111.00010111.10110101.00001101255.255.192.0：11111111.11111111.11|000000.00000000 从子网掩码得出，前18位是网络位（子网掩码中为1的部分），后14位是主机位（子网掩码中为0的部分） 得到网络地址（主机位全变0）：10111111.00010111.1000000.00000000，转换为十进制：192.23.128.0 得到直接广播地址（主机位全变1）：10111111.00010111.10111111.11111111，转换为十进制：191.23.191.255 得到主机号（网络位全变0）：00000000.00000000.00110101.00001101，转换为十进制：0.0.53.13 得到子网内最后一个可用IP地址（直接广播地址的前一个地址）：191.23.191.254 综合题 2本题涉及的内容有：路由器POS接口配置、lookback接口配置、OSPF动态路由协议配置、静态路由的配置 和 DHCP服务器配置 （1）POS接口的配置参数有接口带宽、接口地址，接口的链路层协议，接口的帧格式，接口的CRC校验和flag（帧头中净负荷类型的标志位）等。 （2）loopback接口主要用于网络管理。网络管理员为loopback接口分配一个IP地址作为管理地址，其掩码应为255.255.255.255. Router-R3 #configure terminal 进入路由器的全局配置模式 Router-R3 (config)#interface pos4&#x2F;0 进入POS4&#x2F;0接口 Router-R3 (config-if)#description To Internet 该接口连接到互联网 Router-R3 (congfig-if)#bandwidth 10000000 设置了接口的带宽为 10000000，表示该接口的带宽为 10 Mbps Router-R3 (config-if)#ip address 211.68.69.170 255.255.255.252 指定的IP地址为211.68.69.170，子网掩码为255.255.255.252 Router-R3 (config-if)# crc 32 开启 CRC（循环冗余校验）功能，以帮助检测数据在传输过程中是否发生错误 Router-R3 (config-if)#pos framing sdh 希望配置接口的 POS（Packet over SONET）帧格式为 SDH（Synchronous Digital Hierarchy）。SDH是一种光传输网络标准，用于在光纤网络中传输数据。通过将接口的帧格式设置为SDH，可以确保接口与光纤网络兼容。 Router-R3 (config-if)#no ip directed-broadcast 禁止了 IP 直播（Directed Broadcast）功能。禁止 IP 直播可以增强网络安全性，防止网络中的广播消息被转发到其他网络中，从而减少潜在的安全风险 Router-R3 (config-if)#pos flag sls0 2 配置路由器接口的 POS（Packet over SONET）标志。在这条命令中，您设置了 POS 接口的 SLS0（Section Line Signal 0）标志为 2 Router-R3 (config-if)#no shutdown 这条命令通常用于启用路由器接口，使其处于活动状态，开始接收和发送数据流量。 Router-R3 (config-if)exit 退出了接口配置模式，返回到全局配置模式 Router-R3 (config)#router ospf63 配置路由器 R3 的 OSPF 进程，编号为 63 Router-R3 (config-router)#network 221. 89. 23. 0 0.0.0.255 area 0将网络地址 221.89.23.0&#x2F;24（子网掩码为 255.255.255.0）添加到 OSPF 进程中，并指定该网络所属的区域为区域 0 Router-R3 (config-router)#redistribute connected metric-type 1 subnets配置路由器 R3 的 OSPF 进程中进行连接路由的再分发。具体来说，您使用了 “redistribute connected” 命令来将连接路由（即直连路由）纳入 OSPF 进程中进行再分发。通过指定 “metric-type 1 subnets”，您设置了再分发的连接路由的度量类型为类型 1，并包括子网信息。这样做可以使得路由器 R3 将直连的网络信息纳入 OSPF 进程中进行传播，使得其他 OSPF 路由器可以学习到这些直连网络的存在并进行路由选择。 Router-R3 (config-router)#area 0 range 221.89.23.0 255.255.255.0配置 OSPF 进程中的区域范围汇总。通过命令 “area 0 range 221.89.23.0 255.255.255.0”，您指定了在 OSPF 区域 0 中汇总网络地址 221.89.23.0&#x2F;24（子网掩码为 255.255.255.0） Router-R3 (config-router)#exit 退出 OSPF 进程配置模式，返回到全局配置模式 Router-R3 (config)#ip route 0.0.0.0 0.0.0.0 211.68.69.169 添加了一条默认静态路由，将所有目的地流量指向下一跳地址 211.68.69.169 Router-R3 (config)#exit 退出路由器 R3 的全局配置模式，返回到全局配置模式下 Router-R3 # 待机 注意事项： 1.POS: 接口速率：bandwidth 10 000 000 帧格式： flaming sdh：flag s1s0 2 flaming sonet：flag s1s0 0 3.10DHCP：（Dynamic Host Configuration Protocol，动态主机配置协议）使用UDP协议工作，统一使用两个IANA分配的端口：67（服务器端），68（客户端）。DHCP通常被用于局域网环境，主要作用是集中的管理、分配IP地址，使client动态的获得IP地址、Gateway地址、DNS服务器地址等信息，并能够提升地址的使用率。简单来说，DHCP就是一个不需要账号密码登录的、自动给内网机器分配IP地址等信息的协议。 DHCP报文种类DHCP一共有8中报文，各种类型报文的基本功能如下： 报文类型 说明 Discover（0x01) 客户端请求IP地址时不知道服务器的位置 —&gt; 广播Discover报文—&gt;收到的服务器发送应答报文 Offer（0x02） &emsp; 服务器收到Discover报文 —&gt;所配置的地址池中查找一个合适的IP地址，加上相应的租约期限和其他配置信息（如网关、DNS服务器等）以构造Offer报文发送给客户端，告知用户本服务器可以为其提供IP地址。[但这个报文只是告诉DHCP客户端可以提供IP地址，最终还需要客户端通过ARP来检测该IP地址是否重复。] Request（0x03） 1. 客户端在收到的众多Offer报文中选择一个(通常为第一个)，向该服务器发送一个广播的Request报文，通告选择的服务器，希望获得所分配的IP地址。 2. 另外，DHCP客户端在成功获取IP地址后，在地址使用租期达到50%时，会向服务器发送单播Request报文请求续延租约，如果没有收到ACK报文，在租期达到87.5%时，会再次发送广播的Request报文已请求续延租约。 ACK (0x05) 服务器收到Request报文后，根据Request报文中携带的用户MAC来查找有没有相应的租约记录，如果有则发送ACK应答报文，通知用户可以使用分配的IP地址。 NAK（0x06） 如果DHCP服务器收到Request请求报文后，没有发现有相应的租约记录或者由于某些原因无法正常分配IP地址，则向DHCP客户端发送NAK应答报文，通知用户无法分配合适的IP地址。 Release（0x07） 当DHCP客户端不再需要使用分配IP地址时（一般出现在客户端关机、下线等状况）就会主动向DHCP服务器发送RELEASE请求报文，告知服务器用户不再需要分配IP地址，请求DHCP服务器释放对应的IP地址。 Decline（0x04） DHCP客户端收到DHCP服务器ACK应答报文后，通过地址冲突检测发现服务器分配的地址冲突或者由于其他原因导致不能使用，则会向DHCP服务器发送Decline请求报文，通知服务器所分配的IP地址不可用，以期获得新的IP地址。 Inform（0x08） DHCP客户端如果需要从DHCP服务器端获取更为详细的配置信息，则向DHCP服务器发送Inform请求报文；DHCP服务器在收到该报文后，将根据租约进行查找到相应的配置信息后，向DHCP客户端发送ACK应答报文。目前基本上不用了。 TAP：监控流量，汇聚、负载均衡、报文过滤、报文编辑 网络号：将两个IP地址转换成二进制，然后找相同位。不同位取0例：192.168.6.129转换成二进制：11000000.10101000.00000110.10000001192.168.6.130转换成二进制：11000000.10101000.00000110.10000010得网络号：11000000.10101000.00000110.10000000转换成十进制得：192.168.6.128，相同位有30位，因此子网掩码是&#x2F;30 3.11聚合后可用地址数选择.10. IP地址块202.113.79.128&#x2F;27、202.113.79.160&#x2F;27和202.113.79.192&#x2F;27经过聚合后可用的地址数为（） 地址块202.113.79.128&#x2F;27可表示为11001010 01110001 01001111 10 | 000000地址块202.113.79.160&#x2F;27可表示为11001010 01110001 01001111 10 | 100000地址块202.113.79.192&#x2F;27可表示为11001010 01110001 01001111 11 | 000000 前两个IP地址的前26位是完全相同的。因此该两个地址块聚合成 202.113.79.128&#x2F;26聚合后主机位 6 位。可用地址数 2^6-2 &#x3D; 62 个第三个IP地址 可用地址数 2^5-2 &#x3D; 30 个加起来 92 个。 3.15城域网 QoS 【Quality of Service】资源预留协议（RSVP；Resource ReSerVation Protocol）区分服务（DiffServ）多协议标记交换（MPLS；MultiProtocol Label Switching） IEEE802. 11中三种协议的传输率分别是: 802.11b的最大数据传输率为11Mbps, 802.11a的最大数据传输率为54mbps, 802.11g的最大数据传输率为54mbps 3.161.NAT地址转换 2.三地址块聚合地址 3.错误的IPV6地址 4.BGP：不同自治系统 路由向量 BGP发言人 TCP 5.RIP距离值： 后一个表中数值各+1，再与前一个表 每行总共两个数字择小值 6.OSPF: 划分区域，不知道其他区域 32位区域地址标识符 不超过200个 7.集线器： 广播 共享冲突域 串接集线器以监听链路 不能划分vlan CSMA&#x2F;CD介质访问控制方法 8.综合布线 双绞线扭绞：减小干扰 多介质插座：链接铜缆与光纤 STP屏蔽双绞，UTP非屏蔽 适配器：不同信号数模转换，数据速率转换 管道内布线法：建筑群子系统 9.VLAN：虚拟 10.STP BridgeID： 2byte优先级值+6byteMAC地址值 越小越优先 11.Catelist 时间格式： clock set 小时:分钟:秒 日 月 年 12.拨号远程： Console（RJ-45） AUX（AUXiliary）— 可连接 modem 13.缺省路由IP地址看下一跳 14.蓝牙： 对称链接异步信道 433.9 kbit&#x2F;s 非对称链接异步信道 723.2 kbit&#x2F;s &#x3D; 57.6 Kbit&#x2F;s 802.11b 点对点：256 基本：1024 无线有线，接入点 3.18 数据包分组转发： 目的IP始终为终点目标IP不变 目的MAC为下一跳MAC地址 Cisco工作模式： Global configuration 全局配置模式 Privileged EXEC 特权模式 Setup 设置模式 RXBOOT 维护模式 18.Serv-UFTP： 每个虚拟的服务器称作域 域由IP地址和端口号唯一识别 防火墙 outside（Ethernet 0 端口）外部接口安全系数 0 inside 1 内部接口 100 DMI 2 中间接口 50 3.2020.信源为单位：ATM网 光信号为单位：以太网 21.RPR： 自愈环：50ms 每一个节点SRP公平算法 每两个节点裸光纤最大长度100km 内外环都可以数据传输分组与控制分组 22.接入技术： APON（无源光网络）是一种光纤接入技术 Cable Modem利用波分复用 上下行信道 23.路由器技术特征： 高性能路由器：交换式结构 服务质量体现： 队列管理机制 端口硬件队列管理 支持QOS协议 包转发能力相关： 端口数量 端口速率 包长度 包类型 24.全双工交换机： 100&#x2F;1000 Mbps 看大数字 x2 25.建筑群布线子系统： 管道内布线好 直埋布线最差 BPDU：每两秒发送一次 无线设备： 无线接入点：类似有线中的集线器 无线网卡： 点对点 无线网桥： 链接不同网（较远） 无线路由器： 具有路由功能的AP（接入点），一般具有NAT功能 3.22：大题整理 (60分)综合题1：IP地址相互推理 网络地址：网不变主0 直接广播地址：网不变主1 受限广播地址：255.255.255.255 主机号：网0主不变 子网内第一个可用IP地址：网络地址+1 子网内最后一个可用IP地址：直接广播地址-1 综合题2：(1). 路由器 仿真 配置参考一： 参考二： (2). 交换机 仿真 配置","tags":["计算机三级","网络技术"],"categories":["网络技术"]},{"title":"基于 OpenCV-Python 和 Mediapipe 的手部识别教程","path":"/OpenCV/","content":"（初次加载图片可能会比较慢，请耐心等待一下~） 本文意在教你如何在PyCharm上用OpenCV-Python 和 Mediapipe库实现手部识别 （很遗憾，暂时没有什么实际用处，初步了解用） 阅读本文，你将学会： 学会安装Python 学会安装PyCharm 学会给代码配置合适的环境并成功运行代码（手部识别） 使用编译器：PyCharm2023.3.2专业版 编译环境：Python3.7.9 使用库：Numpy，OpenCV-Python，Mediapipe 准备活动：一. Python的安装与环境变量部署1. 下载 Python 最新版本 2.Python安装 3.Python环境变量配置环境变量的配置可以保证在任意路径都能执行程序，而不是拘泥于在命令行所在路径查找 用户变量 &#x2F; 系统变量： 用户变量是对单一用户生效，系统变量对所有用户生效。 二. PyCharm的安装以及相关环境准备1. 下载 PyCharm 最新版本 2.PyCharm的安装以安装免费的PyCharm社区版为例： 3.创建PyCharm项目并正确配置Python解释器 （1）新建项目 （2）新建Python程序文件 （3）给PyCharm做汉化，下载中文语音包，下载完重启后启用 4.程序运行所需软件包安装（OpenCV-Python 和 Mediapipe）前言：软件包资源大多需要从国外服务器上下载，为保证下载速度和下载成功率，我们选择将下载目标地址转向国内镜像源： （1）永久设置pip指定国内镜像源（windows内） （2）然后转回PyCharm设置安装OpenCV-Python:接着安装Mediapipe;然后就是编写程序代码了。 三. 编写代码，运行代码（1）编写代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445import cv2 #导入OpenCv库 import mediapipe as mp #导入Mediapipe库import time cap = cv2.VideoCapture(0) #0为打开默认摄像头,1为打开你设备列表的第二个摄像头,以此类推;mpHands = mp.solutions.hands #使用Mediapipe库的手部姿势估计模型hands = mpHands.Hands(static_image_mode=False, max_num_hands=4, model_complexity=1, min_detection_confidence=0.5, min_tracking_confidence=0.5) #创建手部姿势估计器对象，设置参数。mpDraw = mp.solutions.drawing_utils #初始化Mediapipe库绘图工具handLmsStyle = mpDraw.DrawingSpec(color=(0, 0, 255), thickness=5)handConStyle = mpDraw.DrawingSpec(color=(0, 255, 0), thickness=10) #设置绘制手部关键点和连接线的样式pTime = 0cTime = 0 #用于计算帧率 while True: #无限循环 ret, img = cap.read() #读取摄像头的图像帧 img = cv2.flip(img, 1) #对img图像进行水平翻转 if ret: imgRGB = cv2.cvtColor(img, cv2.COLOR_BGR2RGB) #将图像从BGR格式转换为RGB格式 result = hands.process(imgRGB) #使用手部姿势估计器处理图像，获取结果 # print(result.multi_hand_landmarks) imgHeight = img.shape[0] #获取图像的高度，并将其赋值给变量imgHeight(其中[0]表示高度的维度) imgWidth = img.shape[1] #其中，img是一个图像对象，而shape[1]表示图像的宽度 if result.multi_hand_landmarks: #检查是否检测到手部 for handLms in result.multi_hand_landmarks: #遍历检测到的手部 mpDraw.draw_landmarks(img, handLms, mpHands.HAND_CONNECTIONS, handLmsStyle, handConStyle) #绘制手部关键点和连接线 for i, lm in enumerate(handLms.landmark): #遍历每个关键点 xPos = int(lm.x * imgWidth) #计算关键点在图像中的x坐标 yPos = int(lm.y * imgHeight) #计算关键点在图像中的y坐标 # cv2.putText(img, str(i), (xPos-25, yPos+5), cv2.FONT_HERSHEY_SIMPLEX, 0.4, (0, 0, 255), ) if i == 4: #绘制特定关键点的标记,如果是特定的关键点（在代码中是第5个关键点） cv2.circle(img, (xPos, yPos), 15, (92, 65, 214), cv2.FILLED) print(i, xPos, yPos) #在特定关键点处绘制一个填充的圆 cTime = time.time() #获取当前时间 fps = 1/(cTime-pTime) #计算帧率 pTime = cTime #更新上一帧的时间 cv2.putText(img, f&quot;FPS : &#123;int(fps)&#125;&quot;, (30, 50), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 3) #在图像上显示帧率 cv2.imshow(&#x27;img&#x27;, img) #显示处理后的图像 if cv2.waitKey(1) == ord(&#x27; &#x27;): break #如果按下 &#x27; &#x27; 键，则退出循环 概括：这段代码的功能是实时从摄像头获取图像，并使用手部姿势估计器检测手部关键点并绘制在图像上，同时显示帧率。 PS:这段代码是@GrandmaCan我阿嬤都會的，我给代码添加了注释 如果以后有空就补充关键代码的配置调参，咕咕咕 （2）运行代码及注意事项 成果展示： 教程到这里就结束了。制作不易还望点赞&#x2F;评论&#x2F;关注呀","tags":["计算机视觉","Python","PyCharm"],"categories":["计算机视觉"]},{"title":"Hexo欢迎你(:!","path":"/hello-hexo/","content":"欢迎来到 Hexo! This is 一篇引导文章. Check documentation - 文档 for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting - 故障排除 or you can ask me on GitHub. Quick Start - 快速上手Create a new post - 创建一个新帖子12$ hexo new &quot;My New Post&quot;$ hexo new &quot;xxx&quot; More info: Writing Run server - 运行服务器12$ hexo server$ hexo s More info: Server - 服务器 Generate static files - 生成静态文件12$ hexo generate$ hexo g More info: Generating - 生成 Deploy to remote sites - 部署到远程站点12$ hexo deploy$ hexo d More info: Deployment - 部署 补充：确定部署过程没问题你便可以一步到位：1$ hexo c &amp;&amp; hexo g &amp;&amp; hexo d 注意事项：如果上传遇到了问题，很有可能是网络问题（ Hexo自定义原理 Hexo 系列的博客中的文章都是经Hexo的主题渲染的静态网页。所以Hexo博客大部分都呈现出一种高度的统一化与规范化。不过 Hexo 提供了跳过渲染功能，使得我们可以直接在博客中放入自定义网页。 比如在博客中放入图片、自定义404.html、自定义About页面、简历等 创建自定义网页 网页可以是自己编写的，也可以是别人现成的源码（下载喜欢的页面）。 网页编写完成后，在Hexo\\source目录下创建一个文件夹（文件夹名称任意，比如我创建的是about这个文件夹，部署完成后，访问http://mrlsm.github.io/about即可看到效果，依此类推） 将 html 文件放置于此文件夹，并重命名为 index.html 。 跳过渲染 跳过渲染有下述两种方法： 1.在自定义页面的开头添加如下： --- layout: false --- 123 添加该指令后，执行 hexo g命令时便会跳过该 index.html文件，使得index.html不受当前 hexo 主题影响，完全是一个独立的网页，如果网页引用了 css 或 js，css 和 js 需使用外链或者将css js 文件放入index.html同目录下引用。 引用图片亦是如此 2.在_config.yml文件中设置skip_render 使用编辑器打开 Hexo 目录下的_config.yml文件，找到skip_render skip_render一般有以下四种常用参数： 跳过source目录下的 test.html: skip_render: test.html跳过source目录下 test 文件夹内所有文件：skip_render: test/*跳过source目录下 test 文件夹内所有文件包括子文件夹以及子文件夹内的文件：skip_render: test/** 跳过多个路径： skip_render: - test.html - test/* 123 最后执行： hexo g -d 1 --- Hexo 部署中遇到的问题以及相应的解决方案Hexo错误：spawn failed的解决方法Hexo错误：spawn failed的解决方法 | 张洪Heo (zhheo.com) 解决方案： 在C盘——用户——你的主机名文件夹中找到.ssh文件夹；（此前配置SSH时会生成该文件夹）在.ssh文件夹中新建文件 config,不带后缀（可以新建文本文档，去掉.txt后缀）使用notepad++（或其他方式）打开config文件，输入以下内容，保存后即可 123456Host github.comUser YourEmail（你的邮箱）Hostname ssh.github.comPreferredAuthentications publickeyIdentityFile ~/.ssh/id_rsaPort 443 Hexo d 时显示 CRLF LF Warning 问题、12git config --global core.autocrlf false# Git 配置命令：全局 自动转换换行符 禁止 更新日志：2024： 2.16 网站初建 3.5 初步解决不能稳定上传数据的问题，网站复活 3.7 导入第一篇文章 3.11 实现图片加载 3.12 修改网站图标更正文章链接修改主页标题 3.13 实现GIF加载 3.14 优化网站文章的永久链接格式导入了B站视频（测试中 3.18 尝试引入JavaScript网页小游戏 3.21 创建了github图床，方便了撰写文章时图片的引用 3.22 实现指定篇目取消渲染，添加README 3.26 实现从网站下载文件汉化Hexo引导文章更换域名为顶级域名 opentap.top 3.27 初步配置Netlify（还在研究 3.28 接入萌ICP备 4.1 发布霜晴的避风港.apk 4.2 优化网站图表样式(方形圆角,192x192,png) 4.30 接入Vercel，使用vercel部署 5.11 新增域名 opentap.cn 7.24 在 stellar 主题中配置网站logo、补上友链 9.5 稍微修改了一下页脚 10.16 使用 uptimebot 增加网站状态监控 10.28 在阿里云服务器上部署Alist，开启网盘服务","tags":["博客搭建","Hexo"],"categories":["博客搭建","Hexo"]},{"title":"友链","path":"/friends/index.html","content":"Puresys纯净系统-软件下载"},{"title":"about","path":"/about/index.html","content":"关于"}]